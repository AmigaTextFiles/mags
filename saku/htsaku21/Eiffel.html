<HTML>
<HEAD>
<TITLE>Eiffel-ohjelmointikieli</TITLE>
</HEAD>
<BODY background="Kuvat/Tausta.GIF" bgcolor="#ffffff" text="#000000" link="#109F00" vlink="#095200">

<TABLE WIDTH=100% BORDER=0>
<TR>
  <TD WIDTH=50% ALIGN=LEFT><FONT SIZE=5 FACE="Arial" color="#109f00"><B><I>Eiffel-ohjelmointikieli</I></B></FONT></TD>
  <TD WIDTH=50% ALIGN=RIGHT><FONT SIZE=2><I><B>HtmlSaku #21, 12.4.1997</B></I></FONT><BR>
  <FONT SIZE=3><B>Mikko Koivunalho, <A HREF="mailto:mikkoi@utu.fi"><I>mikkoi@utu.fi</I></A></B></FONT></TD>
</TR>
</TABLE>
<HR width=100% size=2 align=CENTER><BR>
<FONT SIZE=5>E</FONT><FONT SIZE=3>
iffel on nuori ohjelmointikieli. Sen ensimm&auml;inen malli julkistettiin vuonna 1985. 12 vuotta ei ole pitk&auml; ik&auml;, varsinkaan kun ottaa huomioon, ett&auml; kieli on tullut laajemmin tunnetuksi vasta parina viime vuotena. Niinp&auml; Eiffelill&auml; onkin ollut hyv&auml;&auml; aikaa puhdistautua alkuvaiheen virheist&auml; ja suunnitteluvioista. Kuitenkin sen m&auml;&auml;rittely&auml; on muutettu merkitt&auml;v&auml;sti vain kerran, 1991, ja nykyinen Eiffel-malli, Eiffel 3, on sittemmin pysynyt muuttamattomana.<BR><BR>
Eiffel-standardi on pysynyt samanlaisena, koska Eiffelin kehitys on p&auml;&auml;osin yksiss&auml; k&auml;siss&auml;: Bertrand Meyerin ja ISE:n (Interactive Software Engineering), ja kielen standardina pidet&auml;&auml;n Meyerin kirjaa <I>"Eiffel, The Language"</I>. Nimens&auml; Eiffel on saanut ranskalaiselta insin&ouml;&ouml;rilt&auml; Alexander Gustave Eiffelilt&auml; [efe'l] (1832-1923). Kielen suunnittelussa Meyer on seurannut Eiffelin omaa ideologiaa, jonka mukaan rakenteiden itsens&auml; (p&auml;&auml;osin rautaa, esim. Eiffelin torni) tulee olla kaunista katseltavaa symmetrisyydess&auml;&auml;n, yksinkertaisuudessaan ja t&auml;sm&auml;llisyydess&auml;&auml;n.<BR><BR>
Eiffel on uusi kieli, jonka suunnittelussa on tieten tahtoen hyl&auml;tty suuri joukko vanhemmissa kieliss&auml; k&auml;ytett&auml;vi&auml; ohjelmointimetodeja ja otettu k&auml;ytt&ouml;&ouml;n uusia. Paitsi ett&auml; se on t&auml;ysiverinen oliosuuntautunut kieli, se on my&ouml;s pikkutarkka ja perinteisiin kieliin n&auml;hden syntaksiltaan yksinkertainen sek&auml; ohjelmoijalta runsasta etuk&auml;teissuunnittelua vaativa.<BR><BR>
Eiffelin filosofiaa ymm&auml;rt&auml;&auml;kseen on tarkasteltava perinteisi&auml; kieli&auml; ja niiden ongelmia. Jo kauan ennen Eiffeli&auml; ohjelmoinnin metodologian tutkijat esittiv&auml;t, ett&auml; mm. <B>GOTO</B>-komento ei miss&auml;&auml;n nimess&auml; kuulu asialliseen ohjelmointiin, koska se sallii ohjelman suoritusj&auml;rjestyksen t&auml;ydellisen rikkomisen. T&auml;m&auml; ja vastaavanlaiset piirteet, mm. funktion tai ohjelman keskeytys ennen loppua, on t&auml;ysin poistettu Eiffelist&auml;.<BR><BR>
Edelleen Eiffelin syntaksia on radikaalisti yksinkertaistettu laittamalla siihen vain kolme suorituksenohjauslauseketta: yksi ehtolauseke, yksi toistolauseke ja yksi valintalauseke (moniehto-, C:ss&auml; <I>switch</I>). Perinteisiss&auml; kieliss&auml;h&auml;n n&auml;it&auml; on monissa ollut kasap&auml;in, esim. C-kielen <I>while-, do-while-</I> ja <I>for</I>-silmukat. Miksi laittaa monenlaisia toistolausekkeita sotkemaan ohjelmakoodia, kun kerran yksi riitt&auml;&auml; kaikkiin tarpeisiin hiukan sovittamalla?<BR><BR>
Eiffel on my&ouml;s voimakkaasti tyypitetty kieli. Tavanomaisten vanhoista kielist&auml; tuttujen tyyppien kuten <B>REAL</B>, <B>INTEGER</B> ja <B>BOOLEAN</B> lis&auml;ksi siihen on "sis&auml;&auml;nrakennettu" muita tyyppej&auml;, jotka useimmista kielist&auml; puuttuvat kokonaan tai ne on toteutettu kielen itsens&auml; ulkopuolella, esim. vektori, lineaarinen lista, pino ja jono.<BR><BR>

</FONT><FONT SIZE=4><B>Oliokieli</B></FONT><BR><BR>
<FONT SIZE=5>E</FONT><FONT SIZE=3>
dell&auml; kirjoitin "sis&auml;&auml;nrakennettu" lainausmerkeiss&auml;. Ilmaisu sallittakoon minulle, vaikka nyt selit&auml;nkin, miksi n&auml;in ei oikeastaan voi olla: Eiffel on puhdas oliokieli, joten kaikkien sen ominaisuuksienkin tulee olla olioita.<BR><BR>
Tietorakenteet eli tietotyypit onkin kaikki toteutettu olioina. Niinp&auml; esimerkiksi vektoria tai listaa voi kasvattaa tai kutistaa kulloisenkin olion sis&auml;ll&auml; vaivaamatta p&auml;&auml;ohjelmaa. Muita erikoisia tietotyyppej&auml; ovat mm. puu-tyyppi, jolla on aina kaksi oksaa ja yksi juuri, tai graafi, viel&auml; puurakennettakin monipuolisempi joukkotyyppi. Edell&auml; mainittuja ja muita tyyppej&auml; voidaan k&auml;ytt&auml;&auml; mm. erityyppisen tiedon tallennukseen ja helppoon j&auml;rjest&auml;miseen. Muita tietorakenteita voi luoda omaan tarpeeseen omina olioinaan, jotka sitten voi liitt&auml;&auml; per&auml;kk&auml;in vaikka vektoriin tai jonoon.<BR><BR>
Ohjelmointia helpottaa my&ouml;s automaattinen roskienker&auml;&auml;j&auml;, joka vapauttaa niiden olioiden varaaman muistin, joihin ei en&auml;&auml; ole osoitinta. T&auml;m&auml; tietysti hidastaa ohjelman suoritusta hivenen, mutta toisaalta nopeuttaa valtaisasti sen tekemist&auml;, koska muistivuotoja ei synny. Niiden paikkailuunhan aikaa eniten tuhraantuu koodattaessa ja virheit&auml; korjattaessa.<BR><BR>

</FONT><FONT SIZE=4><B>Eiffelin toteutus</B></FONT><BR><BR>
<FONT SIZE=5>N</FONT><FONT SIZE=3>
ykyisiss&auml; Eiffel-ymp&auml;rist&ouml;iss&auml; Eiffel-koodia ei suinkaan k&auml;&auml;nnet&auml; suoraan konekieleen vaan k&auml;ytt&auml;en v&auml;likielen&auml; C:t&auml;.<BR><BR>
Varsinainen ISE:n Eiffel on isojen koneiden kieli. Sen p&auml;&auml;tarkoitus on "programming in large", siis suurten ohjelmistojen ohjelmointi. Niinp&auml; ISE:n oma Eiffel-paketti on paljon muutakin kuin vain itse k&auml;&auml;nt&auml;j&auml;. Se on p&auml;&auml;asiassa Unix-purkeille tarkoitettu megojen kokoinen kokoelma ohjelmoijan ty&ouml;kaluja, valmiita kirjastoja ja oliokokoelmia mm. graafisen ymp&auml;rist&ouml;n luomiseen tai verkkosovellusten ohjelmointiin. ISE:n paketissa on jopa oma kieli, LACE, ACE-tiedostojen eli perinteisemmin "make"-tiedostojen tekemiseen (siis k&auml;&auml;nt&auml;misen ja linkityksen m&auml;&auml;rittelyihin).<BR><BR>
Sittemmin ISE on alkanut tehd&auml; vastavanlaista pakettia my&ouml;s PC-yhteensopiviin (p&auml;tkitty, mutta toimiva malli on saatavilla ilmaiseksi Maailmanseitist&auml;, osoitteesta <A HREF="http://www.eiffel.com/"><I>http://www.eiffel.com/</I></A>). On my&ouml;s olemassa ilmainen, GNU-lisenssill&auml; levitett&auml;v&auml; SmallEiffel-k&auml;&auml;nt&auml;j&auml;, jonka sorsakoodit on valmiiksi sovitettu GNU C -k&auml;&auml;nt&auml;jiin tusinassa eri laiteymp&auml;rist&ouml;ss&auml; (<A HREF="ftp://ftp.loria.fr/pub/loria/genielog/SmallEiffel"><I>ftp://ftp.loria.fr/pub/loria/genielog/SmallEiffel</I></A>). (K&auml;&auml;ntyy pienell&auml; sovituksella my&ouml;s mm. SAS C:ll&auml;.)<BR><BR>

</FONT><FONT SIZE=4><B>Eiffelin esimerkki-ohjelmap&auml;tki&auml;</B></FONT><BR><BR>
<FONT SIZE=5>T</FONT><FONT SIZE=3>
&auml;rkein kysymys on tietenkin, millaista on Eiffelin ohjelmakoodi. Se, pit&auml;&auml;k&ouml; ohjelmoija koodin ulkon&auml;&ouml;st&auml;, on vakavampi n&auml;k&ouml;kohta kuin useasti tullaan ajatelleeksikaan. Koodin, siis siistityn koodin, tulee olla ennen kaikkea helppolukuista, jotta se kelpaisi malliksi. Samalla sen tulisi kertoa kielen rakenteesta ja sis&auml;isist&auml; ratkaisuista. Ylemp&auml;n&auml; kerroin hiukan Eiffelin koodaamistyylist&auml;, mutta mit&auml;p&auml; sanat merkitsisiv&auml;t ilman konkreettisia esimerkkej&auml;:<BR><BR>

<B><I>1. esimerkki: Hello_World.e</I></B><BR><BR>
<PRE>
class HELLO_WORLD
   <I>-- Se tutuin ohjelma... N&auml;in merkit&auml;&auml;n kommentit Eiffeliss&auml;!
   -- Usein Eiffelill&auml; ohjelmoidessa laitetaan vain yksi luokka
   -- yhteen tiedostoon ja kerrotaan k&auml;&auml;nt&auml;j&auml;lle, mik&auml; on juuriluokka,
   -- josta suoritus alkaa.</I>
creation make <I>-- Mill&auml; rutiinilla olio luodaan, jos ei spesifisesti m&auml;&auml;r&auml;t&auml;
              -- jotakin toista luontioperaatiota.</I>

feature  <I>-- Mit&auml; ominaisuuksia luokalla on. Sek&auml; rutiinit ett&auml; tietoalkiot.</I>

     make is
          do
             io.put_string("Hello World.") <I>-- io-luokka hoitaa io-toiminnot.</I>
          end

end <I>-- HELLO_WORLD  Ohjelman suoritus p&auml;&auml;ttyy juuriluokan luontioperaation
    -- suorituksen p&auml;&auml;ttymiseen.</I>
</PRE>
<B><I>2. esimerkki: Rutiinit</I></B><BR><BR>
</FONT><FONT SIZE=5>V</FONT><FONT SIZE=3>
aikkei se v&auml;ltt&auml;m&auml;t&ouml;nt&auml; olekaan (siis siihen ei pakoteta), esitet&auml;&auml;n ett&auml; rutiineja olisi kahdenlaisia: funktioita ja proseduureja. Funktiot suorittavat jonkin (lasku)toimituksen ja antavat palautteena sen arvon; proseduurit taas eiv&auml;t palauta mit&auml;&auml;n, mutta tekev&auml;t/muuttavat jotakin tai jonkin muistipaikan arvoa. Ja yksi rutiini tietysti tekee mielell&auml;&auml;n vain yhden asian. Esimerkki funktion rakenteesta:<BR><BR>
<PRE>
nimi(argumentit): TYYPPI is <I>-- otsikko ja palautettavan arvon tyyppi</I>
require                     <I>-- (valinnainen) ehtolauseke argumentin arvon
                            -- sopivuuden testaamiseksi, esim. arg >= 0</I>
local                       <I>-- esitell&auml;&auml;n muuttujat</I>
     luku: INTEGER
do
                           <I>-- itse rutiini</I>
     Result := mik&auml;liearvo <I>-- funktion palauttama arvo</I>
end                        <I>-- rutiini loppuu ja arvo palautetaan kutsujalle
                           -- vasta end-sanaan tultaessa. rutiinia ei voi
                           -- keskeytt&auml;&auml;.</I>
</PRE>
<B><I>3. esimerkki: toistolauseke</I></B><BR><BR>
</FONT><FONT SIZE=5>K</FONT><FONT SIZE=3>
uten jo aikaisemmin mainittiin, Eiffeliss&auml; on perinteisiin kieliin n&auml;hden v&auml;h&auml;n rakenteita kontrollivuon ohjaukseen, mutta ne ovat monipuolisia. Alla on malli Eiffelin toistolausekkeesta, loop-lauseesta:<BR><BR>
<PRE>
from       <I>-- from-sanan alle laitetaan toistolauseen alustukseen
           -- tarvittava koodi, esim. muuttujien alkuarvot.</I>
invariant  <I>-- (valinnainen) Ehtolauseke, jonka on oltava voimassa jokaisen
           -- kierroksen alussa, jotta silmukka toimisi oikein (erityisen
           -- t&auml;rke&auml; ensimm&auml;isell&auml; ja viimeisell&auml; kierroksella)</I>
variant    <I>-- (valinnainen) on p&auml;invastainen laskutoimitus kuin se mik&auml;
           -- suoritetaan jokaisella kierroksella; kokonaislukuarvoinen
           -- laskutoimitus, jonka tuloksen t&auml;ytyy olla positiivinen.
           -- Varmistaa, ett&auml; suorituskertoja on &auml;&auml;rellinen m&auml;&auml;r&auml;.</I>
until      <I>-- lopetusehto</I>
loop
           <I>-- T&auml;h&auml;n v&auml;liin itse silmukka.</I>
end
</PRE>
Tuntuiko pitk&auml;lt&auml; ja hankalalta? Mutta t&auml;llaisten juttujen miettiminen etuk&auml;teen tekee kummasti debuggauksesta helpompaa ja nopeampaa. Luulisi, ett&auml; Meyer olisi laittanut toistolauseen loppuun vastaavan toiminnon kuin alun from-lause huolehtimaan toiston j&auml;lkeisist&auml; toimenpiteist&auml;. Olisiko unohtanut vai pit&auml;nyt turhan hankalana?<BR><BR>

</FONT><FONT SIZE=4><B>Kenelle Eiffel?</B></FONT><BR><BR>
<FONT SIZE=5>H</FONT><FONT SIZE=3>
ankala kysymys. Helpompi kai olisi vastata p&auml;invastaiseen: Eiffel ei ainakaan miss&auml;&auml;n nimess&auml; ole perinteisen mallin hakkerin kieli. Eiffel-koodin kanssa ei voi helposti r&auml;pelt&auml;&auml; tai oikaista. Ohjelman suunnitteluun t&auml;ytyy uhrata aikaa.<BR><BR>
Toisaalta aikaa ei kannata uhrata pienten sovellusten tekemiseen, mutta ammattiohjelmoijille Eiffel voisi olla mannaa. Apuneuvoineen se soveltuu isojen ohjelmien tekemiseen.<BR><BR>
Mik&auml;&auml;n jokapaikan jyr&auml; Eiffel ei ole, mutta ainakin minun suosiostani se kilpailee tasaveroisesti C++:n kanssa (raskaassa sarjassa).<BR><BR>
</FONT>
<HR width=100% size=2 align=CENTER>
<CENTER>
 <FONT SIZE=2><I>HtmlSaku numero 21, &copy; Copyright 1993-1997 Suomen Amiga-k&auml;ytt&auml;j&auml;t ry.</I><BR></FONT>
</CENTER>
</BODY>
</HTML>

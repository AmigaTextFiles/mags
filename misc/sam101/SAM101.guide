@DATABASE SAM9501.GUIDE
@NODE MAIN "Svenska Amiga Magazin 1-95 950312"
@TOC 1INNE
                            .ø¤°"¯ SVENSKA ¯"°¤ø. 
                                                
             ###          ###    ###   #####      ########        ### 
            ####         ####   ####    ###     ####      #      #### 
           #####        #####  #####    ###   ####              ##### 
          ## ###       ## ### ## ###    ###  ####              ## ### 
         #######      ##  #####  ###   ###   ###    ######    ####### 
        ##   ###     ##   ####   ###   ###   ####     ###    ##   ### 
       ##    ###    ##    ###    ###   ###    ####   ####   ##    ### 
     #####  #####_#####         #####_#####____########___#####  #####

                    ## ## #####  #### ##### ##### # ##  #
                    # # # #   # #     #   #     # # # # #
                    # # # ##### #  ## #####  ###  # # # #
                    #   # #   # #   # #   # #     # # # #
                    #   # #   #  ###  #   # ##### # #  ##
               
                             Nummer 1-95  950312

                                 @{" INNEHÅLL " LINK 1INNE}
@ENDNODE
@NODE 1INNE "Innehåll 1-95"
                            .ø¤°"¯ SVENSKA ¯"°¤ø.
                          .:Ø   AMIGA MAGAZIN   Ø:.

                                INNEHÅLL 1-95 
                               ~~~~~~~~~~~~~~~
                                 @{"  LEDARE  " LINK 1LED} En ny disktidning

     Nyheter                          Artiklar
     ~~~~~~~                          ~~~~~~~~
     @{"    C=    " LINK 1NY1} Senaste ryktet       @{" Nytt OS? " LINK 1AOS} Hör Maarten Ter Mors
     @{"Versioner " LINK 1VER} Nyaste versionerna   @{"AmigaGuide" LINK 1AG1} Att skriva en manual
                                      @{"  DPaint  " LINK 1DP1} Najsiga effekter


     Tester                           Spel
     ~~~~~~                           ~~~~
     @{"LZX vs LhA" LINK 1LZX} Vilken är bäst?      @{"  Sökes!  " LINK 1SPL} Spelrecensioner
     

     Programmering                    Övrigt
     ~~~~~~~~~~~~~                    ~~~~~~
     @{"    C     " LINK 1CCC} Filminnesallokering  @{"  PD/SW   " LINK 1PDT} Fyra tester
     @{" E-skolan " LINK 1EIN} Hur du reggar E      @{"  BBS'er  " LINK 1BBS} Baslistan
     @{"  Arexx   " LINK 1ARX} LZX och moduler        
     @{"  Böcker  " LINK 1BOK} Kort om bra böcker       


                                 @{"   Red    " LINK 1RED} Vilka? Var? Delta?

=============================================================================
@ENDNODE
@NODE 1RED "Redaktionen"
@TOC 1INNE

Redaktionen och övrig information
=============================================================================

Svenska Amiga Magazins redaktion är, i bokstavsordning :

     Björn Bertilsson

     Henrik Hästbacka

     Henrik Nyström

     Mattias Karlsson

     Per Malmström


Svenska Amiga Magazin är till för alla Amiga ägare och alla Amiga ägare
kan också bidra med artiklar och tester. Alla kommentarer och önskningar
är välkommna, vi vill ju göra en tidning som så många som möjligt läser.

För åsikter, kommenterer eller medverkan var vänlig kontakta :

     Björn Bertilsson, Sysop på Transilvania 0224 - 91060
     eller
     Henrik Nyström, #3387 på DMZs bbs, e-mail: henrik.nystrom@talshiar.ct.se

Har du ej tillgång till modem så kan vi nås via snail-mail :

     Henrik Nyström
     Skarpskyttevägen 20
     153 36 JÄRNA
     Sverige

Svenska Amiga Magazin (SAM) är pd och får fritt distribueras via modem 
eller diskett. Diskett distribution få endast ske i icke vinst syfte 
och den totala kostnaden (inkl porto) får inte överstiga 25:- (SEK).
Ingen spridning av SAM i kommersiellt syfte är tillåtet utan tillåtelse 
av SAM's redaktion.

Svenska Amiga Magazin, dess redaktion och textförfattarna tar inget 
som helst ansvar för hur information hämtat från SAM används eller 
missbrukas. Material sänt till SAM's redaktion är fritt för oss att 
använda, i helhet eller endast vissa delar, utan författarens 
medgivande om inget annat nämns. Allt material i SAM får fritt återges 
i oförändrat skick. Översttningar får ske om SAM's redaktion först 
meddelas och om översättningen inte ändrar innebörden i materialet.

@ENDNODE
@NODE 1LED "Ledare SAM 1-95"
@TOC 1INNE

En ny tidning är född                                  Av Henrik Nyström
=============================================================================

Välkommna till Svenska Amiga Magazin's första nummer.

Svenska Amiga Magazin (SAM) är en ny disktidning som handlar om allas
vår favorit dator. När det blev känt att DMZ skulle börja med 50% PC,
blev det minst sagt en massiv proteststorm på deras bas. Mitt i all
klagan dök det upp en text om att starta en diskett baserad tidning.
Även om textförfattaren inte själv nappade på sitt förslag, så var vi
några som gjorde det. Björn Bertilsson tog tag i saken när allt höll på
att ebba ut, genom att be intresserade ringa hans bas Cyberica III
(numera Transilvania). Efter några dagar var vi åtta stycken som började
diskutera och planera. Innan vi kom igång ordentligt föll fyra stycken
bort och när vi kom igång ordentligt kom två nya. Vi är alltså sex 
stycken som har skapat denna enastående, lysande, roliga, intressanta,
snygga (min layout :) ) och läsvärda tidning.

Som du kanske har märkt så går vi inte riktigt i Amiga Reports fotspår, 
utan har försökt att likna en mer vanlig datatidning. Du hittar inte 
artiklar om hur du gör AmigaGuide dokument, hur du använder DPaint 
eller en E-skola i Amiga Report, men det gör du här. Det som det kanske 
är lite ont om i detta nummer är tester av diverse programm/spel, men 
det hoppas vi kunna ändra på till nästa nummer. Om du har ett nyinköpt 
programm/spel så ser vi gärna att du hör av dig till oss med en 
testartikel. Vi på SAM önskar dig en trevlig läsning.

Mvh SAM's redaktion


@ENDNODE

@NODE 1NY1 "Senaste ryktet om C= uppköpet"
@TOC 1INNE

Ytterligare ett rykte, eller...
=============================================================================

Det senaste ryktet som jag har hört talas om när det gäller uppköpet
av C=, är att likviderarna nu har accepterat ett bud från tyska Escom.
Om det stämmer så är det nu 'bara' själva auktionen som står kvar som
hinder mot ett klart uppköp. Det verkar som det är CEI, C= UK och Escom
som är kvar.

(Jag vet att detta inte är mycket till nyheter, men ni får ha överseende
med det då detta bara är första numret. Vi ska bättra oss.)


@ENDNODE

@NODE 1VER "De senaste versionerna"
@TOC 1INNE

De senaste versioner av diverse PD
=============================================================================

Namn                     Version   Datum     Beskrivning
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Amiga Link               #1        950301    Tidning på engelska
Amiga Report             3.05      950228    Tidning på engelska
Svenska Amiga magazin    1.01      950312    Tidning på svenska
Virus Checker            6.52      950226    Antivirus

 ---------

Saknar du något program på listan så skriv till oss med aktuell
information. (Det kommer fler i nästa nummer)


@ENDNODE

@NODE 1DP1 "Deluxe Paint skola del 1"
@TOC 1INNE

Genvägar i Deluxe Paint - Del 1                        Av Henrik Hästbacka
=============================================================================

Visst har vi alla drömt om att kunna rita lika bra som grafikerna i
olika demos, eller som min favorit "Peachy", han kan VERKLIGEN rita
han! Vi har alla sett en massa logos som folk ritat och man tänker,
så där skulle jag vilja kunna rita. Faktist så är det inte så svårt
som de verkar, ja visst finns det undantag men i många fall så är
det simpla effekter som används och sedan redigeras om till ett
tillfredställande resultat.

Det jag kommer att ta upp är några enkla (men bra) genvägar när man
skall rita. Det som egentligen bara behövs är ett bra fantasi-sinne
och en Amiga. =)

 --------------

Vi kan börja med en mycket enkel grej:

* Outline

Outline är en mycket behändig och ett effektfullt hjälpmedel. Låt
oss säga att du just ritat en fyrkant, men det saknas något.

Gör då följande:
Kopiera din fyrkant till en "brush" (så att du håller i den).
Markera en färg i paletten som du skulle vilja ha runt din fyrkant
(helst inte samma färg som fyrkanten).
Sedan går du upp i menyn "Brush" och sök efter "Edge", där kommer
du att hitta "Outline", välj nu "Outline" och titta vad som händer
med din fyrkant. 

För att få en fin effekt med OUTLINE kan du göra så att du markerar
en färg, låt oss säga ljusgrå, sedan väljer du "Outline" i menyn och
väljer sedan en ny färg (helst en nyans mörkare), fortsätt så och du
kommer förhoppningsvis att få en brush med en vacker toning runt om!

TIPS: För att snabba upp processen när du skall leta efter "Outline"
 i menyerna så kan du trycka på "o" tangenten istället. Då slipper
 du en massa spring i onödan.

Nu när du kan denna enkla effekt så är det bara att låta din fantasi
flöda. Tyvärr så används denna effekt nästan aldrig av nån som kan
rita eftersom det anses vara "förbi sin tid" att använda Outline.
Men jag har sett logos med mycket vackra Outlines, så "förbi sin tid"
ska man nog ta med en nypa salt.

 --------------

Nästa effekt som jag skall ta upp är en vacker fyllning på ex en logo.

*Tonad fyllning

Denna princip är mycket lik Outline-effekten men här skall man inte
ha nån outline utanpå.

Gör följande:
Skriv ett namn (Helst på den gruppen du är med i =) ).
Kopiera det du skrev och förstora den till den storleken du vill ha.
Ta nu och rita en massa punkter på skärmen innom en begränsad area.

     .   .
      .     .
    .   ..
          .  .
     .  .


Ungefär som skissen ovanför. Helst skall punkterna vara i VIT färg
eftersom det ska bli en tonad fyllning. kopiera dina punkter till
en brush och gör en outline med en färg som är någorlunda mörkare,
fortsätt så tills du kommit till den mörkaste färgen i din toning.

Nu bör du fått nått som LIKNAR kristaller (Behöver inte nödvändigtvis
likna kristaller!). Om du är nöjd med din toning så letar du rätt på
knappen "Fill cursor" som ligger på HÖGRA sidan (den du fyller objekt
med), klicka med HÖGER musknapp på den, då kommer det upp en ruta med
massor av roliga effekter som jag kommer att ta upp senare. Klicka
nu på "FROM BRUSH", när du gjort det kommer din brush att synas i en
liten ruta. Tryck på OK. Fyll sedan din logo eller vad du nu vill
fylla, så kommer din brush att fungera som en fyllning.
Förhoppningsvis så kommer ditt objekt att se mycket trevligt ut och
dina närmsta kompisar tycker att det är tjusfullt.

TIPS: När du skall rita ut punkterna bör du ha ett litet avstånd
 mellan varje pixel så att det inte blir så kladdigt när du sedan
 gör Outliners.

Denna effekt används MYCKET av många grafiker som ritar t ex logos.
Så om du ser en vacker logo, kolla lite nogranare på den så för-
hoppningsvis kommer du att kunna se hur grafikern gjort sin logo.
Personligen så tycker jag att denna effekt är lite dålig eftersom det
syns så väl att nån använt den effekten. Men visst, det GÅR att få det
riktigt bra ibland. 

 --------------

Denna effekt som jag kommer att beskriva nu är mycket användbar.
Själv så använder jag den när jag ritar upp en grund för ett
graffiti-motiv.

* Antialias

Anitalias fungerar på så sätt att den "mjukar" de linjer du drar
eller cirklar.

Gör följande:
Börja med att välja en annan bakgrundsfärg ex. ljusblå. Om du nu
skulle dra ett rakt sträck med hjälp av "Straight line tool" eller
med andra ord, Knappen-som-man-drar-raka-streck-med( =) ) så kommer
du förmodligen att märka att den linjen blir ganska kantig.
Men genom att välja "antialias" så blir det en helt annan sak.

Antialias hittar du i menyn under "Effect", välj antialias High eller
Low. Dra nu ett sträck till så kommer du att märka att linjen är
mycket finare och mjukare.
En nackdel finns i denna effekt! Om du har valt den minsta pixeln
att rita med och väljer antialias så blir strecket mycket tjockare,
visserligen så är det kanske inte en nackdel eftersom linjen blir ju
mjukare.

TIPS: Använd en lagom ljus färg som bakgrundsfärg, för om du tar
 ex. svart bakgrundsfärg, kommer INTE linjen se SÅ bra ut!
 Prova också att rita en logo med antialias. Det brukar bli mycket
 fint.

Denna effekt är säkert också vanlig, men jag har inte sett den så
mycket ändå. Visst har man sett den på någon logo någonstans, men de
som verkligen kan rita pixlar dessa saker för hand.

 --------------

Denna effekt som jag tänker beskriva bygger på samma princip som
Tonad Fyllning.

*Marmor fyllning

Marmor är alltid snyggt om man vill ex ha en vacker texture. Om du
vill få nästan samma marmor-effekt prova då detta.

Gör följande:
Börja med att skaffa en palette som har en marmor-toning.
Gå upp i menyn "Color" och sedan på "Palette" och sen Mixer on/off.
Nu kommer paletten fram. Gör en toning där. Det är mycket enkelt,
det märker du nog.
När det är klart så tar du den ljusaste färgen i din toning (i
paletten) och sätter ut en massa punkter på ett samlat ställe.
Gör en massa outlines med en nyans mörkare per gång, precis som i
Tonad fyllning. Efter detta placerar du din brush på skärmen och
väljer i menyn "Mode" och "Smear". Kladda runt på ditt objekt som
du har på skärmen tills du tycker att det räcker. Efter det går
du upp i menyn på "Mode" och "Smooth" och Smooth:ar hela ditt objekt.
Efter det tar du och kopierar ditt objekt till en brush och klickar
på HÖGER musknapp på "Fyllnings knappen" och väljer "From Brush".
Nu är det bara att fylla det objekt du vill ha fyllt, ex. en logo.

TIPS: Denna effekt kan vara lite svår att få bra, men med lite
 övning så skall det säkert gå bra! Prova också att ha andra
 toningar som ex. ljusrött till mörkrött eller ljusblått till mörk-
 grönt. Ja det är bara att mixa. Ett OBS också! Använd inte smooth
 för MYCKET, det gör din fyllning så suddig.

Marmorfyllning är en vanlig fyllning bland grafiker. Det är ju snyggt
med marmor (eller hur?). Men för att få riktig marmor krävs lite
mer än bara fyllning, det gäller att få det att se realistiskt ut
också.

 --------------

Nu hoppas jag att du lärt dig åtminstone något nytt efter att du har
läst detta, och man får hoppas att ni blir ena riktiga hajar på att
pixla i dpaint. Självklart så var inte detta alla effekter jag känner
till utan ni får vänta tills nästa nummer då det kommer några nya
effekter som jag ska försöka att lära ut.

Tills nästa gång,

C Ya'! 


@ENDNODE

@NODE 1AG1 "En guide i AmigaGuide"
@TOC 1INNE

En guide i AmigaGuide - Del 1                          Av Henrik Nyström
=============================================================================

Vill du skriva en manual i AmigaGuide format till ditt nya program,
men vet inte hur man gör? Då hoppas jag att denna artikel kan hjälpa
dig, för precis som rubriken säger så är detta en guide för att skriva
AmigaGuide dokument. Bara de funktioner som är de mest viktiga tas
upp här. Funktioner som kräver 3.x behandlas inte i denna artikel,
utan kommer att tas upp i nästa nummer.

Okej, nu börjas det. Häng me...

 ---------

En bra start är att planera lite. Vilka olika sidor ska jag ha med?
Här följer de exempel på texter som jag ska ha med (Jag kommer att
använda samma exempel i hela texten).
  
* Innehåll : Den första sidan, varifrån man startar.

  Manual till MP - Mitt Programm - v1.0 1995
                    
  Inledning       Lite allmänt om programmet.
  Installation    Hur man installerar programmet.
  Användning      Hur man startar och använder programmet.
  Historia        Lite information om förbättringar mellan versioner.
  Registrering    Hur man kan registrera sig som användare.

* Inledning

  Mitt Program (i fortsättningen kallad MP) är lösningen på mångas problem
  med att köra vissa andra program. MP gör helt enkelt det som det andra
  programmet inte klarar av att göra, som det borde klara av att göra. En
  nyhet som borde glädja alla användare är att MP nu helt är skrivet i
  systemvänlig ascii text och dessutom har snabbats upp ordentligt. För att
  utnyttja MP:s hela potensiella kraft bör du registrera dig omgående.
    
* Installation
  
  För att installera Mitt Programm kopierar du helt enkelt MP till PIPE:.
  Skriv följande från Cli:
  > Copy MP#? to PIPE:       (#? bara för att få med ikonen)
    
  MP är därefter körklar.
       
* Användning
    
  Du har nu alltså installerat Mitt Program och är reda att använda det.
  För att använda MP startar du det enklast från Cli eller WB.
    
  Från Cli:
  > Run MP
  
  Från WB:
  Dubbelklicka på ikonen.
    
  MP ligger nu i minnet och du kan lungt glömma bort att det finns då det
  klarar sig utmärkt av sig själv.
    
* Histroia
  
  Detta är version 1.0 av Mitt Program. Här är en kort beskrivning av
  ändringar och utökningar mellan olika versioner.
    
  1.0 - Denna version. Nu i systemvänlig ascii text. Snabbare. Fixade en
  bugg med v0.9b (både insekten och disketten gick sönder :( ).
            
  0.9b - Föregående version. Ej systemvänlig ascii text. Långsam.
  
* Registrering
    
  Att registrera sig som användare av MP har många fördelar, en är att du
  helt gratis får en reggad version av alla i framtiden oplanerade ej
  kommande versioner av MP v0.9b. För allt detta behöver du bara skicka
  en multicynk monitor.

 ---------

Nu när jag har texterna, så ska jag göra om dom till olika noder.
Framför varje text skriver jag då '@node <nodnamn> [<fönsternamn>]'.
Det finns två regler att följa när man väljer nodnamn. Den första
måste heta 'MAIN' och två noder får inte ha samma namn. Efter varje
nodtext ska du sedan skriva '@endnode' för att tala om att noden
slutar här (ganska uppenbart va). I mitt exempel blir de så här
(med komprimerad nodtext)
  
 @node MAIN "Innehåll"
   Min innehålls text.
 @endnode
  
 @node INLED "Inledning"
   Min inlednings text.
 @endnode
  
 @node INST "Installation"
   Min installations text.
 @endnode
  
 @node ANV "Användning"
   Min användnings text.
 @endnode
  
 @node HIST "Historia"
   Min historia text.
 @endnode
  
 @node REG "Registrering"
   Min Registrerings text.
 @endnode

Det var väll ganska lätt. Om du inte har alla texterna i samma
dokument så är det dags att du nu klipper ihop dom. Se till att den
första noden är MAIN noden, ordningen på de andra är inte lika
viktiga. När du har gjort detta så återstår det bara två saker. Vi
tar den enklaste först.

 ---------

Du måste nu skapa ett huvud som talar om att det är ett AmigaGuide
dokument som skall visas. Det gör du genom att på första raden i
dokumentet (alltså innan MAIN noden) skriva '@database <namn>'. Det
färdiga resultatet av mitt exempel har självklart inte med detta
kommando då det inte är en egen databas utan en nod i denna tidning,
men annars så skulle jag skriva

 @database Manual.guide
  
vilket betyder att denna databas heter just 'Manual.guide'.
  
 ---------

Har du varit uthållig nog att orka läsa ända hit? Bra, det tar jag
som ett bevis på att jag skriver bra :). Du har kommit till den
knappskapande delen av artikeln. För att skapa knappar så använder
du kommandot 
  
 \@{<namn> COMMAND}
  
Då endast <namn> tar upp plats när texten visas är det en fördel att
ha skrivit texten i förväg, eftersom raderna då redan är lagom långa.
  
'Tryck gärna på \@{"kanppen" LINK 1TEST} du ser.'
kommer i texten att bli
'Tryck gärna på @{"kanppen" LINK 1TEST} du ser.'
  
Följande kommandon är användbara
  
 LINK <namn> [<line>]        @{"Ex" LINK 1TEST} \@{"Ex" LINK 1TEST}
   Går till noden <namn> med start på raden <line>.
  
 RX <command>                @{"Ex" RX PModS} \@{"Ex" RX PModS}
   Kör ett ARexx macro.
  
 RXS <command>               @{"Ex" RXS "Address COMMAND Cli"} \@{"Ex" RXS "Address COMMAND Cli"}
   Kör ett ARexx kommando.
  
 SYSTEM <command>            @{"Ex" SYSTEM Cli} \@{"Ex" SYSTEM Cli}
   Exekverar ett AmigaDOS kommando.
  
I manual exemplet använder jag bara LINK och det räcker oftast med
det. Jag visar nu hur min MAIN (Innehåll) sida kommer att se ut.

 @node MAIN "Resultatet av manual exemplet"
  
  Manual till MP - Mitt Programm - v1.0 1995
  
  \@{"Inledning   " LINK INLED}    Lite allmänt om programmet.
  \@{"Installation" LINK INST}    Hur man installerar programmet.
  \@{"Användning  " LINK ANV}    Hur man startar och använder programmet.
  \@{"Historia    " LINK HIST}    Lite information om förbättringar mellan versioner.
  \@{"Registrering" LINK REG}    Hur man kan registrera sig som användare.

 @endnode

I det färdiga exemplet har jag även knappar mellan de olika under-
noderna. Vill du se resultatet? @{"Tryck då på denna knapp!" LINK XMANUAL}

VIKTIGT! 
  
När du använder '@database'/'@node'/'@endnode' så måste de stå på
radens första kolumn för att vara giltiga. Annars gäller de som
vanlig text i dokumentet.
  
 \@{<namn> COMMAND} är alltid giltigt var det än står om det inte
 föregås av en backslash, ex. \\@{<namn> COMMAND}

Lycka till!

@ENDNODE
@NODE 1TEST "Testnoden"
@TOC 1INNE
  Det fungerade! Tryck på tillbaks.^^^^^^^^
@ENDNODE
@NODE XMANUAL "Resultatet av manual exemplet"
@TOC XMANUAL

    Manual till MP - Mitt Programm - v1.0 1995
  
    @{"Inledning   " LINK XINLED}    Lite allmänt om programmet.
    @{"Installation" LINK XINST}    Hur man installerar programmet.
    @{"Användning  " LINK XANV}    Hur man startar och använder programmet.
    @{"Historia    " LINK XHIST}    Lite information om förbättringar mellan versioner.
    @{"Registrering" LINK XREG}    Hur man kan registrera sig som användare.
@ENDNODE
@NODE XINLED "Inledning"
@TOC XMANUAL

    Mitt Program (i fortsättningen kallad MP) är lösningen på mångas problem
    med att köra vissa andra program. MP gör helt enkelt det som det andra
    programmet inte klarar av att göra, som det borde klara av att göra. En
    nyhet som borde glädja alla @{"användare" LINK XANV} är att MP nu helt är skrivet i
    systemvänlig ascii text och dessutom har snabbats upp ordentligt. För att
    utnyttja MP:s hela potensiella kraft bör du @{"registrera" LINK XREG} dig omgående.

@ENDNODE
@NODE XINST "Installation"
@TOC XMANUAL
  
    För att installera Mitt Programm kopierar du helt enkelt MP till PIPE:.
    Skriv följande från Cli:
    > Copy MP#? to PIPE:       (#? bara för att få med ikonen)
    
    MP är därefter klar för @{"användning" LINK XANV}.

@ENDNODE
@NODE XANV "Användning"
@TOC XMANUAL
    
    Du har nu alltså @{"installerat" LINK XINST} Mitt Program och är redo att använda det.
    För att använda MP startar du det enklast från Cli eller WB.
    
    Från Cli:
    > Run MP
    
    Från WB:
    Dubbelklicka på ikonen.
    
    MP ligger nu i minnet och du kan lungt glömma bort att det finns då det
    klarar sig utmärkt av sig själv.

@ENDNODE    
@NODE XHIST "Histroia"
@TOC XMANUAL
  
    Detta är version 1.0 av Mitt Program. Här är en kort beskrivning av
    ändringar och utökningar mellan olika versioner.
    
    1.0 - Denna version. Nu i systemvänlig ascii text. Snabbare. Fixade en
    bugg med v0.9b (både insekten och disketten gick sönder :( ).
            
    0.9b - Föregående version. Ej systemvänlig ascii text. Långsam.

@ENDNODE
@NODE XREG "Registrering"
@TOC XMANUAL
    
    Att registrera sig som @{"användare" LINK XANV} av MP har många fördelar, en är att du
    helt gratis får en reggad version av alla i framtiden oplanerade ej
    kommande @{"versioner" LINK XHIST} av MP v0.9b. För allt detta behöver du bara skicka
    en multicynk monitor.
    
@ENDNODE

@NODE 1BOK "Kort om programmerarens bästa böcker"
@TOC 1INNE

Böcker för den blivande programmeraren                 Av Mattias Axelsson
=============================================================================

Här följer en kort recension av några böcker som kan vara användbara för alla
som programmerar (eller tänker börja programmera) i exempelvis Assembler, C
eller E. Störst behållning av böckerna har förstås den som bemästrar C men
de är även oersättliga hjälpmedel för den som programmerar i andra liknande
språk. Dessa böcker är inte någon slags 'lär-dig-programmera-från-grunden'-
serie utan är till för att användas som kunskapskällor för lite mer avancerad
programmering och som referenser när du behöver slå upp något. Lite kort om
de olika böckerna som kan vara användbara:

RKM Devices
~~~~~~~~~~~
Här står allt du behöver veta om Amigans olika devices för bl.a ljud,
disketthantering, inmatning och kommunikation med serie- och parallellporten.

RKM Hardware Reference Manual
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Boken för hårdvarufreaksen och demoprogrammeraren. Här står det mesta om
Amigans hårdvara, brukar kallas för 'bibeln'.

RKM Libraries
~~~~~~~~~~~~~
För den som vill kunna använda Amigans olika 'bibliotek'. Med dessa kunskaper
kan du sedan exempelvis göra användarinterface, filrequestrar och hantera
grafik. En ganska praktisk bok för den genomsnittlige programmeraren.

RKM Includes & Autodocs
~~~~~~~~~~~~~~~~~~~~~~~
En väldigt användbar bok medan du skriver dina program. De andra böckerna går
igenom olika saker till skillnad från I&A som är ett slags 'uppslagsverk'.
Här står alla kommandon du kan tänka dig i bokstavsordning efter kategori. En
rejält tjock bok som innehåller massor av värdefull information.

User Interface Style Guide
~~~~~~~~~~~~~~~~~~~~~~~~~~
Rekommendationer på hur dina gränsnitt bör se ut, har inte läst den, men den
sägs vara intressant läsning.

The AmigaDOS Manual
~~~~~~~~~~~~~~~~~~~
Här går man igenom alla medföljande kommandon (type, dir osv) i tur och
ordning, bra om man vill ha ut det mesta av dem. Förutom det så innehåller
den en programmerardel där det bl.a står hur man använder funktionerna i
dos.library, som för övrigt kan läsas i RKM I&A. En bra bok om man vill
utveckla DOS-program.

 ---------

Detta var givetvis bara en bråkdel av de böcker som finns på marknaden, men
bland de mer användbara. Sidantalet skiftar ganska rejält från bok till bok,
RKM devices är på 582 sidor medan RKM I&A är på 1003 sidor. Det är dock
innehållet som räknas.. Det som är lite tråkigt är att böckerna inte har
släppts i versioner som täcker nyheterna i OS 3.0/3.1, men eftersom OS 2.04
har de flesta funktionerna som man har användning för så är det inte hela
världen. Hoppas att detta har hjälpt dig lite i ditt bokval!

/ MATTIAS AXELSSON (DOOM/CYBERICA) /

@ENDNODE

@NODE 1LZX "LZX bättre än LhA?
@TOC 1INNE

Vilken arkiverare är bäst?                             Av Henrik Nyström
=============================================================================

LZX heter en ny filarkiverare av Jonathan Forbes (Lhunarc, LZ, LX och 
Xenolink) och Tomi Pountanen som nu kommit till Amigan och senare även
ska komma i en PC version. Frågan är om LZX är bättre än LhA av Stefan
Boberg. Detta ska vi nu ta reda på.

Förutsättningarna för testet :

 LZX v1.00 finns i tre olika utvärderingsversioner (68000/68010,
 68020/68030 och 68040/68060). Varje test skedde med 68000/68010 och 
 68020/68030 versionerna av LZX.

 LhA v1.38 finns bara i en utvärderingsversion (68000) och testen
 gjordes med denna.

 Testen är gjorda i RAM: på en A1200 030 40Mhz 2+8Mb.

 ---------


* Test 1 - Amiga Report #3.05 (239978)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Arkiverare     Argument            Storlek   Tid-packa Tid-uppacka
------------------------------------------------------------------

Lha v1.38      -2 -q a             92650     7.66 s    1.14 s

LZX_68000EC    -2 -q a             85324     9.08 s    1.02 s
LZX_68000EC    -3 -q a             85076     9.90 s    1.02 s

LZX_68020      -2 -q a             85324     6.96 s    0.94 s
LZX_68020      -3 -q a             85076     7.56 s    0.94 s
------------------------------------------------------------------




* Test 2 - Forlist (2498506) sampling av Förlist
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Arkiverare     Argument            Storlek   Tid-packa Tid-uppacka
------------------------------------------------------------------

LhA v1.38      -2 -q a             1772019   90.56 s   12.40 s

LZX_68000EC    -2 -q a             1709532   90.72 s    9.82 s
LZX_68000EC    -3 -q a             1709310   90.78 s    9.84 s

LZX_68020      -2 -q a             1709532   75.00 s    9.20 s
LZX_68020      -3 -q a             1709310   74.82 s    9.04 s
------------------------------------------------------------------




* Test 3 - New Touch Professional v2.18b (877124) arkiv 94 filer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Arkiverare     Argument            Storlek   Tid-packa Tid-uppacka
------------------------------------------------------------------

LhA v1.38      -2 -q -r -a -x a    406644    29.14 s   4.52 s

LZX_68000EC    -2 -q -r -a -x a    352239    28.12 s   5.14 s
LZX_68000EC    -3 -q -r -a -x a    350481    31.76 s   5.16 s

LZX_68020      -2 -q -r -a -x a    352239    22.22 s   4.78 s
LZX_68020      -3 -q -r -a -x a    350481    24.38 s   4.78 s
------------------------------------------------------------------


Utifrån dessa testresultat är det ganska klart att LZX är en bättre
arkiverare. Om du har en 68020+ processor i din Amiga så är LZX även
snabbare än LhA. Enda svårigheten är att lära sig skriva LZX istället
för LhA på kommandoraden.

@ENDNODE

@NODE 1SPL "Speltester"
@TOC 1INNE

Här skulle det egentligen vara några speltester, men vi har haft svårt
att få tag på några till detta nummer. Om du har ett nytt spel eller
känner någon som har ett, så kan du väl skriva ned ett test. Vi ser helst
att du använder betygen 1-5.

Betygsexempel:

Grafik    :    4
Ljud      :    2
Spelvärde :    4
--------------------
Totalt    :    4

Läs "Red"-sidan om hur du kan kontakta oss.

@ENDNODE

@NODE 1PDT "PD tester"
@TOC 1INNE

Några tester av nya PD program/spel.
============================================================================


NextWindow v2.2 av Heikki Linnakangas, Finland
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
NextWindow är ett commodity som låter dig använda tangentbordet
istället för musen när du vill byta aktivt fönster. Inställningarna
görs via tooltypes. Du kan bestämma tre olika snabbtangenter, en 
vardera för att växla fönster framåt/bakåt och en för att aktivera 
det främsta fönstret. Du kan också bestämma om aktiverat fönster 
skall flyttas längst fram automatiskt. Detta är vad NextWindow 
skall klara, men inte riktigt klarar av. Funktionen 'nästa fönster'
"fryser" datorn och försöker man växla fönster med inga fönster öppna 
sker samma sak. Då jag använder TBC så räknas detta som ett fönster 
och om jag sedan inaktiverar 'nästa fönster' och bara använder
'föregående fönster' så fungerar allt bra.

BETYG : 3/5


FileFinder v1.1 av Mark D Melton, England
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ett program för att hitta filer på din hårddisk. Även detta program
är ett commodity och kan styras från Exchange. Du aktiverar FileFinder
med dess hotkey och får då upp sök fönstret. Du kan nu bestämma var 
du vill söka och efter vilket mönster. Du kan också ställa in maximal 
och minimal strolek på filerna att söka efter samt datum avgränsning. 
Du får en lista på hittade filer som går att skriva ut på skrivare. 
Detta program är snyggt och lätthanterligt och får en klar 4:a.

BETYG : 4/5


LZX v1.00 av Jonathan Forbes, Canada
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
För er ännu ej upplysta så kan jag tala om att LZX är ett nytt
filarkiverings program som är bättre än LhA (se testet i tidningen).
LZX v1.00 finns i tre olika versioner, optimerade för olika processorer.
LZX styrs nästan exakt som LhA, men är inte kompatibelt med LhA. LZX
packar filer bättre än LhA och med en 68020+ Amiga så är den också
snabbare. Manualen är väldigt bra och tar upp hur man använder alla
funktionerna. LZX är shareware och den registrerade versionen kostar
25 US$, men det går bra att betala i svenska kronor. LZX är ett mycket
bra program och kan bara få ett betyg.

BETYG : 5/5


MAGIC MENU
~~~~~~~~~~
Magic Menus låter dina menyer "ploppa upp" precis där du håller din mus-
pekare. Detta kan vara mycket behändigt i många lägen. Programet har många
inställningar som låter dig ställa in tex att menyerna ska ha 3-D stil och
att man bara ska behöva klicka en gång på högra och inte hålla in knappen
utan man klickar helt enkelt en gång på vänstra istället. Vill man sedan
ha bort menyen när man klickat fram den så är det bara ett lätt tryck på
högra knappen. Programet installeras mycket enkelt. Det är bara att lägga
det i WBStartup och köra. Manualen är ganska bra upplagd och räcker bra
till. Den är skriven i guide format och finns på både Tyska och Engelska.
Det enda minuset är att datorn "fryser" sig ibland, men detta händer
mycket sällan så det bör inte vara något problem.

BETYG : 4/5


@ENDNODE

@NODE 1BBS "Baslistan"
@TOC 1INNE

BBS            Telnr          Baud      Öppet     Info
=============================================================================

Digital Square 08-7546400     14400     24h       Amiga E Sup. Programmering
Transilvania   0224-91060     28800     24h       Okult inriktning. SAM HQ.

                    ···***»»» LITE LEDIG PLATS «««***···

@ENDNODE

@NODE 1ARX "ARexx och packade moduler"
@TOC 1INNE

Att spela LZX-packade moduler med hjälp av Arexx       Av Henrik Nyström
=============================================================================

Det är lika bra att erkänna på en gång, jag är ingen expert på ARexx.
Faktum är att detta är mitt första ARexx program. Anledningen till att
jag skrev detta program är att jag ville packa om mina moduler till
LZX, men ingen modulspelare stödjer för tillfället LZX-packade moduler.
Genom att titta på andra enkla Arexx program, skrev jag ett script som
helt enkelt packade upp modulen med LZX och startade en spelare. Det
såg ut ungefär så här:

 ---------
 
/* Spela LZX-moduler */
Arg fil
spela = 'Smartplay '
Address COMMAND 'LZX -q x 'fil' RAM:'
Address COMMAND 'List RAM: PAT (#?.mod|mod.#?) FILES LFORMAT %p%n >PIPE:lista.txt'
Call Open(lista,'PIPE:lista.txt','R')
Do forever
 mod = ReadLN(lista)
 If EOF(lista) then break
 spela = spela '"'mod'"'
End
Call Close(blist)
Address COMMAND spela

 ---------
Programmet ovan gör vad det skall, men är inte speciellt färdigt. Jag
bestämde mig för att lägga till stöd för LhA och LZX och fixa så att
man kunde styra allt via requesters. La också till att man kan välja
modulspelare själv utan att ändra i programmet.

En snabb genomgång :

PModS - Packed Module Sender
Packar upp moduler packade med LhA/Lzh/LZX och startar den valde
modulspelaren.
WB:
 För WB styrning krävs 'rexxreqtools.library'.
 Välj modulspelare.
 Välj modul/moduler att spela.
 Tryck OK!
Cli:
 Kan ta emot max 10 filer (går lätt att ändra på).
 Syntax: [rx] PModS Player fil.1 fil.2 ... fil.10

Anledningen till att du kan välja mellan HiP, Smartplay och Other är
att jag hade HiP och Smartplay tillgängliga och att de stöder LhA. Om
du väljer någon av dem så packas inte LhA arkiven upp utan spelas upp
direkt av spelaren.

Då jag inte precis är någon ARexxguru och jag idag ändrade i programmet
så att min gamla text blev lite inaktuell, låter jag programmet tala
för sig själv. Här under ser du två knappar, varav den ena visar hur
programmet ser ut och den andra kör programmet i WB-mode (kräver 
rexxreqtools.library).

 ------------- @{"PModS - listning" LINK 1PMS} ------------ @{"PModS - körning"RX PModS} -------------


@ENDNODE

@NODE 1PMS "PModS - Packed Module Sender"
@TOC 1INNE
/*   PMods - Packed Module Sender v2.1 : Henrik Nystrom 1995 */

Call addlib('rexxreqtools.library',0,-30,0)

Arg opt fil.1 fil.2 fil.3 fil.4 fil.5 fil.6 fil.7 fil.8 fil.9 fil.10

Do
 If opt > '' Then Do
   PLAYER = opt
   Say '*** PModS - Packed Module Sender - v2.1 : Henrik Nystrom 1995 ***'
   If opt = '?' then DO
    Say
    Say 'Usage: [rx] PModS playername fil.1 fil.2 fil.3 ... fil.10'
    Say
    EXIT
   End
   If fil.1 > '' then do
     Do i=1 to 10
      If fil.i > '' then fil.count = i
     End
    End
   Else Do
    Say 'No files selected.'
    Exit
   End
  End
 Else Do

  NL = '0a'x
  Call rtezrequest("Packed Modules Sender v2.1" || NL ||,
  " Henrik Nystrom 1995 ", " Let's Rock ")

  Call rtezrequest("Choose module player to use." || NL ||,
  "It must exist in your path.", "_HiP|_SmartPlayer|_Other|_QUIT")
  If rtresult == 0 then EXIT
  If rtresult == 1 then PLAYER = "Run >NIL: HiP "
  If rtresult == 2 then PLAYER = "Run >NIL: Smartplay "
  If rtresult == 3 then 
  Do
    play = 0
    PLAYER = rtgetstring(,"Enter name of your modulplayer.", "Name:",,
    "_Ok|_Quit")
    If rtresult == 0 then EXIT
   End
  Else play = 1
  Do
   Call rtfilerequest("DH0:",,"Pick modules", ,,
   "rtfi_height=184  rtfi_matchpat=#?(.lha|.lzx|.lzh)  rtfi_flags=freqf_multiselect",fil)
   If fil == 0 then Exit
  End
 End
End

Address COMMAND 'Assign PMODS: REMOVE'
Address COMMAND 'Delete Ram:PModS/ all FORCE >NIL:'
Address COMMAND 'Makedir Ram:PModS'
TempDir = 'RAM:PModS/'  
Address COMMAND 'Assign PMODS: 'TempDir
Do i=1 to fil.count
 UNP = Upper(Right(fil.i,3))
 If (UNP = 'LHA' | UNP = 'LZH') & play = 1 then PLAYER = PLAYER '"'fil.i'"'
 Else Address COMMAND UNP' -q x 'fil.i' PAT #?.mod mod.#? PMODS:'
End
Address COMMAND 'List PMODS: PAT (#?.mod|mod.#?) FILES LFORMAT %p%n >PIPE:blist.txt'
Call Open(blist,'PIPE:blist.txt','R')
Do forever
 mod = ReadLN(blist)
 If EOF(blist) then break
 PLAYER = PLAYER '"'mod'"'
End
Call Close(blist)
Signal On break_c
Address COMMAND PLAYER

BREAK_C:
 EXIT


@ENDNODE

@NODE 1AOS "Nytt OS till Amigan"
@TOC 1INNE

Information om det nya Amiga OS projektet              Av Maarten Ter Mors
=============================================================================

Här är lite allmän information om projektet att skriva ett nytt Amiga OS.
Texten är kanske inte speciellt ny, men pga tidsbrist från min sida så har
jag just nu ingen annan information att ge. I fortsättningen hoppas jag kunna
rapportera om projektet och då även hinna översätta texterna till svenska.
Denna text är skriven av Maarten Ter Mors som är projektledare. (Henrik)


 ---------


1. WHAT ARE WE DOING ?
             
Isn't that the question life is all about ?  What we're doing here is writing
a new version of the Operating System of the Amiga.  That means everything
from Exec, through DOS to Intuition and GadTools.
We will do this in a hardware-independent manner, in a hardware-independent
language, most likely GNU C++, so our OS will be portable to (in theory) any
conceivable hardware platform.


2. WHY ARE WE DOING IT ?

The Operating System is tha Amiga's main feature these days.  Its hardware is
showing its age after few real changes since 1985 and apart from that, it is
likely to be a long time before the first new Amiga will appear, if ever.
The Commodore fiasco surely isn't doing the Amiga any good in the
professional sector : few professionals will now buy a machine (provided they
can find one at all) that is no longer produced.  On top of that, more and
more professional software developers are moving away from the Amiga market.

But the OS is software.  Unlike hardware, it can be reproduced without the
need for actual silicon materials that cost money, assembly lines that cost
even more and factories with a price tag the size of North America.
This is what we intend to do.  If we can make another computer that *is*
still supported hardware-wise, say, a Mac, run the Amiga OS, then that Mac
would have become an Amiga.  We could run Amiga applications on it by
recompiling their sources on the new hardware (all system calls will still be
in the same place and respond in the same way, remember) and use it as if it
were an Amiga.  No matter what the front panel says.

As an added bonus, we will be able to incorporate any and all features we
want in the new OS, because we're the ones writing it !  Most Amiga users
will be fairly satisfied with what the OS can do (they ought to be, it's
still up there with the best - we're not doing all this to save a half-decent
OS, you know !), but everyone must have one thing, small or big, that they
miss or would prefer to be different.
We could give the OS a new, professional look, implement things like virtual
memory, memory protection, network support, font-sensitivity, Retargetable
Graphics...  You name it and (within reasonable limits :) we could build it
in.  This means that you can use a better OS on your Amiga with your existing
software, with the same hardware you have now.  This also means that our
effort will be useful if the Amiga does pull through.

             
3. HOW WILL WE DO IT ?

Writing an OS is no trivial task.  We have our work cut out for us, in terms
of design, programming, testing, bug fixing, documenting and a couple of more
things writing an OS involves.
To make sure all this labour is regulated, planned and not wasted, we have a
committee of coordinators who will see to it that everything is done in a
premeditated way.  The worst thing that can happen in a project such as this
is that different designers and/or programmers design incompatible pieces of
code, unaware of their respective efforts.  Most of the work will be for
nothing and the deception lethal to the motivation of those who have put so
much time and effort into their work.
To give an easy example of what could go wrong : suppose two groups of
programmers are working on the user interface.  Chances are that they'll come
up with two lay-outs, looks&feels that are just a little bit too different to
be tidy and easy to use.  A lot of work will have to go into merging the two
designs into one (chances are also that they'll both have some good features
in them).  And in the end you may still have problems making a seemless fit.
In short, an unnecessary waste of time.

The designers will come up with a detailed description of what the OS should
be able to do and (roughly) how we will implement the different aspects.
This design will be a well-thought-out mix of the ideas, wishes and
suggestions from the Amiga community (mainly from those involved in the
project, of course).
Then the ball is in the programmers' court.  They will work in groups on the
different aspects of the Operating System.  There will be a group GUI, which
will work on things like Intuition, Gadtools, ASL and so on - all in one,
uniform style, a group DOS for the disk operating system, filesystems etc., a
group EXEC that tackles the tricky task of reproducing the Exec micro kernel,
and so on, and so on.
The beta testers will be our quality check department.  They will try the
newly programmed functions in daily use.  The flexibility of the (current)
Amiga OS allows you to substitute your own functions for existing library
calls - the magic word SetFunction() will mean a lot to programmers.  Should
the beta testers find a bug (they happen), they will report this back to the
programmers, who will try to fix it.

You guessed it - this is going to require a huge pile of mail and files
flying across the globe.  Luckily for us, the Internet is made for this kind
of traffic and so it will be our first stop as far as distribution goes.  We
will have one or (probably) more mailing list(s) for exchanging news, an FTP
site for exchanging files, like sources and programs, perhaps a newsgroup for
discussions and/or a WWW site for general information.  In addition, we will
be looking for local BBS systems to become support BBS and carry our files
and documents.
And that doesn't even include the extensive email/netmail contacts the
different team members will be upholding.  Also, we'll keep the rest of the
world informed through announcements in other newsgroups (like
c.s.a.announce, for example) from time to time, as well as news bulletins to
the media.


4. WHAT AUTHORITY/RESPONSIBILITY DO THE COORDINATORS HAVE ?
   (or : who the hell do they think they are ?! :)

Everybody in on this project is so on a voluntary basis.  This not only means
that no money will be involved, it also means that the coordinators have no
real authority over the rest of the team, in the way an employer has it over
his employee.
We can not tell you to DO this or DO that, because we (or at least most of
us) live in a free world and you can do what you like.  In short, we can't
make you do anything.  This automatically implies the coordinators are no
more the boss than anybody else, nor have they any right to pretend they are
- and so they won't :-)

What we will do, is direct people in a certain direction, persuade them
(always with reason) to take a certain course of action, for the benefit of
the project.  We will have to get someone who means to make the default
look of the OS pink with green and yellow dots, not to mention a mushroom in
every corner of the screen, to change his mind, for example.
This brings us to our responsibility, which is to make the OS happen.  This
is our promise to everyone involved : we will do anything in our power
to make the goal that everybody joined to accomplish, reality.  We will do so
according to the general rules of democracy, which means that if 95% want
virtual memory support and 5% absolutely couldn't bear such an option, sorry
guys.

The other tasks of the coordinators is keeping track of progress, maintaining
contact between programmers, beta testers, the general public and everybody
else, making sure development is going according to the design everyone
agreed on, putting together beta releases and releases, contacting the media,
lose sleep and in general, tie up all the loose ends.
             
 ---------

@ENDNODE

@NODE 1CCC "C"
@TOC 1INNE

Minneshantering i filer                                Av Mattias Karlsson
=============================================================================

                                FileMem 1.0

              - eller så kan man behandla en fil som minne!

Har du någonsin önskat att du kunde på ett enkelt och smidigt sätt låta
flera programm dela på en enda datafil och samtidigt låta dem lagra sina
egna data i samma fil? Eller du kanske använder 100-tals olika små tmp
filer och önskar att det fans ett sätt att slå ihop alla dessa småfiler till
en enda stor fil.

Nu så är lösningen här! Hör bara på dessa kommentarer från några
förbipasserande:
- Jag har aldrig använt filer förut eftersom jag inte vetat hur man skall
  allokera minne för dem. Tack vare FileMem så kan jag äntligen sova på
  näterna.
Ja beställ nu så får ni inte bara 1 utan 2, ja just det 2 kopior och du
sparar 1.000:- på kopia nr 2.
(Börjar det låta som en reklamfilm från TVShop?. Bra,för det är en reklam-
film från TVShop. Skall vi övergå till grovgörat då kanske? Bra)

Ifall man vill låta flera programm dela lagringsutrymet i en fil så vore
det väl bra om det fanns ett system som tillät en att behandla filen precis
som om det vore vanligt minne? Och det är precis vad den här artikeln går
ut på.

Nu kanske en del anser att man måste hålla en lista i minnet över alla
lediga block. Frågan är berättigad och lösningen är kanske aldeless för
självklar för att man skall tänka på den. Om man nu kan lagra alla sorters
data i en fil, t o m länkade strukturer (Jepp, det är möjligt men är
igentligen en annan historia, vem vet jag kanske får anledning till att 
återkomma till det någon annan gång) varför kan man då inte lagra en så
självklar sak såsom en enkel minneslista. Igentligen så finns det ju aldrig
något "ledigt" minne i tex AmigaOS utan det är bara en fråga om vems minne
det är, tex ramlib (exec) eller de olika programmen vad gäller det vanliga
ram-minnet.

Ett annat problem är ju hur man anger maxstorleken för minnesfilen. Du
kanske säger att man måste skapa en tom fil på 100k för att kunna skapa en
fil för att lagra 100k i, när allt man behöver göra är att skapa ett
specielt minnesblock sist i filen och känna igen när man allokerar av det
blocket såsom här är fallet.

Nog rundsnack nu och ett direkt hopp rakt ner i teoribänken för här kommer
det. För att hålla reda på de lediga minnesblocken använder vi en struktur
som ser ut som följer:

LONG   Offset till nästa lediga block.
LONG   Offset till föregående block.
LONG   Storlek på det här blocket.

Som du kan se så består de två första fälten en dubellänkad lista, precis
som det vanliga ramminnet gör fast där är det en enkellänkad lista. Det är
igentligen ingen större skillnad på en enkel och en dubbellänkad lista i det
arbetsätt vi använder här fast jag har beslutat mig att använda en
dubbellänkad lista för enkelhetens skull.

Sedan så följer alltså storleken på det här blocket inklusive headern, dvs
är storleken 12 (3 LONG) så består det här minnesblocket bara av själva
strukturen och är det mer än 12 så följs den av Storleken-12 bytes av gamla
skräpdata.

Hur kan man då vara säker på att den här strukturen alltid ryms i
minnesblocken då det senare blir deallokerad? Svaret består av att man
igentligen delar upp alla storlekar antalet grupper om 12 bytes, eller
avrundar uppåt till gämna 12 bytes igentligen, varför man då automatiskt
kan vara säker på att rymma det i även det minsta minnesblock. Faktum är att
Ramminnet fungerar på precis samma sätt fast där avrundar mam till gämna 8
bytes (gäller dock inte vid AllocVec).

Om vi då skall övergå från den inledande teorin och göra en djupdykning ner
i själva huvudfilen, @{"FileMem.c" LINK 1FMC}, så ser man att den består av tre funktioner,
nämligen FAllocMem, FFreeMem & FCopyMem och de fungerar precis som deras
motsvarighet i exec (AllocMem,FreeMem & CopyMem).

Om vi går direkt in i den första funktionen, @{"FAllocMem" LINK 1FMC 12}, så ser vi efter en
inledande variabeldeklaration hur man avrundar ett tal uppåt till varfri
storlek, i det här fallet 12. Det går till på så sätt att man först ökar
storleken med avrundningssiffran-1 sedan så drar man ifrån
Storleken MOD Avrundningssiffran. Alltså så skulle de två raderna se ut så
här i tex AMOS (och en mängd andra språk också för den delen):

Size = Size + (12-1)
Size = Size - Size MOD 12

Sedan så söker vi rätt på det första minnesblocket. Detta genom att vi som
första LONG i filen har lagrat offseten till just det minnesblocket.
Observera att det första minnesblocket inte alltid är på offset 0 det är
bara en pekare till det första.

Sedan så läser vi in det minnesblocket i tre olika variabler som vi har
avsatt för just det ändamålet. Som du kan se senare så finns det alltid
åtminstående ett block med ledigt minne.

Sedan så går vi in i en loop som i början på varje omgång kontrolerar ifall
det senast inlästa blocket är stort nog att rymma den aktuella allokeringen.
Om det skulle vara falskt (minnesblocket är för litet) så söker vi först
till nästa block och det läses in.

Efter det så kontrolerar vi ifall blocket är precis lika stor som våran
begäran oisf så raderar vi det helt enkelt från listan. Eftersom hela
blocket går åt så vet vi att det finns åtminståne ett block efter (Det
stämmer dock inte ifall vi har allokerat en total filstorlek på exakt 4
gigabytes, fast ärligt talat hur stor är sanorlikheten för det?) samt att
vi alltid har åtminståne ett LONG reservetat före. (Mao Pred fältet på det
första minnesblocket måste peka tillbaka på våran orginalpekare, i det här
fallet noll).

Om det blir kvar delar av blocket så beräknar vi först offseten till den
återstående delen vilket tas från slutet av blocket och sedan så lagrar
vi den positionen på den föregående blockets Next pekare eller InitPekaren
ifall det här var det första blocket.

Sedan så kontrolerar vi ifall det här är det sista blocket och om så inte
var fallet så lagrar vi även den blockpositionen i nästa block. Om det var
det sista blocket så expanderar vi helt enkelt filen så att allt allokerat
utrymme existerar.

Och till slut så skapar vi en ny struktur efter den allokerade delen av
blocket och voila så är allokeringen klar.

Om vi övergår till @{"FFreeMem" LINK 1FMC 80} functionen så ser den precis likadan ut i början
dvs vi avrundar storleken och följer listan med lediga block tills dess vi
kommer till blocket före de vi just skall till att deallokera.

Där så kontrolerar vi om det block vi skall deallokera liger precis efter
det föregående blocket och om så är fallet så ökar vi bara på dess storlek
och returnerar.

Om inte så skapar vi ett nytt block och lägger det mellan blocket just efter
och blocket just före och voila så är det blocket deallokerat.

Om vi till sist övergår till @{"FCopyMem" LINK 1FMC 133} functionen så har den igentligen inte
så mycket att göra med själva allokeringen/deallokeringen utan är bara
ett exempel på hur man kan göra en smart datakopieringsrutin inom filer
(och tom mellan olika filer ifall man lägger till ett ToFile argument).
Inte så mycket att tillägga där igentligen utan källkoden borde tala för
sig själv.

Om vi skall övergå till det första av de två demoprogrammen (@{"Alloc" LINK 1ALC}) så är
det ett simpelt programm som allokerar ett visst antal block a 12 bytes och
sedan fyller det med ordet "Reserverad!"!. Du borde fram för allt kika på 
Filskaparrutinen, eftersom även en tom fil kräver en del initering innan
den kan användas.

Det andra demoprogrammet (@{"Free" LINK 1FRC}) deallokerar ett minnesblock som blivit
allokerad av Alloc programmet.

Om du vill kontakta mig av någon anledning (förbättringar på koden eller
buggfixar tex) så finns jag på följande adresser:

Fido : Mattias Karlsson@2:205/425.3
UUCP : betasoft@alognet.se
SNAIL: Mattias Karlsson
       Slöjdgatan 6
       930 61  Bastuträsk

@ENDNODE
@NODE 1FMC "FileMem.c"
TOC 1INNE

/* Den här filen består av en massa funktioner som ger minneshantering
 * fast istf i minnet så sker allting i en fil */

#include <dos/dos.h>

#include <clib/dos_protos.h>
#include <pragmas/dos_pragmas.h>

extern struct DosBase *DOSBase;

/* Allokerar "minne" i filen */
ULONG FAllocMem(BPTR File, ULONG Size)
{
ULONG ThisPos,PrevPos,NextPos,FSize,Tmp;

     /* Avrundar size uppåt till jämna 12 bytes */
     Size += (12-1);
     Size -= Size % 12;

     /* Söker rätt på det första lediga minnesblocket */
     Seek(File, 0, OFFSET_BEGINING);
     Read(File, &NextPos, sizeof(ULONG));
     Seek(File, NextPos, OFFSET_BEGINING);
     ThisPos=NextPos;

     /* Läser in minnesheadern för det minnesblocket */
     Read(File, &NextPos, sizeof(ULONG));
     Read(File, &PrevPos, sizeof(ULONG));
     Read(File, &FSize, sizeof(ULONG));

     /* Söker igenom minneslistan tills vid hittar ett ledigt block *
      * som är stort nog att rymma blocket */
     while(FSize < Size )
     {
          Seek(File, NextPos, OFFSET_BEGINING);
          ThisPos=NextPos;

          Read(File, &NextPos, sizeof(ULONG));
          Read(File, &PrevPos, sizeof(ULONG));
          Read(File, &FSize, sizeof(ULONG));
     };

     if(FSize == Size)
     {
          /* Hela minnesblocket går åt */
          Seek(File, PrevPos, OFFSET_BEGINING);
          Write(File, &NextPos, sizeof(ULONG));

          if(NextPos != NULL)
          {
               Seek(File, NextPos+4,OFFSET_BEGINING);
               Write(File, &PrevPos, sizeof(ULONG));
          }
     }else{
          /* Det blev kvar delar av blocket */
          Tmp=ThisPos+Size;

          Seek(File, PrevPos, OFFSET_BEGINING);
          Write(File, &Tmp, sizeof(ULONG));

          if(NextPos != NULL)
          {
               Seek(File, NextPos+4, OFFSET_BEGINING);
               Write(File, &Tmp, sizeof(ULONG));
          }else{
               /* Vi måste expandera filen så att det sista blocket hamnar rätt */
               SetFileSize(File, Tmp, OFFSET_BEGINING);
          }

          Seek(File, Tmp, OFFSET_BEGINING);
          Write(File, &NextPos, sizeof(ULONG));
          Write(File, &PrevPos, sizeof(ULONG));
          FSize -=Size;
          Write(File, &FSize, sizeof(ULONG));
     }
     return(ThisPos);
}

/* Deallokerar "minne" i filen */
void FFreeMem(BPTR File, ULONG Pos, ULONG Size)
{
ULONG OldPos,FSize,NextPos,ThisPos,PrevPos;

     /* Avrundar size uppåt till jämna 12 bytes */
     Size +=11;
     Size -= Size % 12;

     OldPos=Seek(File, 0L, OFFSET_BEGINING);
     Read(File, &NextPos, sizeof(ULONG));
     Seek(File, NextPos, OFFSET_BEGINING);
     ThisPos=NextPos;

     Read(File, &NextPos, sizeof(ULONG));
     Read(File, &PrevPos, sizeof(ULONG));
     Read(File, &FSize, sizeof(ULONG));

     while(NextPos < Pos)
     {
          Seek(File, NextPos, OFFSET_BEGINING);
          ThisPos=NextPos;

          Read(File, &NextPos, sizeof(ULONG));
          Read(File, &PrevPos, sizeof(ULONG));
          Read(File, &FSize, sizeof(ULONG));
     };

     if(ThisPos+FSize == Pos)
     {
          /* Addera storleken till ThisPos */
          Seek(File, ThisPos+8, OFFSET_BEGINING);
          FSize += Size;
          Write(File, &FSize, sizeof(ULONG));

          return;
     }

     /* Sätter upp det här blocket att peka på oss istället */
     Seek(File, ThisPos, OFFSET_BEGINING);
     Write(File, &Pos, sizeof(ULONG));

     /* Skapar en ny header för det här blocket */
     Seek(File, Pos, OFFSET_BEGINING);
     Write(File, &NextPos, sizeof(ULONG));
     Write(File, &ThisPos, sizeof(ULONG));
     Write(File, &Size, sizeof(ULONG));

     /* Sätter upp nästa block att peka på det nya blocket */
     Seek(File, NextPos+4, OFFSET_BEGINING);
     Write(File, &Pos, sizeof(ULONG));
}

/* Kopierar en del av filen */
void FCopyMem(BPTR File, ULONG From, ULONG To, ULONG Size,
     APTR Buf, ULONG BufSize)
{

     /* Loopar så länge Size är mindre än BufSize */
     while(Size <= BufSize)
     {
          Seek(File, From, OFFSET_BEGINING);
          Read(File, Buf, BufSize);
          Seek(File, To, OFFSET_BEGINING);
          Write(File, Buf, BufSize);

          /* Updaterar pekare */
          From += BufSize;
          To += BufSize;
          Size -= BufSize;
     }

     /* Är Size MOD BufSize == 0? */
     if(Size)
     {
          Seek(File, From, OFFSET_BEGINING);
          Read(File, Buf, Size);
          Seek(File, To, OFFSET_BEGINING);
          Write(File, Buf, Size);
     }
}

@ENDNODE
@NODE 1ALC "Alloc.c"
@TOC 1INNE

/* Detta demoprogram allokerar minne ifrån filen
 * Syntax:
 * Alloc AntalBlock */

#include <dos/dos.h>
#include <stdlib.h>
#include <stdio.h>

#include <clib/dos_protos.h>
#include <pragmas/dos_pragmas.h>

#include "FileMem.h"

extern struct DosBase *DOSBase;

/* Detta är filnamnet på vmem filen */

STRPTR FilNamn="DemoFile.VMF";

int main(int argc, char **argv)
{
ULONG Block,Pos;
BPTR File;

     if(1==argc)
     {
          printf("Syntax:\nAlloc Block\n");
          exit(0);
     }

     Block=atol(argv[1]);
     if(0==Block)
     {
          printf("Syntax:\nAlloc Block\n");
          exit(0);
     }

     if(!(File=Open(FilNamn, MODE_OLDFILE)))
     {
          printf("Skapar en ny fil\n");
          if(!(File=Open(FilNamn, MODE_NEWFILE)))
          {
               printf("Kan inte skapa filen\n");
               exit(NULL);
          }
          Pos=4;
          Write(File, &Pos, 4l);
          Pos=0;
          Write(File, &Pos, 4l);
          Write(File, &Pos, 4l);
          Pos=~11;
          Write(File, &Pos, 4l);
     }

     Pos=FAllocMem(File, Block*12);
     printf("\nAllokeringen lyckades vid pos:%d\n\n",Pos);
     Seek(File, Pos, OFFSET_BEGINING);

     for(;Block != NULL; Block--)
          Write(File, "Reserverad!!",12);

     Close(File);
}

@ENDNODE
@NODE 1FRC "Free.c"
@TOC 1INNE

/* Detta demoprogram deallokerar minne ifrån filen
 * Syntax:
 * Free Offset AntalBlock */

#include <dos/dos.h>
#include <stdlib.h>
#include <stdio.h>

#include <clib/dos_protos.h>
#include <pragmas/dos_pragmas.h>

#include "FileMem.h"

extern struct DosBase *DOSBase;

/* Detta är filnamnet på vmem filen */

STRPTR FilNamn="DemoFile.VMF";

void main(int argc, char **argv)
{
ULONG Block,Pos;
BPTR File;

     Pos=atol(argv[1]);
     Block=atol(argv[2]);

     if(!(File=Open(FilNamn, MODE_OLDFILE)))
     {
          printf("Kan inte öppna filen\n");
          exit(0);
     }

     FFreeMem(File, Pos, Block*12);

     Close(File);
}

@ENDNODE

@NODE 1EIN "Förberedelser inför E-skolan"
@TOC 1INNE

Amiga E information
=============================================================================

Här var det tänkt att Amiga E-skolan skulle starta, men någon tyckte
att plugget var viktigare, så starten är uppskjuten till nästa nummer.
Istället har vi lite information om var och hur du kan skaffa den
registrerade versionen av E. Informationen kommer från Jonas Tehler,
sysop på Digital Square (D²) som är supportbas för Amiga E. Jag lämnar
nu över ordet till Jonas.

 ---------

            Official Amiga E Registration Site
            
Nu kan man börja registrera Amiga E genom mig. Det här är priserna som
gäller tills vidare.

Amiga E på disk     - 300kr - Du får en diskett i brevlådan med hela den
           senaste versionen av Amiga E. (just nu v3.1a)

Via email eller BBS - 260kr - Du får kompilatorn (ca 60K) utan 8K-spärren
           via email (internet) alternativt kan du hämta
           den här på supportbasen.

Priserna är preleminära och kan komma att variera beroende på kurs-
förndringar mm.

Betala helst via PostGiro (nr 6106998-5)

Fråga mig om du vill betala på något annat sätt.

Jag måste veta ert namn och full adress, telefon, email-adress, och helst
också datorkonfiguration.

/mvh Jonas Tehler (SysOp)
     Digital Square (D²) 08-7546400


@ENDNODE


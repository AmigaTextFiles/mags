@database "Amiga Haber Veda"
@font XEN-ISO9.font 11

@node Main "AMIGA HABER VEDA SAYISI"
AMIGA HABER VEDA SAYISI  EKİM 1997
----------------------------------
        @{"SON ÖNSÖZ" link ONSOZ}

        @{"C/C++ KURSU" link MUAD}

        @{"AMIGA VE PROGRAMCILIK" link PRO}

        @{"HD-TOOLBOX PROGRAMI" link TOOLBOX}

        @{"AMOS" link AMOS}

@endnode

@node ONSOZ

Merhaba herkese,

AMIGA`nızda bulunan bu disket AMIGA HABER`in veda sayısı.17 sayıdır
sizlere AMIGA dünyasındaki bütün yenilikleri buradan duyurmaya
çalıştım.Sağolun sizler oldukça destekte bulundunuz 17 sayı boyunca.

Ancak son 2-3 aydır AMIGA HABER`e ilgi oldukça azaldı.Aylık 45-50
olan tirajımız geçen ay 30`a kadar düştü.Ayrıca birçok okuyucu
PC!,SURVIVOR AMIGA ve AMIGA HABER`deki yazıların birbirinin aynı
olduğundan yakınmaya başladı.Evet haklısınız yazılar aynı oldu ama
başka çaremiz yoktu,sonunda kaç kişiyiz şurda ?

AMIGA HABER`in son sayısıyla AMIGA`dan uzaklaştığımız sanılmasın.
PC! dergisindeki yazılarıma aynı hızda ve ciddiyetle devam edeceğim.
Ayrıca Türkçe Workbench ve yeni çıkacak birkaç oyun ve programların
Türkçeleştirilme işlemlerine devam edeceğim.

AMIGA HABER`i kapatmadan birkaç söylemek istediğim var:

- Lütfen bizleri eleştirmeden önce içinde bulunduğumuz durumu
göz önünde bulundurun.Elimizden gelenin en iyisi yapmaya
çalışıyoruz ama yine de bazılarına yaranamıyoruz.

- AMIGA HABER`in karı düştüğü dergiyi kapattığımı düşünüyorsanız
yanlış yaparsınız.Şimdiye bu dergiden elime geçen en yüksek
miktar 30-40 günde 2.500.000 TL oldu.O parayı da zaten sizin
JOY Bilgisayar`dan aldığınız oyunları Internet`ten çekerken
oldukça yükselen telefon faturama yatırdım.(Internet`te telefon
faturaları aylık 12.000.000 civarında).Örneğin en son çıkan
TFX için yaklaşık 4 saat bağlı kaldım,bu telefon faturama yanlızca
4 saatte 750.000 TL olarak yansıdı.Bunları yakınmak için anlatma
dım,yanlızca gerçeklerin bilinmesini istiyorum.

Bu sayıda elime son geçen yazıları okuyabilirsiniz.

17 sayı boyunca bana mektup  ve yazı gönderen herkese
buradan çok teşekkür ederim.İsim saymak istemiyorum çünkü
unuttuklarım olabilir.

PC! ve SURVIVOR AMIGA dergisinde yeniden buluşmak üzere.

Sinan Gürkan

@endnode

@node AMOS

Merhaba Amiga dostlari 

Bu sayidan itibaren Amiga Haber dergisinde bir AMOS Professional
yazi dizisi baslatiyoruz. Bu dizide Turkiye'deki programciliga
merakli tum arkadaslarla birlikte Amiga'da programciliga bir giris
yapacagiz.   Tabii ki bu sadece bir baslangiç olmakla kalmayacak,
ilerleyen sayilarla birlikte butun AMOS komutlarini, programlama
tekniklerini ogrenecek ve çesitli programlar yapmaya baslayacagiz.
Herhalde cogu Amiga kullanicisi AMOS hakkinda birseyler
duymustur.  Ancak hala Turkiye'de AMOS'un bir shoot'em up maker
oldugunu sanan bazi arkadaslar oldugunu bile gordugum için konuya
AMOS'u tanitarak bir giris yapmak istiyorum.
AMOS temelde bir BASIC dili. Ancak siradan bir basic dilinden 
çok çok buyuk farklari var.  AMOS'la yapabileceklerinizin hemen
hemen siniri yok diyebilirim.  Bunu zaten beraber yaptigimiz
program uygulamalariyla da gorecegiz.
AMOS ilk olarak STOS adiyla Atari ST bilgisayarlar için piyasaya
suruldu. Ancak Atari ST kullanicisi olan dostlarimiz STOS'un
degerini bilemedikleri için François Lionet amcamiz ve ekibi
Amiga piyasasina yonelerek AMOS'u piyasaya surduler, çok iyi de
ettiler. 
AMOS Amiga'da tutulunca François Lionet surekli AMOS'un yeni
surumlerini yazarak sonunda AMOS'u mukemmel bir hale getirdi.
Su anda AMOS Professional Amiga'nin kendi BASIC diliymis gibi
revaçta olan bir program. Dunyadaki çesitli AMOS programcilarinin
AMOS'la yaptiklari birçok programi hayranlikla kullaniyoruz.
Ayrica AMOS'la yapilmis her turden birçok programi Aminet'te
bulabilir ve bu programlarin neler yapabilecegini gorebilirsiniz.
AMOS Professional programini kullanabilmeniz için once AMOS'un
toplam 9 disket olan program, data, update ve compiler disklerini 
temin etmeniz gerekiyor. Bu diskleri soyle siralayabiliriz:

   1.  AmosPro_System:
   2.  AmosPro_Extras:
   3.  AmosPro_Examples:
   4.  AmosPro_Tutorial:
   5.  AmosPro_Accessories:
   6.  AmosPro_Productivity1:
   7.  AmosPro_Productivity2:
   8.  AmosPro_Update:
   9.  AmosPro_Compiler:


AMOS Professional programinin çalismasi için AmosPro_System: adli
diskete sahip olmaniz yeterli ancak sadece bu diskete sahip olmakla
sadece programlarinizi (sinirli olarak) yazip AMOS Professional'in
editorunden bu programlarinizi çalistirabilirsiniz, ancak AMOS'tan
tam performars almak ve AMOS'un nimetlerinin tamamindan yararlanmak
için yukaridaki 9 diskete de sahip olmaniz gerekiyor.
Bu disketleri aldiniz ve harddiskinize install ettiniz. Simdi yapmaniz
gereken birsey daha var. AmosPro_Update disketini kullanarak daha once
harddiskinize kurdugunuz Amos Professional'i v2.00 versionuna update
etmeniz gerekiyor. Boylece AMOS Professional'in update edilmemis
versionunda bulunan buglari ve duzgun çalismayan bazi yardimci
programlari duzeltmis oluyoruz. Update islemini AMOS Professional'i
harddiske install etmeden once de yapabilirsiniz ancak bunun için
AMOS Professional disklerinizi yedeklemenizi tavsiye ederim.
Butun bu islemleri hallettikten sonra artik AMOS Professional programini
çalistirabiliriz.
Programi çalistirdiginizda editor ekrani karsiniza çikacak.
Kodlama çalismalarinizin buyuk bir bolumunu bu editor ekranindan
yapacaksiniz. Bazi durumlarda ise yapacaginiz bir islemin sonucunu
yazmakta oldugunuz programi çalistirmadan onceden gormek istiyorsaniz
bunu DIRECT MODE'u kullanarak yapabilirsiniz. Direct mode'da yaptiginiz
islemin sonucu aninda ekranda gozukur. Direct Mode'a geçmek için ise ESC
tusuna basmaniz gerekiyor.
Bu sayimizda AMOS'a ve BASIC'e yeni baslayacak olan arkadaslar için ve
AMOS'ta biraz ilerlemis olan arkadaslar için iki kuçuk programimiz var. 
Bu programlari AMOS Professional editorune yukleyin ve F1 tusuna basarak 
çalistirin. Ayrica bu programlar uzerinde yapacaginiz kuçuk degisikliklerle 
ortaya çikacak olan sonucun degisecegini goreceksiniz. 
Iste bu programlar ve açiklamalari.

  **  Program1.AMOS  **

Bu programin yaptigi is 320x256 boyutlarinda 32 renkli lowres bir ekran 
açmak ve bu ekranin belirtilen yerlerine yazilar yazmak. Kullanilan 
komutlar ve gorevleri ise soyle:

Screen Open 0,320,256,32,lowres
     |      |  |   |  |    |
     |      |  |   |  |    -> Açacagimiz ekranin lowres
     |      |  |   |  |       olacagini belirtiyoruz.
     |      |  |   |  |
     |      |  |   |  -> Açilacak olan ekranin 32 renkli olacagini
     |      |  |   |     belirtiyoruz.
     |      |  |   |
     |      |  |   -> Açilacak ekranin Y boyutu. (256 pixel)
     |      |  |
     |      |  -> Açilacak ekranin X boyutu. (320 pixel)
     |      |
     |      -> Açacagimiz ekranin numarasini belirtiyoruz.
     |         (0-7 arasinda toplam 8 ekran açabiliriz)
     |
     -> Ekran açma komutu.

Cursoff  ---> Cursor imlecini gorunmez hale getirir.

Cls 0   ----> Ekrani siler. Cls komutundan sonra kullanilan sayi
              ekrani silecegimiz renk numarasini belirtir.

Hide On ----> Mouse pointerini yokeder.

Paper 0 ----> Ekrana yazacagimiz yazilarda yazinin zemin rengini 
              sifirinci renk olarak belirtiyoruz.

Flashoff ---> AMOS'ta ekran açtiginizda 3 nolu renk flash atar.
              Bunu onlemek için bu komutu kullaniyoruz. Flash komutunun
              ayrintilarina daha sonra girecegiz.

Locate 10,13
  |     |   |
  |     |  -> Az sonra ekrana yazacagimiz yazinin Y koordinati.
  |     |
  |     -> Yazinin X baslangiç koordinati.
  |
  -> Yazilacak yazinin ekranin neresine yerlestirilecegini
     belirtmek için kullanilan komut.

Locate komutundan sonra kullanilan koordinat rakamlari biraz sonra
deginecegim Print komutu için geçerlidir. Yani ekranin normal 10,13
koordinatlari degil, 10x8,13x8 = 80,104 grafik koordinatlarina esittir.

Print "Amiga Haber"
  |         |
  |         -> Tirnak isaretleri içindeki yazi ekrana yazilir.
  |
  -> Ekrana yazi yazma komutu.

Repeat  ---> Bir donguyu baslatir.

Until Mouse Key  ---> Baslatilan dongunun mouse tusuna basilincaya
                      kadar devam edecegini belirtiyoruz.

Edit   ---> Editor ekranina donmemizi saglar. 
            (Artik programin çalismasi bitmistir.)

  **  Program2.AMOS  **

Bu programimiz ise daha once AMOS kullanmis olup AMOS'ta biraz daha
ilerlemis olan arkadaslar için.
Bu program basit ama sirin bir intro. Bu intro hiç de komplex bir
program sayilmaz ama derdini rahatlikla anlatabiliyor.
Programin yaptigi sey muzik çalmak ve AMIGART logosunu ve suya dusen
golgesini bir oraya bir buraya hareket ettirmek. Inceleyin bakalim.

Evet arkadaslar,
ilk sayida bu kadar yeter diyorum ve artik yazimi bitirmek
istiyorum. Size bu sayida bana ulasabilmeniz için bir e-mail adresi
veya telefon numarasi veremiyorum. (Evimi tasiyorum ve servis
saglayicimi degistiriyorum) Ancak bir dahaki yazimda bana ulasabileceginiz
e-mail adresimi ve telefon numarami da verecegim. Boylece takildiginiz
ve yardim istediginiz yerlerde bana danisabilecek, ayrica kendi
fikirleriniz ve tavsiyelerinizle AMOS kosesinin gidisatini
belirleyeceksiniz.  Gelecek sayida gorusmek uzere...

                                                      Alp YENER


@endnode


@node TOOLBOX

                     HARDDISK TOOLBOX

  Bu ay yeni upgrade eden arkadaşların özellikle harddiskler,cd-romlar üzerine 
bunların tanıma,uyum,düzenleme gibi problemlerinin üzerine sihirli bir iksir te
davisi etkisi gösteren bir programa göz atacağız.Tabi uyum falan dedikse pc'deki 
gibi ses kartı modem çakışması falan değil.Ya da ne bileyim Newicons'ı install 
ettim Flyin'High bozuldu gibi değil.Hadi herşeyi bozup yeniden yapalım.(Başlama
dan önce en aşağıdaki NOTları okuyun)

 İlk önce "İnstall 3.0"diye bir program var bunu alıyorsunuz.Yeni bir harddiskiniz
var uygun bir format attıktan sonra.İnstall 3.0'ı install ediyorsunuz.Bu program
aslında "Workbench 3.0"ı harddiskinize install ediyor ve kullanıma hazır,start-up'lı
falan bir harddiskiniz oluyor.Program disketinin içinde yer alan "HDTOOLS"da Work
bench'in Tools bölümüne atılıyor(ya da siz kopyalıyorsunuz).Biz şimdi bu aletlerden
HDToolBox programı ile haşır ve neşir olacağız.Programı eğer işlemlere yeni baş
lıyorsak yani harddisk'i bölümlere ayırma falan diskten çalıştırın.

  Program Amiganıza bağlı device'leri kontrol etti ve sıkıcı gibi gözüken nitekim
oldukça etkili menümüze geçtik.Eğer harddiskiniz tanınmadıysa "Change Drive Type"
a basın buradaki markalar da yer almıyorsa "define new"deyin.Çıkan menüden read
configuration deyin ve harddiskinizi babalar gibi tanıtmış olun.Bu işlemi iki 
harddiski taktığınız zaman ikisinide tanımak için kullanıyoruz.Mesela ben 2.5inch
olan ufak harddiskimin yanına 1gb olan 3.5inch normal bildiğimiz IDE pc'lerde 
kullanılan harddiski aldığımda küçüğü büyüğe tanıtırken kullandım.Jumperlardan
bir harddiski MASTER(Efendi/ilk okunan)ikincisini SLAVE(esir/tanınan ama amale 
olan)yapıyoruz.Sonra Opus veya DiskMaster gibi bir programla kopyala diyoruz
sonra da küçük harddiski satıp para kazanıyoruz.Tanıtma faslı bittikten sonra
artık makine HD'i tanıyor siz de "Save Changes To Drive"diyerek kaydediyorsunuz.

  §imdi de harddiski bölümlere ayırmaya göz atalım:Buna da karar vermek yine 
elinizde ve çok rahat.İki bölümden düşünüyorsak Low level format atıyoruz ki
bunu biraz çoğaltmak sizi rahatlatır düşünün 1.2gigabyte hd var ve 600mb'lık
iki bölümden oluşuyor neyse siz çok bölüm düşünüyorsanız Partition Drive basın:
§imdi çıkan yerden orta sırada yer alan "New Partition"(yeni bölüm)a basın.
§u an iki bölüme ayrılmış ve gri/beyaz karışımlı(taralı küme gibi)(hey gidi ilk
okul)alan var sol taraftakine basın siyah oldu.Hemen altında mavi bir ok var
onu mouse'un sol tuşuyla basılı tutarak sol doğru oynatın.Bıraktığınız yerin
altında size numarasıda değişecek.İşte bu belirledeğimiz bölümün mb cinsinden
kapasitesi.İyice belirleyin ve durun.Bu ilk belirlediğimiz DH0 bunun okunması
gerekli yani Start'up'ı bu bölüm olacağı için Bootable'ı tikleyin.Bu bölümü
Workbench olarak düşünün ve yaklaşık 40mb'lık yapın.Workbench ile ilgili gerekli
gereksiz ne varsa buraya atarsınız ve diğer bölümleriniz Workbench olmayacağı 
için daha rahat olacaktır.Yani size de rahat bilgisayarınıza da.İsim de konduktan
sonra ok'ye basın.Sonra da bölmek istediğiniz diğer yerler için sırayla New par
tition deyin,ardından sırayla küçük mavi ok ile MB'ı belirleyin,alttan da adını
dh1,dh2,dh3...olarak girin fakat yalnız dh0 bootable olsun.İşte daha modern bir
harddisk ve huzurlu siz.Eğer Virtual memory kullanacaksanız 15-20 mb'lık bir yer
daha açın ne bileyim harddisk'i Macintosh olarak kullanacaksanız 200-250mb'lık
bir yer internet için ayrı bir bölüm açabilirsiniz.Ben size 4 yada 5 bölüm yapma
nızı öneririm bu işlerinizi kolaylaştırır ve arşiv büyüdükçe siz de kafayı ye
messiniz.Her şey bittikten sonra Save Changes to Drive deyin ve kaydedip kaçın.

  NOT1)Eğer harddiskiniz zaman olarak epey yol almışsa yeni bölümlere ayırma iş
lemini kullanmayın çünkü yeni bölümlerin oluşturduğu düzene göre format atacaktır.
Dilerseniz Harddiskin kopyasını veya backup'ını alın ona göre karar verin.Genelde
yeni alanlar ilk başta yaparsa rahat olur.

  NOT2)Sinan Gürkan'a bu programı ilk aldığımda bana katlanıp yardım ettiği ve Hd'imi
gün ışığına çıkardığı için selam ve teşekkür.

Berk İybar


@endnode TOOLBOX

@node PRO

Senin dilin ne diyo ??

Giris

    Merhabalar,

  Bu aydan itibaren AmigaRT olarak yepyeni bir bolum ile karsinizdayiz.Bolumun
adindan da anlayacaginiz gibi Amiga,assembly (MC 68k ve belki ileride PowerPC )
programlama ve bilgisayarimizin ve isletim sistemimizin calisma modelleri
uzerine duracagiz. Sadece assembly ile kalmayip C/C++ gibi yuksek seviyeli
dillerden de faydalanacagiz.

 Once sizlere kendimizi tanitalim. Benim adim Erhan Bilgili. Dokuz Eylul
Universitesi Elektronik muhendisligi 3. sinif ogrencisiyim. Yaklasik olarak lise
2'den beri Amiga ve programlama uzerine calisiyorum .Diger arkadas ise usta
programcimiz Orhan Dagistanli. O da ozel bir sirkette programci olarak
calismakta. Bu ay biraz isleri oldugu icin yaziyi ben yaziyorum .Bizlere ulasmak
isterseniz yazinin sonunda email'lerimizi bulabilirsiniz.

 Gelelim yazimizda neler olacagina veya olabilecegine . Aslinda bu ay icin fazla
bir konu detayina girip olayi aniden sekillendirmek istemiyorum ; zira bu bolumu
hep birlikte goturecegiz ve herkesin fikrini ortaya koymasini bekliyorum. Bu
seferlik sizlere kendi dusuncelerimi aktaracagim ve yorumlarinizi bekleyecegim .

 Neler olabilir ?

  Yazi dizisine once bir islemci mantigi olusturarak baslamak istiyorum. Daha
sonra ise  Motorola 680x0 islemcilerinin mimarisi ve programlama modelleri
uzerine duracagiz. Onceleri 68000/010 , daha sonra ise 68020+ islemcilerin
komutlarini ve adresleme modlarini verecegiz.Sonra ise Amiga olayina girecegiz.
Daha once bazi dergilerde yayinlanan programlarin aksine olabildigince isletim
sisteminin sinirlari icinde dolasacagiz. Yani yapacagimiz sey demo/intro yazmak
bile olsa olabildigince isletim sistemini rahatsiz etmeden yapmaliyiz. Bunun
nedeni ise acik . Daha onceleri bazi illegal , kural disi yontemlerle ( absolute
-sabit- adresleme, dogrudan donanim kullanimi vb. ) programlarin su anda yuzde
kaci tam olarak calisiyor ? Cevabi neredeyse hic. Belki o zamanlar kendilerine
gore hakli sebepleri ( RAM'in 1 mb olmasi ,harddisk kullaniminin yaygin olmamasi
ve disketlerden tam olarak istifade etmek gibi ) vardi , en azindan oyle
dusunuluyordu. Fakat su anda durum oldukca farkli. Genelde Amiga
kullanicilarinin iyi birer islemcileri , bol RAM lari ve yeterli harddiskleri
var; hatta bazi sansli seytanlarin grafik kartlari bilen var .Ayrica gelecekte
Amiga donaniminda koklu degisiklikler olmasida gundemde .Boyle bir durumda
kurallarin disina cikmak oldukca riskli bir is. Hatta eger gfx , ses karti gibi
birimlerden faydalanmak istiyorsaniz OS oldukca faydali bir eser .Peki hic mi
donanim olmayacak ? Tabi ki olacak . Blitter, copper gibi birimlerin kullanimini
daha iyi anlamak icin once h/w olarak inceleyip daha sonra ise OS ile olan
koprulerini kuracagiz .Bu arada tekrar belirteyim , bunlar benim olabilirlerim ;
sizden daha iyi fikiriler (OZELLIKLE YAZININ PERIYODU) gelmesi halinde yazimiza
oyle bir sekil verebiliriz ,beklerim efenim .

Kaynaklar

Evet. Lafi fazla uzatmayalim ve gelelim kullanacagimiz kaynaklara.Asagidaki
kaynaklari size siddetle tavsiye ediyorum.

M68000PM/AD - 680x0 Programmers Reference Manual

 * Asagidakilerden bir tanesini islemcinizin modeline gore secin :

M68000UM/AD - MC68000 User's Manual

M68020UM/AD - MC68020 User's Manual

M68040UM/AD - MC68040 User's Manual

M68060UM/AD - MC68060 User's Manual

MC68030UM/AD - MC68030 User's Manual / Prentice Hall

Yukarida saydigim bu kitaplar [http://www.design-net.com] Motorola Literature
Distribution Center'lar tarafindan ucretsiz olarak dagitilmakta (en azindan ben
oyle aldim).Bu arada bunlardan herhangibirisini bulmakta zorluk cekiyorsaniz
bana adinizi ,adresinizi ve islemcinizi belirten bir mail atabilirsiniz .

Amiga ROM Kernel Reference Manuals : Libraries (Rev 3)

Amiga ROM Kernel Reference Manuals : Devices

Amiga Hardware Reference Manuals (ECS)

 * Sanirim yukaridakileri kitap halinde bulmaniz oldukca zor olacak .Bende
bunalrin Amigaguide formatindaki halleri bulunmakta ( adresi neydi yaw ?? ) . Bu
arada ortaliklarda dolasan ve oldukca iyi oldugu soylenen bir kitap daha var :

The Amiga Guru Book - A Reference Manual by Ralph Babel

 * Bunu tam olarak inceleme firsati bulamadim ama arastirdigim kadariyla bayagi
guzel .Icerisinde exec ,dos.library (error code'lari, CLI ve user shells,
handlers ve packets, BCPL, the Global Vector, processler ve yaratilmasi,
AmigaDOS data structure'lari ) ve FastFileSystem hakkinda oldukca detayli
aciklamalar bulunuyormus. Kitabi edinmek isterseniz :

Stefan Ossowskis Schatztruhe
Gesellschaft für Software mbH
Veronikastraße 33
D-45131 Essen
Germany
Voice:  +49 (201) 788778
Fax:    +49 (201) 798447
Web:    [http://www.schatztruhe.de/] www.schatztruhe.de
E-Mail: stefano@tchest.e.eunet.de

 * Kitaplar hakkinda daha fazla bilgi icin net'te dolasan FAQ listelerine
bakabilirsiniz .

Software

Gelelim software konusuna .Assembler olarak ,ben PhxAss 4.36 ve Devpac 3.04
kullaniyorum .Sanirim Devpac'in daha yeni bir versiyonu var .Eger yeni
basladiysaniz ve bunlari kullanmakta gucluk cekerseniz size Trash'em One 'i
tavsiye ederim .Hem kullanimi kolay , hemde guzel bir debugger'i var ;fakat
sadece 68000 komut ve adresleme modlarini destekliyor .Yani 68020+ icin
yazacaksaniz bunu unutun !Paket olarak ise Devpac ( Devpac editor ,genam ve
monam ) oldukca iyi .Icerisinde profesonel bir de debugger'i var ( ben yinede
SAS/C 6.5x in debugger'i cpr yi tercih ederim ) .Fakat bence en guzel calisma
ortami CygnusED V3.x + PhxAss 4.56 + cpr 'den olusuyor .Ayrica PhxAss freeware
ve (Aminet'te var) oldukca kaliteli bir program (devpac gibi bir programin
orjinalini alamiyorsaniz , korsan kopyasi yerine bir freeware kullanmak cok daha
iyi bir secim :) ).

C/C++ Compiler olarak SAS/C 6.5x paketini oneririm .Bende su anda 6.51 bulunuyor
.Aminette daha yukari versiyonlara upgrade etmek icin patchler bulunuyor ;fakat
nedendir bilinmez benim SAS/C bir turlu patch olmuyor (bana hep yanlis
versiyondan bahsediyor) .Bunu becerebilen veya elinde 6.55 ve yukari bir
versiyonu olan varsa bana nasil yaptigini veya 6.50/6.51 versiyonunu nereden
aldigini bildirirse sevinirim .SAS/C 2 MB+ gerektiriyor .Ayrica StormC 2.x ,
DiceC 3.5 ve GNU gcc gibi compiler lar da mevcut .StormC 2.x 'in $499 CAD
(yaklasik 50 milyon !!....!!) gibi bir fiyati var .yaklasik 4 MB gibi bir hafiza
gerekiyor .DiceC ise birkac hafta oncesine kadar commerical bir programdi ;fakat
gecenlerde full sourcelari ve paketin tamami Aminete koyuldu , yani artik
freeware .Su ana kadar kullanmis degilim ve nasil oldugunu bilmiyorum . Gcc'ye
gelince ,oldukca iyi . Hem de freeware .Su anda bircok platforma bulundugu icin
oldukca iyi bir temele ve standarta sahip .Kullanmak icin yaklasik 6 MB Ram
gerektiriyor. Tabiki harddisk'ten bahsetmiyorum bile ... (Harddiskiniz vardir
degil mi ?? :)) Bu arad sunu da belirteyim ; daha onceki makinamin yanmasi (...
ve dolayisiyla kart) ve benim tekrar bilgisayar almam nedeni ile su anda ciplak
1200'um var .68K boardlari (040 , 060 falan) yerine PowerPC yi bekliyorum .Bu
sebeple su siralar C++ ve C ile pek birseyler yazamiyorum :

Neyse , bu seferlik bu kadar .Dedigim gibi , yorumlarinizi bekliyorum .Bir
dahaki yazida gorusmek uzere .Simdilik hoscakalin ,Amiga'yla kalin .

Bitirmeden once , son olarak birde reklam vermeden gecemiyecegim .Orhan (OR
denmesini daha cok sever , iddia ettigine gore dunyadaki kelimelerin 1/3 unde OR
hecesi bulunuyormus :>..) birkac kucuk utility yazdi ve Aminete koydu .Bunlar :

- Floppy4.1  (floppy41.lha) , DD disketlerde 1148 , HD disketlerde 2 MB den
fazla kullanabilen ,Amiga'nin keni trackdisk.device'indan daha hizli bir device
. (SHAREWARE)
- Orpsw V2.3 (orpsw23.lha) , bircok kucuk commodity'nin (hatta yeni bir console
: KON:) bir arada toplandigi bir utility . (SHAREWARE)

Erhan Bilgili email : prohst03@unimedya.net.tr

Orhan Dagistanli email : prohst03@vm.ege.edu.tr


@endnode PRO

@node MUAD


                  BUGÜN C İÇİN NE YAPTIN?


  İlk lafım yeni çıkan Amiga uyumlular hakkında.  Uzun sÜredir 
heyecanla beklediğimiz resmi lisanslı Amiga clone'larının fiyatları da 
beklenenin altında olmadı tabi.  Bu kasalı Amigalar'ın piyasaya 
çıkması her ne kadar sevindirici olsa da, yeteri kadar geniş bir 
alıcı kitlesine ulaşıp ulaşamayacaklarını kestirmek zor.  Hepimizin 
farkında olduğu gibi, bu fiyata satılan bir A1200 tÜrevini sıradan bir 
PC kullancısına pazarlamak yÜrek ister.  özellikle TÜrkiye'deki 
inanılmaz ucuz toplama-PC fiyatları nedeniyle geçerli olan bu durum, 
yeni Amigalar'ın hedef pazarını eski Amiga kullanıcıları ile 
kısıtlıyor.  Ve nedendir bilinmez, biz TÜrk Amigacıları'nın cebinde 
fazla miktarda para bulunmuyor.  Amiga'mızı bu kadar gönÜlden 
sevmemizin bir nedeni de bu kadar ucuz fiyat ve dÜşÜk konfigÜrasyon 
ile bize hayal bile edemeyeceğimiz işletim mÜkemmelliğini sağlaması 
değil midir?  Neticede, biz TÜrkler arasından yeni Amigalar'ı almaya 
yeltenecek çok fazla kullanıcının çıkacağını sanmıyorum.
  Ama alın.
  Her gÜn abuk subuk yerlere harcadığınız paraları bir kenara koyun, 
dolara çevirin, biriktirin, eğer ikinci bir bilgisayarınız varsa onu 
satın; yeter ki zor elde ettiğiniz paranızı çarçur etmeyin.  
Birikiminizin ne kadar çabuk arttığını göreceksiniz.
  Avrupa'da toplama bilgisayar fazla tutulmadığı için yeni Amigalar'ın 
daha çok satılacağı muhtemel.  öyle olmasını bÜtÜn kalbimle diliyorum.  
ÇÜnkÜ eğer yeteri kadar A1200 clone'u satılırsa Micronik gibi 
şirketler Üretimlerini artırıp bilgisayar başına maliyeti 
dÜşÜrebilirler.  §u sıralar oldukça pahalı gelen kasalı Amiga 
fiyatları da böylece PC kasaları gibi makul seviyelere iner.  Sonunda 
A1200 clone'ları, asıl hedef kitlesi olan bol paralı ama cimri PC 
kullanıcılarına direk olarak ulaşabilir.  Gerisi zor değil.
  Evet, yeni Amigalar'ın devrim yaratabilmesi için gerçekten sizin 
onları almanıza ihtiyaçları var.
  "Bana ne abi, Amiga çok çok satsın, herkes Amiga alsın, ben de bi 
tane alırım," demeyin, hele paranız varsa hiç dÜşÜnmeyin, turbo 
kartlı yeni bir Amiga'ya terfi ederek yaratıcılığınızın kaç kat 
arttığını görÜn.  Hiçbir cafcaflı bilgisayarın Amiga'nın yerine 
geçemeyeceğini unutmayın.
  Peki bu yeni Amigalar'da ne var da bu kadar ÜstÜn?
  Bence A1300, A1400 ve A1500'lerin tek kağıda sığmayan özellikleri 
arasında en devrimsel olanı, bu makinelerin PCI ve ISA slot'larına 
sahip olmalarıdır.  Yok Zorro II'ymiş, Zorro III'mÜş, bunlar o kadar 
önemli değil.  PCI slot'unun varlığı, yeni Amiga'mıza cÜzi bir fiyata 
64-bitlik ekran kartı takabileceğimiz anlamına geliyor.  Phase5 
şirketinin CyberGraphX yazılımına PCI kartlarını kullanabilecek bir 
sÜrÜcÜ eklemesi kendi CyberVision 64/3D satışlarını dibe 
vurduracağından, bu onursal görevi Phase5'ten beklemek biraz zor.  Ama 
PCI kartlarını kullanacak yazılımlar (veya Amiga için özel PCI 
kartları) mutlaka çıkacaktır.  ISA slotlarına da kolayca 16-32-64 
bitlik ses kartlarının takılabilmesi ile Amiga bÜtÜn donanım 
kısıtlamalarından kurtulmuş oluyor.  Yani kasalı bir Amiga aldıktan 
sonra genişletmek çok ucuza geliyor.  Bu devrime önderlik etmek 
istiyorsanız paranıza kıyın ve bir A1400 veya A1500 alın.  Gelecek bu 
makinelerde.
  Phase5'in PowerPC603e kartlarının gecikmesiyle ilgili de söyleyecek 
bir çift lafım vardı ama yer darlığından (!) bir dahaki aya kaldı.

  İkinci lafım yeni bir kitap hakkında.  Belki duymuşsunuzdur, Nebula 
ödÜlÜnÜn ilk sahibi olan muhteşem ölçekli fantazi kitabı Dune, bir-iki 
ay önce TÜrkçe'mize "Çöl Gezegeni Dune" adı altında çevrildi.  
Çevrildikten bir ay sonra da çoğu kitapçıda "En çok satanlar" bölÜmÜne 
kapağı attı.  özellikle Dune 1'i oynamış HER fantazi hayranına "Çöl 
Gezegeni Dune"'u bir yerlerden bulup okuması şiddetle tavsiye olunur.  
Oyun çok gÜzeldi; kitabının ise oyundan ne kadar yÜksek bir seviyede  
şekil aldığını görebilir, Paul Muad'Dib hakkında kesinlikle tahmin 
edemeyeceğiniz gerçekleri öğrenebilir ve devasa kapsamlı felsefik bir 
bedevi macerasının ortasına atılabilirsiniz.  Sarmal Yayınevleri'nin 
çıkarttığı bu olağandışı kitabın, ciltli olmadığı halde 1.750.000 gibi 
tuzlu bir fiyata satılması çok yazık tabi, ama ilgilenenler mutlaka 
paraya kıyıp alacaktır.  Bence kaçırmayın.  Dune'u okumuş olanlar ise 
okkalı bir Dune muhabbeti koymak için bana E-Mail atabilirler.

  ÜçÜncÜ lafım ise "Rocko's Modern Life" adlı abuk ötesi bir çizgi 
film hakkında.  Psikopatlığınızı daha fazla baskı altında tutmayın, 
sabah saat 9.30'da Nickelodeon'ı açın ve Amerikalılar kafayı yiyince 
ne yapıyormuş öğrenin.
  (Acaba Rocko'nun Fan KlÜp'ÜnÜ kurma fikriyle kimse ilgilenir mi?)
@{i}
  "Bazı otistikler mÜkemmel bir soyut mantıksal dÜşÜnÜş yeteneğine 
sahiptirler."
  Bir Microsoft yetkilisi demiştir ki:
  "Bill is just smarter than everyone else."
@{ui}
  C denen bu dehşetengiz bilgisayar dilinde, çağırmak istediğimiz bir 
fonksiyona argÜman gönderirken, değişkenin sadece değerinin 
aktarıldığını, bu nedenle elimizdeki değişkenlerin muhteviyatını 
hiçbir açıkgöz fonksiyonun kurcalayamayacağını geçen ayki yazıda 
görmÜştÜk.  Açıkçası, main'den bir fonksiyon çağırdığımızda, 
argÜmanlarımızın geçici birer kopyası alınır ve bunlar çağırdığımız 
fonksiyona iletilir.  Fonksiyon ise sadece kendisine verilen bu yerel 
kopyaların değerleriyle oynayabilir; yani ancak tiridine banar.
  Dilin bu özelliğinden yararlanarak geçen ayki "power" fonksiyonunu 
azcık daha kısaltarak yazabiliriz:
@{fg shine}
/* power: as'i us'uncu kuvvetine cikarir; us>=0; surum 2 */
int power(int as, int us)
{
  int kuvvet;

  for (kuvvet=1; us>0; --us)
    kuvvet=kuvvet*as;
  return kuvvet;
}
@{fg text}
  "us" parametresi, yerel bir değişken olarak kullanılarak 0'a 
indiriliyor; artık "i" değişkenine lÜzum yok.  "power"'ın içinde 
"us"'e yapılan hiçbir değişiklik, "power" çağırılırken verilen 
argÜmana etki etmiyor.
  Eğer illa da mızıkçılık ediyor ve çağırdığımız fonksiyonun 
gönderdiğimiz değeri değiştirebilmesini istiyorsak, fonksiyona, 
değişkenimizin bellekteki adresini ihtiva eden bir "pointer" iletmemiz 
gerekir.  Böylece fonksiyon, bellek adresini takip ederek direk olarak 
orijinal değişkenle oynayabilir.  "BlöfçÜnÜn Pointer Kullanma Sanatı" 
adlı best-seller kitabın ayrıntılı özetini ilerde göreceğiz, fakat 
şimdilik bilmemiz gereken, argÜman olarak kullanmaya 
yeltenebileceğimiz bir array'in, kopyasının değil de bellek adresinin 
fonksiyona iletildiği...
  Yani bir C fonksiyonu, teslim aldığı bir array'in her elemanına 
ulaşabilir ve onu değiştirebilir.
@{i}
  "Otistikler başkalarıyla olan sosyal ilişkilerinde eşsizlik 
çekerler."
  Eski bir kız arkadaşı demiştir ki:
  "People who know Bill know that you have to bring him into a 
group... because he doesn't have the social skills to do it on his 
own."
@{ui}


                         @{bg fill}@{fg shine}STRING'LER
@{bg back}@{fg text}

  Si'de öyle bir pointer raconu vardır ki, sormayın gitsin.  öbÜr 
katıksız bilgisayar dillerinin en harbi fanatikleri bile, "pointer" 
denince, "Ulu tanrımız ANSI Sİ, yalvarıyoruz sana, bizi ihya et, o 
ölÜmsÜz pointer ışığından biraz bize de bahşet..!" diye mırıldanarak 
C'nin önÜnde saçları yere değene kadar eğilirler.  Netekim her 
programcı adayı sarp ve engebeli öğreniminin hararetli bir bölÜmÜnde 
gerçeklerle yÜzleşmek ve galaksinin en komplike pointer kullanımının C 
dilinde olduğunu kabul etmek zorundadır.  "Pointer" diyince akla C'nin 
gelmesinin bir sebebi de C virtÜözleriyle yÜz yÜze konuşma onurunu 
elde etmiş nadir sahabilerin yarattığı ve çaylak programcılar arasında 
kulaktan kulağa yayılan pointer mitleridir.
  (İlk karşılaştığım C psikopatı Orta 3'e yeni geçmiş ve birkaç 
santimetre kalınlığında miyop gözlÜkleri takan bir ilginçlikti.  O 
zaman benden 3 yaş kÜçÜk olduğu halde 4-5 bilgisayar dili bildiğini, 
en az 5-6 tane yÜzlerce sayfalık algoritma kitabı hafzettiğini ve 
yalnızca Lise 2 ve 3'lerin katılabildiği meşhur TUBİTAK programlama 
yarışmasına bi yolunu bulup o yaşta katıldığını öğrenince dudağım 
uçukladı tabi.  Bu adam öyle karmaşık C programları yazıyordu ki, o 
zaman çıkalı birkaç ay olan ve ortalığı kasıp kavuran Pentium'lara 
"çok yavaş abi" nitelendirmesini yakıştırmakta sakınca görmÜyordu.  
Sonraki gÜn dalgınlıktan elini döner kapıya sıkıştırdı.)
  Diyelim ki bir C virtÜözÜyle karşı karşıya muhabbet ediyorsunuz.  
Uzun sÜredir kafanıza takılan bi programlama sorununu ne tÜr bir 
algoritma ile çözebileceğinizi soruyorsunuz.  Adam bikaç saniye 
dÜşÜndÜkten sonra hemen çıkıyor:
  "Pointer'a pointer atayalım abi, hemen çözÜlÜr..." diyor.
  Sorun ne olursa olsun cevap değişmiyor.  Bu aşmış C'ciler ne zaman 
bir problemle karşılaşsalar akıllarına hemen pointer'a pointer'a 
pointer atamak geliyor; kaç defa atarlarsa o kadar makbul...  Bu böyle 
devam ede ede C dilinde pointer kullanmanın çok aşmış ve muhteşem bir 
olay olduğu kanısı yayılıyor.  C ile pointer özdeşleşmiş oluyor.  Çok 
karmaşık bir konu olmamasına rağmen pointer kullanımı, programcı 
adaylarına ileri safhalarda kavratılıyor ve ancak C pointer'ları ile 
işin gerçek raconunun yaşanabileceği söyleniyor.  Filhakika, işbu C 
psikopatları, C'nin bahşettiği haddi hududu olmayan pointer 
özgÜrlÜğÜnÜ sonuna kadar kullanıp galakside eşi olmayan karmaşıklıkta 
pointer algoritmaları yaratarak içlerini boşaltmasalar, her Allah'ın 
gÜnÜ sokakta toplu katliam emeliyle dolaşan başı dönmÜş psikopat 
programcı bozmalarıyla karşılaşmamız pekala mÜmkÜndÜr.
  Durum böyleyken böyle.
  İşin zevkli tarafı, pointer'larla bu kadar direk alakası olan C 
string'lerini, yalnızca array bilgilerimizi kullanarak işletebilmemiz.
@{i}
  "Çoğu otistik, spazmlar, tikler, sallanmalar gibi tekrar eden veya 
otomatik hale gelen hareketler yapar.  Bazı otistik çocuklar ileri-
geri sallanıp dururlar."
  "While he is working, he rocks...  His upper body rocks down to an 
almost 45 degree angle, rocks back up, rocks down again.  'They claim 
I started at an extremely young age,' said Gates."
@{ui}
  String, her bilgisayar kullanıcısının aşikar olduğu gibi, ardarda 
gelen karakterlerin oluşturduğu dizi anlamına gelir.  C'de ise char 
array'i kullanılarak temsil edilir ve çok sık kullanılır.  Yani diğer 
dillerde olduğu gibi string'in kendine has bir type'ı yoktur.  Verilen 
bir string Üzerinde her eve lazım tÜrden işlemler yapacak birkaç 
program yazabiliriz.  Bunun için ilk önce tekrar tekrar kullanacağımız 
fonksiyonları kodlamamız gerekir.
  örneğin mesela örneğin; öyle bir "satir_oku" fonksiyonumuz olsun ki:
@{b}
- standart girdi dosyasından sıradaki satırı okuyarak argÜman olarak 
gönderdiğimiz bir char array'in içinde saklasın.
- satırın sonundaki newline("\n") karakterini de ihmal etmesin.
- EOF(End of File)'a karşı uyanık olsun.  EOF'a gelince dursun ve onu 
char array'imizde saklamasın.
- eğer okunan satır, char array'imize sığmayacak kadar bÜyÜkse, sadece 
sığan kısmı kaydetsin ve sonuna "\n" eklemesin.
- hadi bakalım, bir de bunun ÜstÜne, okuduğu satırın uzunluğunu int 
olarak return etmeyi becersin.  Eğer "\n" ile bitiyorsa, satırın "\n" 
dahil kaç karakterden oluştuğunu return etsin.  Eğer char array'imize 
sığmayacak kadar bÜyÜkse, kaydedebildiği bölÜmdeki karakter sayısını 
return etsin. (Böyle bir durumda "\n" zaten kaydedilmeyeceğinden 
uzunluk içinde sayılmayacak.)  Eğer EOF'a gelmişse 0 değerini return 
etsin.
@{ub}
  Tamam işte, "satir_oku"'nun yerine getirmesini istediğimiz görevler 
bunlar.  Biraz dÜşÜnerek algoritmasını yazalım..:
@{i}@{fg fill}
[c: sıradaki karakter]
  for (uzunluk=0; (c newline değil) AND (c EOF değil) AND 
(uzunluk<maksimum-1); ++uzunluk)
      c'yi string'e kaydet
  if (c=newline)
      newline'i string'e kaydet
  return uzunluk
@{ui}@{fg text}
  "Destur!" deyip kodlamaya geçelim:
@{fg shine}
/* satir_oku: girdideki satir'i "satir[]"'da saklar, uzunlugunu returnler */
int satir_oku(char satir[], int limit)
{
  int c, uzunluk;

  for (uzunluk=0; uzunluk<limit-1 && (c=getchar())!=EOF && c!='\n'; ++uzunluk)
    satir[uzunluk]=c;
  if (c=='\n')
  {
    satir[uzunluk]='\n';
    ++uzunluk;
  }
  satir[uzunluk]='\0';
  return uzunluk;
}
@{fg text}
  Fonksiyonumuz hazır.  Hem kısa hem maharetli olduğundan her tÜrlÜ 
gereksiz programda kullanabiliriz. ("stdio.h"'ta tanımlı "gets" 
fonksiyonu da hemen hemen aynı işi yapıyor, ama malum biz Amigacılar 
hiç Üşenmeyiz boş zaman buldukça kendi fonksiyonumuzu kendimiz 
kodlarız kırk bin kere maşallah nazar değmez inşallah..!)  İşe bakınız 
ki "satir_oku" hiçbir şekilde faka basmıyor.  EOF'la karşılaşınca 0 
return etmesi çok mantıklı, çÜnkÜ geçerli hiçbir satırın uzunluğu 0 
değildir. (içinde yalnızca "\n" olan bir satırın uzunluğu bile 1'dir.)
  "satir_oku", doldurduğu array'in sonuna "null" karakteri "\0"'ı 
koyarak string'in bittiği yeri belli ediyor.  C dilinde nedendir 
bilinmez her string'in sonunda bir adet "\0" bulunur.  Mesela 
"satir\n" string'i, kaydedildiği char array'inde şöyle görÜnÜr:
@{bg shine}
s  a  t  i  r \n \0@{bg back}
~  ~  ~  ~  ~  ~  ~

  Yani 6 karakterin yerini kaplar.  "printf" fonksiyonu, "%s" 
parametresini gördÜğÜnde, ona tekabÜl eden argÜmanın "\0" ile biten 
bir string olmasını bekler.  Tabi ki sondaki "\0"'ı ekrana basmaz.
  "satir_oku" fonksiyonumuzu kullanan ilk programımızı yazarak 
faydalı bir eser yaratmış olalım.  Girdi dosyasındaki satırları 
okuyarak bunlardan en uzununu ekrana basan bir programcık yazalım.  
Hatta bu seçtiği satırın uzunluğunu da yazsın.  İşte algoritmamız:
@{i}@{fg fill}
  while (EOF'a gelmedik)
      if (elimizdeki satır şimdiye kadarki en uzun satırdan daha uzun)
          elimizdeki satırı en uzun satır olarak kaydet
          elimizdeki satırın uzunluğunu kaydet
  en uzun satırı yaz
  en uzun satırın uzunluğunu yaz
@{ui}@{fg text}
  "satir_oku"'yu nerede kullanacağımızı görebiliyor musunuz?  İşte 
program-Ül ÜstÜniyye:
@{fg shine}

#include <stdio.h>
#define MAXIMUM 1000

int satir_oku(char [], int);
void copy(char [], char []);

/* Girdi satirlarindan en uzununu ekrana yazar hem de ne yazar..! */
main()
{
  int siradakiuzunluk;
  int enuzunuzunluk;
  char siradakisatir[MAXIMUM];
  char enuzunsatir[MAXIMUM];

  enuzunuzunluk=0;
  while ((siradakiuzunluk=satir_oku(siradakisatir, MAXIMUM))>0)
    if (siradakiuzunluk>enuzunuzunluk)
    {
      enuzunuzunluk=siradakiuzunluk;
      copy(satir, enuzunsatir);
    }
  if (enuzunuzunluk>0)  /* girdide en az bir satirla karsilasmissak */
    printf("%s--> %d karakter boyunda\n", enuzunsatir, enuzunuzunluk);
  return 0;
}

/* satir_oku: girdideki satir'i "satir[]"'da saklar, uzunlugunu returnler */
int satir_oku(char satir[], int limit)
{
  int c, uzunluk;

  for (uzunluk=0; uzunluk<limit-1 && (c=getchar())!=EOF && c!='\n'; ++uzunluk)
    satir[uzunluk]=c;
  if (c=='\n')
  {
    satir[uzunluk]='\n';
    ++uzunluk;
  }
  satir[uzunluk]='\0';
  return uzunluk;
}

/* copy: "from[]"'daki string'i "to[]"'ya kopyalar */
void copy(char from[], char to[])
{
  int i;

  i=0;
  while ((to[i]=from[i])!='\0')
    ++i;
}

@{fg text}
  "copy" prosedÜrÜnÜ (Pascal'da "procedure") kullanarak o ana kadar 
karşılaştığımız en uzun satırı "enuzunsatir" string'inde gÜvenle 
saklamış olduk.  "copy" gibi fonksiyonlar yalnızca amelelik yaparlar 
ve herhangi bir değer return etmezler.  "void" type'ı ile, "copy"'nin 
return değeri olmadığını açıkça ilan etmiş olduk.
  main'in başında, "siradakisatir" ve "enuzunsatir" array'lerinin 
bÜyÜklÜklerini tanımlayarak ("MAXIMUM") bellekte bu array'ler için yer 
açılmasını sağladık. (Toplam 2*MAXIMUM=2*1000=2 KB)
@{fg shine}
  int satir_oku(char satir[], int limit)
@{fg text}
  satırıyla birinci argÜmanın bir char array, ikinci argÜmanın ise bir 
int olduğunu tanımlamış olduk.  Bu tanımda "satir" array'inin 
bÜyÜklÜğÜ gerekli değil çÜnkÜ bu bÜyÜklÜk zaten main'de ayarlanmış 
durumda (MAXIMUM).
@{fg shine}
  void copy(char from[], char to[])
@{fg text}
satırında da aynı durum söz konusu...

  Daha doğrusu yazı konusu...
@{i}
  "Otistik çocuklar bazen ani panik ya da hiddet krizleri geçirirler, 
bağırır veya kontrol dışı saldırırlar."
  "If he strongly disagrees with what you're saying, [Gates] is in the 
habit of blurting out, 'That's the stupidest f...ing thing I've ever 
heard!'  People tell stories of Gates spraying saliva into the face of 
some hapless employee."
@{ui}
  Dikkat ettiyseniz programımızda "ENDOFINPUT" adını verdiğimiz "!" 
sabitini kullanmadık.  Girdi dosyasının sonunu, <stdio.h>'de tanımlı 
bulunan "EOF" sabitini kullanarak tesbit etmeye çalıştık.  Klavyeyi 
kullanarak "EOF" işareti yapmayı bÜtÜn çabalarıma rağmen beceremedim.  
Neticede programımızın girdi dosyasını klavye olmaktan çıkarıp 
kanlı canlı bir text dosyasına yönlendirmemiz gerekiyor.  Bunun için 
önce CLI'yi açıp deneme amaçlı bir text dosyası yaratıyoruz:
@{fg fill}
1.DH0:>Ed RAM:Deneme.txt
@{fg text}
  gibi.  Biz dosyayı kaydedince AmigaOS'umuz "Deneme.txt"'in sonuna 
otomatikman bir "EOF" koyuyor.  Programımızı ise "Enuzun.c" adıyla 
kaydetmiş ve derleyip "Enuzun" adında harbi çalışan versiyonunu elde 
etmiş olalım.  CLI'den
@{fg fill}
1.DH0:>Enuzun <RAM:Deneme.txt
@{fg text}
  yazdığımızda programımızın standart girdi dosyasını klavye değil de 
"RAM:Deneme.txt" yapmış oluyoruz.  "Enuzun," yukarıda kodladığımız 
işlemleri "Deneme.txt" dosyasına uygulayarak en uzun satırı ve 
uzunluğunu ekrana (standart çıktı dosyasına) basıyor.  İstersek,
@{fg fill}
1.DH0:>Enuzun <S:Startup-Sequence >RAM:Sonuc.txt
@{fg text}
  yazarak Startup-Sequence'imizdeki en uzun satırı ve uzunluğunu 
"Sonuc.txt" (yeni standart çıktı dosyası) dosyasına kaydedebiliriz.  
Ekrana hiçbir şey yazılmaz.  Hatta çıktıyı ">PRT:" ile yazıcımıza, 
">SPEAK:" ile speaker'larımıza yollayabiliriz.  Cool cool yani.
@{i}
  "Otistikler göz göze gelmezler."
  "He did not look at me very often but either looked down as he was 
talking or lifted his eyes above my head to look out the window."
@{ui}
  Acaba bu en-uzun-satır programı pratikte ne işimize yarayabilir?  
main'i azıcık kurcalayarak (hatta basitleştirerek) girdi dosyasındaki 
80 karakterden uzun bÜtÜn satırları satır numaralarıyla birlikte 
ekrana yazdırabiliriz.
  Alışkanlık yapan derginiz Amiga-Haber tÜrÜnden bir AmigaGuide 
dökÜmanı, 640x256 çözÜnÜrlÜkte ve Topaz_Tur.font ile yalnız 78 tane 
karakteri pencere dışına taşmadan görÜntÜleyebiliyor.  Ben bu C 
yazımı Amiga-Haber'e koymadan önce "Enuzun" programımı kullanarak 78 
karakterden uzun bÜtÜn satırların numaralarını listeleteceğim ve sonra 
da gidip bu oyunbozan satırları bi gÜzel kırpacağım.  Bu sayede hiçbir 
bahtsız Amiga-Haber okuyucusu benim yazılarımın en olmadık yerlerinde 
scroll etmek zorunda kalmayacak hihahahohaha!

  Biraz daha eğlenmek için "tersyuz(s)" diye bir fonksiyon kodlayalım 
isterseniz.  öyle bir "tersyuz" fonksiyonumuz olsun ki,
@{b}
- "s" string'ini tersine çevirsin.
- hiçbir değer return etmesin.
@{ub}
  İşte bu kadar.  Fonksiyonlar string'lerin içerikleriyle direk olarak 
oynayabildiklerinden "tersyuz" fonksiyonunun yeni bir string yaratıp 
return etmesine gerek yok.  Fonksiyonumuzu, girdisini satır satır 
okuyup tersten ekrana basan bir programcıkta kullanabiliriz:
@{fg shine}

#include <stdio.h>
#define MAXIMUM 1000

int satir_oku(char [], int);
void tersyuz(char []);

/* Girdi satirlarini tersine cevirir. */
main()
{
  int uzunluk;
  char siradakisatir[MAXIMUM];

  while ((uzunluk=satir_oku(siradakisatir, MAXIMUM))>0)
  {
    tersyuz(siradakisatir);
    printf("%s", siradakisatir);
  }
  return 0;
}

/* satir_oku: girdideki satir'i "satir[]"'da saklar, uzunlugunu returnler */
int satir_oku(char satir[], int limit)
{
  int c, uzunluk;

  for (uzunluk=0; uzunluk<limit-1 && (c=getchar())!=EOF && c!='\n'; ++uzunluk)
    satir[uzunluk]=c;
  if (c=='\n')
  {
    satir[uzunluk]='\n';
    ++uzunluk;
  }
  satir[uzunluk]='\0';
  return uzunluk;
}

/* tersyuz: "s" string'ini olduğu yerde tersine çevirir */
void tersyuz(char s[])
{
  int uzunluk, sol, sag, temp;

  for (uzunluk=0; s[uzunluk]!='\0'; ++uzunluk)
    ;
  for (sol=0, sag=uzunluk-1; sol<sag; ++sol, --sag)
  {
      temp=s[sol];
      s[sol]=s[sag];
      s[sag]=temp;
  }
}

@{fg text}
  "tersyuz" fonksiyonu önce "\0" null karakterini arayarak "s"'in 
uzunluğunu hesaplıyor.  Sonra "s"'in solundan ve sağından ortasına 
doğru ilerleyerek karşılaştığı karakterleri değiş-tokuş ediyor.  
Taşeron değişken "temp"'e neden ihtiyacımız olduğunu görebiliyor 
musunuz?
  Bu "tersyuz" fonksiyonundaki ikinci "for" döngÜsÜne dikkat edin.  
Atama ve basamak ataması bölÜmlerinde ikişer tane bildirim var.  
Aralarındaki işarete de (söyemesi ne kadar zor olursa o kadar makbul 
oluyor) virgÜl operatörÜ deniyor.  VirgÜl operatörÜyle ayrılmış 
nesneler soldan sağa doğru işleme konuluyor.
  String konusunu da bu vesileyle tamamlamış olduk.  Hayırlı olsun 
(keh keh).  Kendi text processing programlarınızı yazmayı ihmal 
etmeyenzi.
@{i}
  "Bir otistik ailenin evinde, bÜtÜn ailenin zaman zaman ÜstÜnde
zıplayıp kollarını çırpmaktan hoşlandığı çok kullanılmış bir tramplen
vardı."
  "He has planned a full-size trampoline for a house he is building."
@{ui}
   Yoksa, Bill Gates...?
   Hmm, kimbilir?



            @{bg fill}@{fg shine}EVRENSEL DEĞİ§KENLER VE KAPSAMA ALANLARI
@{bg back}@{fg text}

  "Otostopçu'nun Galaksi Rehberi der ki," şeklinde başlayacağımı 
sanabilirsiniz, ama ne yazık ki Douglas Adams imzalı ve yÜzlerce durum 
komedisi dolu bu aşmış bilimkurgu kitabının parodisini ilerki 
yazılardan birine bıraktım.  §imdilik konumuz, leyleği havada görmÜş 
programcı adaylarının heyecanla kullanmakta tereddÜt etmediği global 
(external) değişkenler.
  Sıkıcı detay: main'in içindeki "siradakisatir" ve "enuzunsatir" gibi 
değişkenler main'e özel ve yereldir.  Aynı şekilde "satir_oku"'nun 
içindeki "uzunluk" değişkeni "satir_oku"'ya, "tersyuz"'deki "temp" 
değişkeni "tersyuz"'e yereldir.  Evrendeki madde ve enerjinin korunma 
kanununa aykırı olarak, yerel her değişken, sadece ve sadece ait 
olduğu fonksiyon çağrılınca ortaya çıkar (yoktan varolur) ve 
fonksiyondan çıkılınca tamamen yokolur. (Bunlara otomatik değişken de 
denir.)  Fonksiyon yeniden çağrılınca otomatik değişkenin baştan 
tanımlanması gerekir; netekim bu yeni değişkenin eskisiyle hiçbir 
alakası yoktur.
  Otomatiklere alternatif olarak, bÜtÜn fonksiyonlara genel olan 
değişkenler de tanımlanabilir. (AMOS'taki "Global" komutunu dÜşÜnÜn.)  
Bu değişkenler evrensel olduğundan programdaki her fonksiyon 
tarafından isimleri kullanılarak erişilebilir ve kurcalanabilir; bu 
yolla fonksiyonlar arasında argÜman listeleri kullanmadan veri 
iletişimi sağlanabilir.  Yerel değişkenlerin aksine, external 
değişkenler program sona erene kadar yokolmazlar.  Hatta kainatın 
sonuna kadar başınızda kara bulutlar gibi dolaşır ve şeytani 
arzularınızı hayata geçirmeniz için kalleşçe dÜrtÜklerler.  Yani eğer 
bir gÜn içinizden "§u Amiga'yı camdan aşağı atsam da bi Ay-Bi-Em Pi-Si 
Em-Em-İx kompetibıl alsam..." diye hırlayan davudi bir tahrik 
duyarsanız, bilin ki o ses, birkaç yıl önce yazdığınız o masum amaçlı 
C programının sol Üst köşesinde tanımladığınız o meymenetsiz hain 
external değişken deccalının sesidir...
  §aka bir yana, global değişken kullanmak, yıllanmış programcı 
guruları tarafından pek tavsiye edilmiyor.  Yine de nerede lazım 
olabileceğini ve kullanma formatını kabaca bilmemiz gerekiyor, değil 
mi ama?
  Bir external değişken, program içinde sadece bir kere, hiçbir 
fonksiyonun sınırına girmeyen bir bölgede tanımlanır.  Bu değişkene 
erişmek isteyen her işgÜzar fonksiyon, kullanacağı değişkenin bir 
"extern" olduğunu type'ıyla birlikte ilan etmek zorundadır.  "Enuzun" 
programındaki "siradakisatir", "enuzunsatir" ve "enuzunuzunluk" 
değişkenlerini "extern" yaparsak acaba ne olur?
@{fg shine}

#include <stdio.h>
#define MAXIMUM 1000

int enuzunuzunluk;
char siradakisatir[MAXIMUM];
char enuzunsatir[MAXIMUM];

int satir_oku(void);
void copy(void);

/* Girdi satirlarindan en uzununu global değişken kullanarak ekrana 
yazar.  Baska isimiz olmadıgından kodladık. */
main()
{
  int siradakiuzunluk;
  extern int enuzunuzunluk;
  extern char enuzunsatir[];

  enuzunuzunluk=0;
  while ((siradakiuzunluk=satir_oku())>0)
    if (siradakiuzunluk>enuzunuzunluk)
    {
      enuzunuzunluk=siradakiuzunluk;
      copy();
    }
  if (enuzunuzunluk>0)  /* girdide en az bir satirla karsilasmissak */
    printf("%s--> %d karakter boyunda\n", enuzunsatir, enuzunuzunluk);
  return 0;
}

/* girdideki satir'i "siradakisatir[]"'da saklar, uzunlugunu returnler */
int satir_oku(void)
{
  int c, uzunluk;
  extern char siradakisatir[];

  for (uzunluk=0;uzunluk<MAXIMUM-1 && (c=getchar())!=EOF && c!='\n';++uzunluk)
    siradakisatir[uzunluk]=c;
  if (c=='\n')
  {
    siradakisatir[uzunluk]='\n';
    ++uzunluk;
  }
  siradakisatir[uzunluk]='\0';
  return uzunluk;
}

/* copy: "siradakisatir[]"'daki string'i "enuzunsatir[]"'a kopyalar */
void copy(void)
{
  int i;
  extern char siradakisatir[], enuzunsatir[];

  i=0;
  while ((enuzunsatir[i]=siradakisatir[i])!='\0')
    ++i;
}

@{fg text}
  GördÜğÜnÜz gibi external değişken tanımlamalarının yerel 
değişkenlerinkinden tek farkı bÜtÜn fonksiyonların dışında yer 
almaları.  Programımızdaki fonksiyonların external değişkenlere 
erişebilmeleri için, gerekli gördÜğÜmÜz evrensel değişkenlerin 
isimlerini basit "extern" tanımlamalarıyla mevzubahis fonksiyonlara 
bildirdik. ("extern char siradakisatir[]" gibi).  Ama gelin görÜn ki 
bu zahmete katlanmamıza hiç mi hiç gerek yoktu.  ÇÜnkÜ bir Si 
programında bir external değişkenin tanımı, kullanıldığı fonksiyondan 
daha önce geçiyorsa, fonksiyonun içinde ayrıca bir "extern" 
bildirimine kesinlikle gerek yoktur.  Biraz önce yazdığımız programda 
bÜtÜn external değişkenler programın en başında tanımlandığından, beş 
"extern"'Ün beşini de ihmal edebilirdik.  Kafasızlık işte...
  Yeni versiyonlarını yazdığımız "satir_oku" ve "copy" fonksiyonlarına 
argÜman göndermeye gerek olmadığından, parametre listelerinde "void" 
anahtar sözcÜğÜnÜ kullanarak tanımladık.
  Bu yeni "Enuzun" programınının birincisine nazaran daha aşağılık 
olduğuna dikkatinizi çekerim.  "satir_oku" ve "copy" fonksiyonları 
geniş kullanım olanaklarını kaybederek yalnızca bu program için 
özelleştirildiler.  Ayrıca evrensel değişkenler hiçbir zaman 
yokolmayacak birer çıban misali durmadan bizi rahatsız ediyor.  Asıl 
marifet global değişken kullanmadan program yazabilmektir.  Bu böyle 
biline...
  Bitti.
  Si tanıtımımızın beşinci yazısının da sonuna geldiğimiz bu mutlu 
gÜnÜmÜzde...
  Yok, olmadı.
  Beş yazıdır soluk soluğa sÜregelen amansız Si maratonumuzun 
sonunda...
  I-ıh.
  Neyse boşver.

  N'aptık?
  C'nin en can alıcı noktalarını 5 ayda kavrayarak bu dehşetengiz 
dilin çekirdek bilgisini kotarmış olduk.  öğrendiğimiz temel 
bilgilerle kendi halinde text processing programları yazıp 
programcılık tecrÜbemizi artırabiliriz.  Keyfiniz bilir tabi ama, 
benden size tavsiye..:
@{fg fill}
  Problemler:
             Kelime-işlem programlarıyla yarattığımız dökÜmanlarda 
kullandığımız tab'ler, dökÜmanımızı ASCII formatına çevirdiğimizde 
uyumsuzluk sorunları çıkarabilir.  Bir text dosyasındaki tab'leri 
boşluk karakterleriyle değiştiren bir program yazabilir misiniz?  Her 
tab arası, diyelim ki, 5 karakter olsun.
             Tersten gidersek; bir text dosyasındaki (bir tab 
aralığını geçen) boşluk dizilerini tab ve boşluk topluluklarıyla 
değiştiren bir program kodlayabilir misiniz?  *zor*
             Bir C kaynak kodundaki bÜtÜn comment'leri silebilecek bir 
program yazabilir misiniz? (String'ler içinde geçebilecek "/*" ya da 
"*/" işaretlerine dikkat!)
             Bir C kaynak kodundaki hataları bulabilecek bir program 
yazınız.
             Yok devenin nalı.
             Yani demek istiyorum ki, programınız kapanmamış 
parantezleri, kapanmamış array işaretlerini ("[]"), kapanmamış kÜme 
işaretlerini, kapanmamış tek&çift tırnakları ve kapanmamış 
comment'leri farketsin.
             O kadar.
             Sonra da bir köşesinde AHI uyumlu movie oynatan %100 nesne-
yönelimli bir MUI requester'ı açıp hatanın nerde olduğunu kullanıcıya 
bildirsin hiyahıhahıhayt!
             Sadece bi fikir tabi...
@{fg text}
  Ana hatlar bitti.  Gelecek aydan itibaren C'nin Ürpertici, ölÜmcÜl, 
öd patlatıcı, psikopat katliamcı ve bir o kadar da ölÜmÜne sıkıcı 
derinliğine atılıyoruz.  O zamana kadar Amiga'nıza iyi bakın, 
eyvallah! :D

Not: Siz bu destansı yazıyı bitirene kadar herhalde yemekten içmekten 
kesilmiş, haftalarca uykusuz kalmışsınızdır; bari yazı bitmişken 
kalkıp araştırın bakalım; geçen sÜre içinde ayladır beklediğimiz 
PowerPC603e kartları piyasaya çıkmış olabilir..!


                                                 Çağhan "fMuadDib" Demirci
                                                   demircca@boun.edu.tr


@endnode

@node onsoz

@endnode

 



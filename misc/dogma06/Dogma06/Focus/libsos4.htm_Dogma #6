<HTML>
<HEAD>
<TITLE>
Догма - электронное Амижное издание
</TITLE>
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
<BODY TEXT="white" bgcolor="black">
</HEAD>
<script language="JavaScript" src="../topalt.js"></script>
<script language="JavaScript" src="../leftalt.js"></script>

<table BACKGROUND="../GFX/fon.jpg" align="center" width="90%" border="0" cellspacing="0" cellpadding="0" bgcolor="black">
<tr>
<td colspan="3"><font color="white">
<CENTER><BR><font size="+1" color="yellow"><b>Библиотеки AmigaOS4</b></font><BR>
<font size="-1" color="white">Автор -=\<font size="-1" color="yellow">Hans-Juerg Frieden (Hyperion Entertainment)</font>/=- CAM #6</font><BR><font size="-1" color="white">Перевод -=\<font size="-1" color="yellow">amif1team</font>/=-</font><HR></CENTER>
Библиотеки это основной строительный материал для любого программиста, а также простой вход
в интерфейс операционной системы. Практически любой элемент операционной системы AmigaOS так или
иначе взаимосвязан с системными библиотеками (естественно за редким исключением). Классическая
структура библиотеки состоит из структурной базы, находящейся в памяти (называемой Library
Base) и "прыгающего указателя", который и находится на поверхности структурной базы.
<BR><BR>
Например, нам надо вызвать некую функцию из заданной библиотеки, для начала стоит поставить "указатель"
на требуемую библиотеку с использованием вызова вспомогательной библиотеки - exec OpenLibrary, а уже затем
переместить "указатель" на требуемую функцию из состава структурной базы. Затем требуемая функция переходит
на передний план базы библиотеки, доступ к функции осуществляется "негативно", то есть от обратного
при первом векторном обращении поиск -6 секунд, при повторном -12 и так далее. Сам же вектор состоит
из одной 68k JMP-инструкции, следующей за 4 байтами адресной функции (следовательно вектор имеет 6 байт на стороне).
А сама программа просто управляет переходами на требуемый вектор.
<BR><BR>
В данном параграфе стоит отметить две основные точки: "Управление" (Direct) и "68K JMP инструкции".
<UL>
<LI>"Управление" - это важный показатель-индикатор, следящий за состоянием отсутствия взаимодействия между
собственно программой и кодом библиотеки. В отсутствии взаимодействия, процесс управления передаётся
механизмам, которые находятся "вне" данной задачи.
<LI>"68k JMP" - это также очень важный фактор, так как классическая программа при нахождении 68k JMP
инструкций просто переходит под управление 68k-кодом. А PowerPC-программы не осуществляют данный
переход, в отсутствии таких инструкций.
</UL>
Таким образом, осуществляется отгорожение в использовании 68k-библиотек PowerPC-программами (а переход
первых в режим эмуляции, каждой библиотеки в отдельности), и наоборот.
<BR><BR>
Когда мы осуществляли переход операционной системы под спецификацию PowerPC, нам удалось получить
исчерпывающие ответы на интересующие нас вопросы. А решения возникших проблем можно было найти следующими
методами:
<BR><BR>
Библиотеки должны были подходить как под PowerPC так и под 68k-код. 68k-программа должна вызывать
PowerPC-библиотеку без перекомпиляции, но тут возникал вопрос, а при обратном - откуда при запуске PowerPC-приложения
программа будет знать, является ли библиотека спецификацией PPC или 68k. Ответ был дан незамедлительно,
должна существовать возможность замены 68k-кода и функций без перекомпиляции приложения для использования искомой библиотеки.
<BR><BR>
Выход из сложившейся ситуации имелся только один, на системном уровне должна присутствовать необходимая метка библиотеки,
которая всегда стоит в режиме 68k. Но таким образом мы будем вынуждены опять же тащить за собой устаревшую концепцию,
что просто не допустимо, да и данное решение приводило к тому, что должен постоянно присутствовать режим эмуляции (за
редким исключением) для функций библиотек. Из всего вышесказанного был сделал вывод - данная методика не подходит.
Да и при этом не было возможности вызывать часто используемые инструкции или использовать их одновременно.
<BR><BR>
Установка библиотечной метки только в режим PowerPC также не решала данного вопроса. Старые приложения при
обращении к необходимой библиотеке просто не могли использовать их функции, а использование двух копий (PowerPC & 68k)
одной и той же библиотеки только осложняло их взаимодействие, да и данное решение ещё долго бы снилось разработчикам в страшном сне.
<BR><BR><font color="yellow">
Мульти-интерфейсные библиотеки
</font><BR><BR>
Но как известно, безвыходных положений не бывает, и выход был найден - его название "мульти-интерфейсные библиотеки"!
Как можно догадаться уже из самого названия, данные библиотеки могут экспортировать любое количество
переходов - "прыгающих указателей".
<BR><BR>
Что касается самого интерфейса, то он очень похож на классический, состоящий из рабочего стола,
составленного функциональными указателями, и собственно интерфейсной приватной базы данных. Что
полностью исключает наличие так называемых прыгающих инструкций. Программа, нуждающаяся в той или
иной функции, просто считывает необходимые данные, так как указатель уже установлен (данное решение
очень выгодно для использования в архитектуре PowerPC).
<BR><BR>
Основа полностью сохраняется в наследовании самой концепции, так как переходы к функциям 68k
присутствуют в полном объёме. Из-за своей функциональной "бедности" 68k-библиотеки сохраняют
указатели на своём коде, что делает возможным перенаправлять вызовы при необходимости эмулирования
или при использовании нативной версии. Это даёт возможность старым программам работать со скоростью,
доступной PowerPC, и работать под нативную системную функциональность.
<BR><BR>
Запускаемая библиотека (exec.library) служит тому ярким примером, написанная полностью под PowerPC-код,
она имеет свойство перенаправлять стол задач в требуемую среду. Так, при вызове 68k-программы,
система "AllocVec" запрашивает окончание PowerPC-версии и вызывает необходимую 68k, при этом
стоит отметить, что для самого 68k-приложения всё это происходит абсолютно незаметно.
<BR><BR><font color="yellow">
Пользовательский интерфейс
</font><BR><BR>
Интерфейс имеет непосредственную ассоциацию со структурой языка программирования C и линейным названием
текстового формата ASCII, а специфика структуры интерфейса очень похожа на замену старого стиля #pragma в SAS/C на
StormC компилятор. На сегодняшнем современном этапе это интерфейсы Java или классического C++, только при
наличии дополнительных функций и методов, не поддающихся сравнению. В теории этот структурный интерфейс
может распространяться более чем на одну библиотеку или только на одну, но с экспортированием мульти-версионного
интерфейса (о чём мы ещё напишем статью где и будет рассказано о внедрении в OS4 и PCI-архитектуре).
<BR><BR>
Интерфейсы обычно носят какие-нибудь специфические-тематические имена, в основе своей
описывающую часть плюс префикс "IFace". Так например, запускающий (Exec интерфейс)
называется "struct ExecIFace", Intuition (интуитивный) "struct IntuitionIFace" и так далее.
<BR><BR>
Таким образом, каждая библиотека как бы по умолчанию уже знает о наличии двух интерфейсов, один
из которых встроенный интерфейс управления, который может использоваться только системно (и зависит
напрямую от реальной библиотеки или девайса, а так может быть экспортирована как LibraryManagerIFace или DeviceManagerIFace).
И второй - несущий непосредственно основную функциональную часть.
<BR><BR>
Для доставки примера из интерфейса, программа должна вызвать запускающую (Exec функцию)
"GetInterface". Данная функция и позволяет использовать библиотеке базовый указатель и
линейное имя ASCII с необходимым аргументом; и создавать и/или возвращать указатель на исходную позицию.
Поэтому для удобства интерфейсы идентифицируют по именам. Основные библиотеки экспортируют в основной интерфейс
под именем "main", но хотя в этом нет особой необходимости. Для примера, запускаемую библиотеку (exec.library)
экспортируют в основной интерфейс и присваивают ей тип "ExecIFace", и "mmu" интерфейс с тем же типом "MMUIFace"
(далее мы рассмотрим управление интерфейсом с использованием Memory Management Unit под PowerPC).
<BR><BR>
Как обычно, exec.library находится на специальном счету и именно она прикладывает все свои функциональные
задачи на задержание необходимого интерфейса. Так "ExecIFace" указатель устанавливается на стартовый
C-код и сразу же готов для перехода (таким образом осуществляется симуляция авто-открытия старых C-библиотек,
что более похоже на интерфейс DOS, Intuition & Graphics).
<BR><BR>
Вызов функции из интерфейса обратно пропорциональный. Переходы по частям общего окружения структуры
интерфейса и содержат все её функции, формы и функциональные указатели, то есть вызов методики
C++ осуществляется аналогично методике Java.
<BR><BR>
Для примера, предлагаемый любой вариант "IExec" указателя в основном "main" интерфейсе с
exec.library, будет иметь тип "struct ExecIFace", а "AllocVec" функция будет описана следующим образом:
<BR><BR><font color="yellow">
 memory = IExec->AllocVec(size, memory_flags);
</font><BR><BR>
До эры AmigaOS4 это имело вид:
<BR><BR><font color="yellow">
 memory = AllocVec(size, memory_flags);
</font><BR><BR>
Как вы можете видеть, различие тут составляет включение "IExec", что касается старой системы записи
это могло бы привести к вызову и запуску основного SysBase указателя. В этом и состоит разница
в программировании переходов и включении функции AllocVec. И как это может показаться на первый взгляд
данная запись не столь необходима, но это не так, так как именно это и подключает необходимые методы
вызова библиотек:
<BR><BR>
Такой вызов необходим, так как программист получает полный контроль над вызовом, что исключает лишнюю
сортировку по "library base swapping", примером тому может служить подключение plugins к программе.
<BR><BR>
Библиотеки предоставляют полный сервис; поэтому нет необходимости подключать второй раз одну и ту же библиотеку для
предоставления одного и того же сервиса, что требовалось в старой системе при использовании функциональных имён.
<BR><BR>
Вызов происходит совсем по другой схеме, выгодно отличающейся от старой тем, что нативная PowerPC-библиотека может
имитировать старый 68k-переход.
<BR><BR>
Система полностью моделирует необходимую модель работы обоих режимов, что очень помогает работе приложений.
<BR><BR>
Что касается последнего, то это действительно очень важно. Вообще, компонентное моделирование на сегодняшний день имеет
очень большое преимущество по сравнению с традиционным программированием. Сейчас всё что нужно - это вызвать метод или требуемую
функцию, и компонентное решение найдётся само собой. AmigaOS4 сейчас переживает своеобразный технологический бум из-за огромного
наплыва новых решений и внедрения новых технологий, одним из которых является PCI-архитектура: по методу многоразового использования
интерфейса это даёт возможность беспрепятственно и полностью прозрачно реализовать поддержку PCI-контроллера, основанного на
платформе AmigaOne - чипсетом от Articia, где каждое PCI-устройство обслуживается интерфейсом "PCI_Device". Это даёт очень простое
решение управления с точки зрения программиста:
<BR><BR><font color="yellow">
 pcidev->WriteConfigByte(.);
</font><BR><BR>
При этом интерфейс сразу знает о каком разъёме идёт речь, что и даёт возможность использования сетевых карт
в PCI-мосте Prometheus; звуковой карте в Mediator или AGP-карте - посредством PCI->AGP моста, реализованного на AmigaOne.
<BR><BR><font color="yellow">
Совместимость интерфейсов
</font><BR><BR>
По умолчанию функциональность 68k-библиотек переложена на нативный вариант PowerPC, дабы обеспечить запускаемый (Exec)
элемент механизма для создания интерфейсов старого образца. Для примера, ваша PowerPC-программа хочет использовать
"foo.library", которая написана под архитектуру 68k и она к тому же ничего не знает про концепцию требуемого интерфейса;
таким образом ей остаётся только перейти к окружению 68k, которое и работает под эмуляцией PowerPC, интегрированную в
ядро OS4. Ваша программа просто вызывает эмуляцию функций библиотеки "foo.library" и всё, но конечно же для того чтобы иметь
нативную версию требуемой программы, вы можете перекомпилировать её.
<BR><BR>
А чтобы сгенерировать "main" интерфейс для библиотеки "foo.library" со всеми функциональными возможностями, просто укажите "struct FooIFace",
и интерфейс с лёгкостью начнёт эмулироваться, но бывает и наоборот.
<BR><BR>
Когда Exec сообщили команду GetInterface, вызов может быть не удовлетворён, так как библиотека
является старой 68k-архитектурой или команда GetInterface не прошла, в этом случае на помощь нам приходит
вызов RAMLIB (программы, которая отслеживает все загруженные с диска девайсы и библиотеки), которая и подскажет нам
как достать необходимый нам интерфейс. RAMLIB попытается проделать перекомпиляцию интерфейсного файла в директории
LIBS: или сгенерирует необходимый интерфейс на лету при помощи инсталляционного FD или SFD файла.
<BR><BR>
Ну и напоследок, когда foo.library будет в нативном PowerPC-виде, она повторно даст вызов Exec и
требуемая программа автоматически будет использовать уже PowerPC-версию, без перекомпиляции самой программы.
<BR><BR><font color="yellow">
Взгляд со стороны
</font><BR><BR>
На сегодняшний момент мы уже заканчиваем разработку перечисленных мною возможностей новых системных
библиотечных интерфейсов, в ближайших планах внедрение вышесказанного на уровень непосредственно приватной базы, что
даст возможность клонировать интерфейсы прямо во время их работы, а также модифицировать их в зависимости от контекста.
<BR><BR>
</font></td></tr>
</table>

<script language="JavaScript" src="../downalt.js"></script>
</BODY>
</HTML>

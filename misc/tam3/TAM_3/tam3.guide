@database "TAM 3"
@author "TAM Team"

@node main "BENVENUTI IN TOTAL AMIGA MAGAZINE NUMERO 3!!!!!!!!!!!!!!!!!!"
 @{b}                       -------------------------------
                          W  E  L  C  O  M  E    T  O
                        -------------------------------

         JØØØØØØØØØØØØØØØØØØØØ   ÆØØØØØØ#       ØØØØ#_    _ØØØØØ
         JØØØØØØØØØØØØØØØØØØØ"  JØØ@¶¶ØØØL      ØØØØØ#_   ÆØØØØØ
          ¯""°¶@#ÑØØØÑ@@@PP°´   ØØØF  ØØØ#      ØØØØØØ#_ ÆØØØØØØ
                  ØØØ_         áØØØ   0ØØØL     ØØØØØ#Ø#wØØØØØØØ
                  ØØØQ         ØØØØµµµÆØØØQ     ØØØØØ ¶ØØØPJØØØØ
                 JØØØ#        ÆØØØØØØØØØØØØ¸    ØØØØØ  °ØK JØØØØ
                 ÆØØØØL      JØØØØF   JØØØØQ    ØØØØØ      JØØØØ
                 ØØØØØ#      ÆØØØØÞ    ØØØØØ_   ØØØØØ      JØØØØ
                 ØØØØØØL    JØØØØØ     0ØØØØQ   ØØØØØ      JØØØØ


                          ØØØØ   ØØØ@  @     ¤Ñ@@@@##Mm__
                         ÆØØØØ  ÆØØ#                 ¬¶##ç
                        ÆØØØØØ JØØØ                    ÆØP
                       ÆØØÑØØØ ØØØ´          µµµµµµµµæØ#°
                      JØØ# ØØØÆØØ"           °¶¶¶¶¶¶Ñ#æw_
                     JØØØ  ØØØØØF                     °Ñ#µ
                     ØØØF  ØØØØF                       _ØØ
                    ÑÑÑ#   ÑÑÑP          ¢ØæmµµµµµµææÆØ#M¯

          |----------------------------------------------------------|
          | T  O  T  A  L    A  M  I  G  A    M  A  G  A  Z  I  N  E |
          |----------------------------------------------------------|
@{ub}
                         @{" ---INTRODUZIONE MUSICALE--- " system "data/play16 >NIL: data/intro.8svx"}
                               @{" ---COPERTINA--- " system "data/visage >NIL: data/copertina.jpg"}

Siamo ancora qui!!! Un nuovo numero di TAM è qui per voi, cari fratelli e
sorelle amighisti, per tenere alto il nome di AMIGA e darvi un pò di sana
informazione, ovviamente amighista!!! Quindi bando alle ciampole!!!
@{u}                                                                                 @{uu}

@{" EDITORIALE " link editoriale}
Una piccola introduzione...

@{" CONTRIBUTI " link contributi}
Perchè e come contribuire a TAM!!!

@{" DISCLAIMER " link disclaimer}
Non si può mai sapere, a questo mondo...

@{" RINGRAZIAMENTI " link grazie}
I ringraziamenti di rito ai nostri sostenitori!!!

@{" NOTIZIE DAL MONDO AMIGA " link notizie}
Notizie buone e cattive da tutti i pianeti dell'universo AMIGA!!!

@{" IL MEGLIO DEI PD GAMES " link pd_gamez}
Proseguiamo con la rassegna dei migliori giochi PD e Shareware!!!

@{" CORSO DI COMPUTER GRAFICA " link corso_cg}
Panta ci introduce alle animazioni con Imagine!!!

@{" INTRODUZIONE ALL'ASSEMBLER " link corsoasm}
Deep Red ci illustra i fondamenti della programmazione Assembler!!!

@{" INTRODUZIONE AL C " link corsoc}
Alla grande! Deep Red non si ferma e ci introduce anche al mondo del C!!!

@{" VIVERE E MORIRE DI SHELL " link shell_e_basta}
Come aprire una shell e dimenticarsi di tutto il resto!!!

@{" INSTALLAZIONE DI UN CD-ROM SCSI SU A1200 " link inst_ciddo}
Una piccola guida tecnica per chi ancora non ha un ciddo-rom!!!

@{" QUALCUNO VUOLE UN CDID??? " link cdidz}
Un piccolo regalino per chi fa collezione di CDID!!!

@{" WINDOWS '98 SULL'ENTERPRISE " link startrek}
La tragica installazione, o meglio infiltrazione, di Win98 sull'Enterprise!!!

@{" MILLE MODI PER DIRE WINDOWS " link 1000modi}
Noi sì che amiamo il S.O. di casa Micro$oft: gli diamo anche molti soprannomi!!!

@{" GLI SCRIPT JAVA ANTI-MICRO$OFT " link antims}
Deep Red non ha nessuna pietà: guardate un pò come si combatte la M$!!!

@{" LA MALEDIZIONE DEI CLUSTER " link 16k}
E tanto per infierire ancora un pò...

@{" L'ANGOLO DELLA RISATA " link risate}
Per farsi due sane sghignazzate in faccia a Bill Gates!!!

@{" IN CONCLUSIONE... " link concludendo}
Due parole per concludere...

                               @{" ---RICERCA--- " system "data/lsags tam3.guide"}
@{u}                                                                                 @{uu}

@{b}
---------------------------------------------------------------------------------
-------------------------T.A.M. - Total Amiga Magazine---------------------------
------------------------------Copyright ©1996-98---------------------------------
---------------------Claudio Vimercati & Pierluigi Pesenti-----------------------
---------------------------------------------------------------------------------
@{ub}
@endnode

@node editoriale "EDITORIALE DI TAM NUMERO 3 - LO SPETTACOLO CONTINUA!!!"

@{b} ----------------------------------EDITORIALE-----------------------------------@{ub}

Cari brothers & sisters, benvenuti al nuovo numero di TAM: la nostra grande
avventura amighista continua!!!

La vita scorre tranquilla (o quasi)...ormai il PowerPC è una realtà e tante
valide possibilità sono all'orizzonte: quindi i "tempi duri" dovrebbero
finalmente essere passati una volta per tutte: resta solo da vedere se Amiga
saprà reimporsi sul mercato mondiale come una volta, oppure rimarrà un computer
di nicchia per gente seria e non per ragazzini che corrono dietro all'ultima
versione di Fifa '9x (presto '0x): la seconda soluzione mi sembra la più
probabile, anche se in fondo la prima sarebbe la più gratificante: una grande
riscossa dopo anni di dura lotta!!! Comunque sia noi continueremo a dare il
nostro contributo, fino a quando ci sarà possibile!!!

Ora, come Panta ha fatto nell'editoriale della TAM 2, anche io vorrei chiarire
bene la mia posizione per quanto riguarda la storica diatriba Amiga-PC, se
ancora non fosse abbastanza chiaro: io sono un vero amighista ed un autentico
anti-PCista, non mi vergogno ad ammetterlo e sono fiero di esserlo: certo, so
che molti non condividono la mia posizione, considerandola eccessiva ed
estremista, e magari anche stupida, ma in fondo io non vado in giro insultando
gli utenti di PC per la strada nè tantomeno brucio PC in sacrificio al mio Amy:
semplicemente nutro un "odio" recondito per una tecnologia che, pur essendo
nettamente inferiore a quella di Amiga, per causa non sua ma per causa dell'
incompetenza di quelli che hanno gestito Amiga dal punto di vista economico e di
mercato (a differenza dei geni che l'hanno inventata), ha avuto comodamente il
tempo di evolversi e di conquistare immeritatamente il monopolio informatico
mondiale: già questo mi fa incavolare, e se poi aggiungiamo il razzismo
informatico che si è creato nei confronti di Amiga (già discusso milioni di
volte), considerato da anni un computer morto quando ancora vivo e vegeto (al
massimo un pò agonizzante, in certi periodi), è chiaro che la rabbia sale alle
stelle, e se non posso capovolgere l'andamento della storia passata e dei fatti
al presente, almeno mi sfogo come posso, esprimendo tutto il mio rancore in modo
da difendere anche la dignità di Amiga, calpestata troppe volte da gente che se
ne frega delle passioni informatiche e dei sistemi alternativi e vede solo PC,
Windows, Microsoft ed Intel: in fondo le critiche mosse sono spesso solo
satiriche, pur esprimendo la realtà dei fatti: è come per chi fa satira
politica: scherzano e fanno umorismo sulla gente al potere, basandosi sui fatti
e sulle situazioni reali, ma non per capovolgere i governi, semplicemente per
esprimere la loro disapprovazione nei riguardi di tali persone e delle loro
azioni: lo stesso è la critica verso i PC: non ho intenzione di invertire la
situazione del mondo informatico, ma nel mio piccolo provo grande soddisfazione
nell'esprimere la mia disapprovazione verso chi regna sui troni di un monopolio
creato dagli errori altrui, senza alcun merito, e continua a infierire sui
deboli, sfruttando allo stesso tempo l'"ignoranza" delle persone, che si trovano
costrette a seguire la massa, senza la possibilità di conoscere alternative: non
venitemi a dire che la Micro$oft non è un esempio lampante di tutto ciò... e con
questo ho detto tutto: mi dispiace che qualcuno mi biasimerà per questo, ma la
mia posizione è questa e resterà tale finchè vivrà Amiga!!!

Detto questo, vi auguro @{b}BUONA LETTURA@{ub}!!!!!

                                                            @{b}Kle@{ub}

@endnode

@node grazie "GRAZIE A TUTTI, FRATELLI AMIGHISTI!!!!!!!!!!!!!!!!"

@{b} --------------------------CHI DOBBIAMO RINGRAZIARE?----------------------------@{ub}

-Tutti coloro che leggeranno TAM 3
-Tutti coloro che hanno letto i numeri precedenti di TAM
-Enigma Amiga e The Games Machine
-Gateway 2000, Amiga Int. e Amiga Inc. (e anche Inp., Ing., Ins. e Inf.!!!)
-Maurizio "Deep Red" per i suoi notevoli contributi (grandioso!!!)
-Alvaro "Alvi" Vezzoni per la sua lettera
-Magnus Olmgren per Visage
-LouiSe per Amigaguide Searcher
-Marco Negri e Paul Schifferer per Blacks Editor
-Massimo La Spina per il suo contributo al corso di computer grafica

E grazie a tutti i fratelli e le sorelle amighisti/e del mondo!!!

Vorremmo dare una "nota di merito" a Deep Red, che come avrete notato si è
veramente dato da fare!!! (Praticamente mezza TAM l'ha fatta lui!!!) @{b}GRAZIE
FRATELLO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!@{ub}

@endnode

@node contributi "A.A.A. COLLABORATORI CERCASI"

@{b} -----------------------------COLLABORARE CON NOI-------------------------------

PERCHE'?@{ub}
Perchè abbiamo intenzioni serie e vogliamo creare qualcosa di valido che possa
uscire piuttosto regolarmente. Per questo ci servono volenterosi collaboratori!
@{b}E QUINDI?@{ub}
E quindi se siete amighisti creativi che vorrebbero far parte del TAM TEAM, per
scrivere articoli, recensioni e simili o magari contribuire anche solo con un'
immagine, un modulo musicale o una barzelletta per "l'angolo della risata", e
comunque per sostenere l'attività amighista italiana, dovete semplicemente
contattarci!!!
@{b}COME?@{ub}
Per posta:

        @{b}Kle:@{ub}

         Claudio Vimercati
         Via Arnichi 17
         24041 Brembate (BG)

        @{b}Panta:@{ub}

         Pierluigi Pesenti
         Via Arnichi 6
         24041 Brembate (BG)

o per telefono:

        @{b}Kle:@{ub}
         035/802977 (chiedete di Claudio)
        @{b}Panta:@{ub}
         035/4874041 (chiedete di Pierluigi o Gigi, ma lasciate stare la Cremeria!)

Niente Internet per ora, purtroppo...

Se voleste anche solo mandarci una lettera per comunicarci che avete letto TAM e
vi è piaciuta (si spera) e magari per fare conoscenza, oppure per darci consigli
o critiche, vi aspettiamo sempre a braccia aperte!!!

@endnode

@node disclaimer "DUE NOTE LEGALI...(!!!)"

@{b} ----------------------------------DISCLAIMER-----------------------------------@{ub}

Come sempre, è importante ricordare che...

Il software PD (Pubblico Dominio), Freeware e Shareware non ha nessun tipo di
garanzia, e anche noi, distribuendo e utilizzando per la diskmag alcuni
programmi di questo genere, non possiamo dare @{b}nessuna@{ub} garanzia di funzionamento
nè assumerci @{b}nessuna@{ub} responsabilità per danni causati magari dai progs di "terze
parti": non ci è stato possibile testare il funzionamento del tutto su macchine
diverse dall' A1200, ma possiamo auspicare che sia il minimo necessario perchè
tutto vada per il verso giusto!!!!

E' inoltre importante ricordare che tutti i programmi che distribuiamo con TAM
sono sempre @{b}FREEWARE@{ub}, di @{b}PUBBLICO DOMINIO@{ub} o @{b}SHAREWARE NON REGISTRATI@{ub} e quindi
@{b}LIBERAMENTE DISTRIBUIBILI@{ub}!!!!

Infine bisogna ricordare che tutto il materiale distribuito con TAM e TAM stessa
sono @{b}LIBERAMENTE DISTRIBUIBILI@{ub} ma @{b}NON LIBERAMENTE MODIFICABILI O RIUTILIZZABILI
PER ALTRI SCOPI@{ub}!!!!!!!

@{b}GRAZIE!!!!!@{ub}
@{b}
---------------------------------------------------------------------------------
-------------------------T.A.M. - Total Amiga Magazine---------------------------
------------------------------Copyright ©1996-98---------------------------------
---------------------Claudio Vimercati & Pierluigi Pesenti-----------------------
---------------------------------------------------------------------------------
@{ub}
@{b}Copyright del software di terze parti:@{ub}

-@{b}tower.library, jpeg.codec, picture.codec@{ub} sono Copyright ©1994 di Christopher
Feck, TowerSystems.
-@{b}Visage@{ub} è Copyright ©1995 di Magnus Holmgren.
-@{b}Play16@{ub} è Copyright ©1996 di Thomas Wenzel

@endnode

@node notizie "TAM - NOTIZIE BELLE & BRUTTE"

@{b} ----------------------L'ANGOLO DELLE TOTAL AMIGA NOTIZIE-----------------------@{ub}


   @{b}-----LE BUONE NOTIZIE-----@{ub}

   @{" Team 17 " link team17}        I Team 17?! Sarà vero?
   @{" Photogenics " link photocoso}    Ritorna Photogenics!!!
   @{" Bugs " link bugs}           Incredibile! Ma ci vuole una 3DFX???
   @{" Virus Checker " link virus_checker}  E' tornato!!!
   @{" Windows 98 " link uin98}     Sempre più innovativo...
   @{" Enforce " link enforce}        Il primo concorrente di Quake!!!
   @{" OloFight " link olocoso}       Ora si muove!!!
   @{" The Golem " link golem}      Sono stanco di aspettare!!!
   @{" Cloanto news " link cloanto}   Novità dalla soft house italiana!!!

   @{b}----LE CATTIVE NOTIZIE----@{ub}

   @{" Assurdità " link assurdo}       Petro e soci sono impazziti?
   @{" Silicon-PC " link siliconpc}      Cosa c'entra la Silicon coi PC?!?!?!
   @{" Gente che va... " link se_ne_vanno} C'è chi ci lascia, purtroppo...
   @{" Aiuto!!! " link elp}        I NEED HELP!!!

@endnode

@node team17 "RITORNANO I TEAM 17...DAVVERO?!?!?!?!"

@{b} ----------------------IL (POSSIBILE) RITORNO DEI TEAM 17-----------------------@{ub}

La notizia è una "voce di corridoio" che mi è "trapelata" dalle pagine di TGM,
quindi è probabile che molti di voi la sapranno già: certo non è una
stupidaggine: sembra infatti che i famosi @{b}Team 17@{ub}, una delle più grandi software
house ludiche dei passati anni amighisti, che dopo Worms The Director's Cut ha
abbandonato definitivamente l'Amiga (traditori!), anche se sembra intenzionata a
ritornare sui suoi passi!!! Questa è la notizia bomba: pare che Martin Brown e
soci siano infatti disposti a tornare a produrre giochi per Amiga, ma soltanto
per @{b}PowerAmiga@{ub}!!! Vale a dire solo per gli Amiga dotati di scheda PowerUp o dei
prossimi cloni: questa scelta sembra abbastanza ragionevole: dopotutto molti
produttori di giochi ignorano Amiga solo perchè credono (spesso erroneamente)
che non abbia l'hardware adatto per i giochi dell'ultima generazione: certamente
questo è in parte vero, specie se si vogliono convertire giochi per PC che
richiedono un Pentium 200 con scheda accelleratrice 3D: il PowerPC cambia, in
parte, questo discorso, ed è sicuramente un motivo in più per le grandi software
house a considerare l'Amy. Beh, speriamo non sia solo un fuoco di paglia, perchè
se tutto ciò è vero la cosa si fà molto ma molto ma mooolto interessante!!!

E non è finita!!! Forse anche i @{b}Bitmap Brothers@{ub}...beh, sì, in effetti è
ufficiale che l'ultimo gioco per PC dei mitici BB, @{b}"Z"@{ub}, sarà convertito per Amy
indovinate da chi? Ma dai @{b}ClickBOOM@{ub}, ovviamente!!!

                                                            @{b}Kle@{ub}

@endnode

@node photocoso "PHOTOGENICS NON E' MORTO!!!!!"

@{b} --------------------------IL RITORNO DI PHOTOGENICS----------------------------@{ub}

Penso che tutti sappiate cos'è Photogenics: un eccellente programma di
fotoritocco uscito circa quattro anni fa per mano dell'ormai defunta Almathera
(famosa anche per le sue raccolte di software PD su CD), e precisamente per mano
di Paul Nolan, autore del sistema Siamese: subito questo programma si distinse
per la sua ottima fattura, in un certo senso innovativa, per la sua velocità e
per la facilità d'uso di molto superiori ad ImageFX: purtroppo la suddetta
Almathera finì male durante il periodo "Viscorpese" e così si persero le tracce
di Photogenics: ora sembra che qualcuno (ve lo confesso: non so chi!) abbia
rimesso le mani sul progetto e quindi "presto" uscirà @{b}PhotogenicsNG@{ub}, con nuove
funzionalità e tutto quello che ci si può aspettare da una nuova versione: per
ora non so nulla di più: attendiamo novità più chiare, anche se la notizia
sembra ben fondata...vedremo!!! La cosa comunque non può che far piacere ai
molti utenti che hanno apprezzato questo programma in passato e se lo sono visti
"sparire" sotto il naso!!!

                                                            @{b}Kle@{ub}

@endnode

@node pd_gamez "ER MEJO DEI PD GAMES, AOOOOOOOO, GAGLIARDO!!!!!!"

@{b} ----------------------------IL MEGLIO DEI PD GAMES-----------------------------
                            ---------BY KLE---------@{ub}

Nelle puntate precedenti abbiamo visto @{b}Deluxe Galaga, Scorched Tanks, Super Foul
Eggs, Sneech, Spacetaxi, Master Blaster, Knockout, Peg It, Wormtris@{ub} e@{b} Alien Fish
Finger@{ub}, ora proseguiamo con i migliori giochi PD e shareware per il nostro caro
Amy:

@{b}SPEEDBREAK@{ub}: questo simpatico giochillo, creato da Renaud Mearini e Cedric
Andreu, è uno strano shoot'em up dove due giocatori (anche contro il computer)
controllano due navicelle all'interno di un'arena divisa verticalmente in due e
piena di blocchi da eliminare a fucilate: per prima cosa i due giocatori devono
appunto eliminare tutti i blocchi presenti nella loro area, dopodichè la sbarra
di separazione si abbassa e i due si devono "beccare" a vicenda: il primo che
viene colpito perde! Semplice, no? In effetti la il gioco è tutto qui, anche se
in effetti risulta molto divertente, ci sono molti livelli, varie modalità di
gioco e diverse navicelle da scegliere (con caratteristiche diverse) e anche una
completissima classifica auto-aggiornante!!! Il tutto condito da alcuni tocchi
grafici e sonori molto simpatici, che lo rendono acora più appetibile: very good
quindi, un altro bel giochino per divertirsi con un amico, ma anche da soli!!!

@{b}RUSHHOUR@{ub}: dallo stesso autore di SpaceTaxi, Andreas Spreen, un altro gioco
"portato" direttamente (e fedelmente) dal Commodore64: l'idea è molto originale:
impersonando un "vigile urbano virtuale", abbiamo di fronte una serie di strade
incrociate percorse da un sacco di macchinine: ogni incrocio ha un semaforo che
bisogna "switchare" in modo da rendere fluido il traffico: per superare un
livello è necessario che un certo numero di macchinine arrivi a destinazione,
uscendo dallo schermo: il gioco finisce se si creano code troppo lunghe di
macchine ferme fuori dall'area visibile: all'inizio può sembrare stupido, ma
quando cominciano a esserci una decina di incroci, è chiaro che le cose si
complicano un poco!!! Decisamente carino e ben programmato, per non parlare
della possibilità di giocare in 2 o anche in 3 contemporaneamente!!! E' anche
presente un editor di levelli, quindi cosa volete di più???

@{b}KANGY@{ub}: realizzato dall'italianissimo Luca Carminati, questo gioco si è veramente
imposto e infatti è stato inserito sul coverdisk di CU Amiga di alcuni mesi
fa!!! Quindi complimenti doppi a Luca!!! Il gioco è un platform basato su
livelli a schermo fisso, dove il protagonista, il tenero cangurino Kangy, deve
recuperare una serie di frutti sparsi per le piattaforme e depositarli in
apposite casse, anche loro posizionate in punti "strategici": il tutto evitando
i simpatici (ma allo stesso tempo odiosi) animaletti che @{"zonzano" link help 7} per l'area di
gioco con l'intento di farci male (?!) e che a nostra volta possiamo malmenare
(viulenza!!!) usando particolare cautela per il fatto che bisogna "prenderli al
volo": giocando capirete!!! Oltre a ciò bisogna calibrare bene i salti, perchè
Kangy non vola e facendo salti eccessivamente alti si potrebbe schiantare in
fondo al burrone!!! A parte la violenza inaudita (stò scherzando!!!) questo
gioco si fa notare subito per la sua grafica curatissima e veramente carina,
oltre ad una realizzazione quasi impeccabile in termini di programmazione e una
buona giocabilità: l'unica nota dolente è la difficoltà, che in alcuni casi
rende il gioco un pò frustrante, anche se in effetti sono presenti diversi
livelli di difficoltà, quindi non ci sono grandi problemi. Molto bene!!!

@{b}SUPER OBLITERATION@{ub}: questo gioco è un pò vecchietto (1993) ma fà sempre una
bella figura e merita di far parte della vostra collezione: creato da David
Papworth, si tratta del perfetto incrocio fra Pang e Turrican!!! Infatti, nei
panni di un robot quasi identico al caro Turry, dovrete ripulire ben 30 livelli
di un sacco di minacciosi asteroidi svolazzarti, che una volta colpiti si
spezzano in parti più piccole, fino a riempire lo schermo di sassolini
fluttuanti!!! Semplice e divertente, oltre che realizzato molto bene: la grafica
è ottima e piacevole, il sonoro fa il suo dovere e la giocabilità e davvero
molto alta, anche per la presenza di un modo a due giocatori insolito ma
efficace: un giocatore muove il robot, l'altro muove l'arma! Io e Panta ci
abbiamo perso diverse ore!!! Notevole anche la varietà dei livelli e delle armi
utilizzabili, che rendono questo gioco davvero meritevole di essere posseduto e
giocato fino alla fine!!! Peccato che non si possa @{"quittare" link help 13} e si è costretti a
resettare per tornare al Workbench: per questa volta passi...

@{b}TUBES@{ub}: basato su un concept vecchio e abusatissimo, questo gioco, creato da
Chris Hodges, è l'ennesima variante del "gioco dei tubi", dove, in un certo
tempo, bisogna formare una tubatura, la più lunga possibile, utilizzando un
numero prefissato di "pezzi" di vario genere: alla fine del tempo o dei pezzi
disponibili l'acqua comincerà a correre lungo il tubo, e solo se percorrerà un
percorso sufficientemente lungo si potrà passare al livello successivo: il
concetto di base è tutto qui: come ho già detto non è originalissimo, ma ho
trovato questo Tubes davvero ben realizzato e divertente: infatti ci sono
diverse particolarità che lo rendono comunque interessante, come i sottogiochi e
la possibilità, alla fine di un livello, di eliminare i pezzi inutilizzati
tramite un bulldozer (guadagnando punti): quindi si lascia giocare in modo
piacevole e può garantire un bel pò di divertimento e di relax. La grafica e il
sonoro sono piacevoli e la programmazione e molto ben fatta, pur essendo in
Amos: è anche possibile cambiare il tipo di liquido (acqua, olio, latte...), che
non serve a niente, però è una cosa in più!!! ;-)

Bene, anche questa volta ho finito: alla prossima e buon gioco!!!

                                                            @{b}Kle@{ub}
@endnode

@node corsoasm "LA PROGRAMMAZIONE 'INTIMA' DELL'AMIGA"

@{b} --------------------------INTRODUZIONE ALL'ASSEMBLER---------------------------
                         ---------BY DEEP RED---------@{ub}

/* ======================================================== *
 * IZIO    ___    PICCOLA INTRODUZIONE ALL'ASSEMBLER        *
 * SOFT   / //                                              *
 * ___   / //        ...auguri...                           *
 * \ \\ / //                                                *
 *  \ \/ //                                                 *
 *   \__//                        (c)1998 Maurizio DEEP RED *
 *                           SAS/C v6.51 Development System *
 * -------------------------------------------------------- *
 * DATA: Domenica 17-Mag-98 16:45:01  VER ...               *
 * S.O. / HW .....                    REV ...               *
 * NOTE:                                                    *
 * ======================================================== */


Provo a spiegarvi sinteticamente le basi del linguaggio assembler. Dico 'le
basi' in quanto una spiegazione non approfondita ma solo dettagliata della
programmazione Amiga è impossibile senza disporre dei manuali ROM Kernel, che
spiegano come programmare sfruttando le routine contenute nel Kickstart.
Infatti, il più frequente uso che si fa del linguaggio Assembler non è
propriamente la programmazione in ambiente AmigaDOS, che risulterebbe
estremamente complessa e per la quale si preferisce il C, ma la programmazione
di giochi, o demo. Il motivo di questa differenziazione è il fatto che i
programmi AmigaDOS richiedono troppi accorgimenti particolari (condivisione di
parti di memoria, rispetto del MultiTasking, ecc.) al contrario dei giochi e dei
demo che letteralmente si 'impossessano' della macchina, disabilitando gli
interrupt e 'bypassando' il Kickstart, per avere il processore tutto per sè.
Questo semplifica di molto la scrittura del demo in assembler. Infatti in questo
linguaggio è possibile intervenire direttamente sui registri hardware del
processore e dei coprocessori. In C ed in altri linguaggi queste manipolzioni
dei registri vengono eseguite a basso livello dal compilatore o dalle routine
del Kickstart, a scapito ovviamente della velocità. Per questo in Assembler si
preferisce escludere le routine in ROM (efficacissime, sicure, non vanno mai in
Guru ma lente) a favore di una programmazione meno corretta, ma molto più
veloce.
E' questo il motivo che fa sì che i demo o i giochi spesso si inchiodino senza
motivo, o con alcuni processori vanno in guru (ne so qualcosa con lo 040),
andando in conflitto con le cache o chissà con quale altra cosa.
La programmazione di questi demo è spettacolare, ma profondmente scorretta
verso il 'povero' AmigaDOS che viene completamente 'immobilizzato' senza poter
impedire che i registri del computer vengano illegalmente manipolati.
Questo per quanto riguarda i giochi o i demo che sono autobootabili da disco.
Un discorso simile vale per i giochi o i demo altrettanto spettacolari
(vedi PygmyProjects) che partono tranquillamente da AmigaDOS e poi escono senza
causare Guru. Questi programmi salvano alla partenza tutti i registri del
processore e le cache in uno stack, per poi ripristinarli all'uscita del demo;
in questo modo l'AmigaDOS è stato 'congelato' per il tempo in cui il demo
girava.

In sintesi, quando uno programma in Assembler, può intervenire come più gli
piace sul computer agendo sui tanti registri che regolano le funzioni Hardware.
Questi registri li vedremo più avanti.

Il più comune assemblatore per questo tipo di programmi è ovviamente il SEKA,
il quale non ha alcuna funzione di Include, come in C, quindi i file di
definizione delle routine AmigaDOS non possono venite caricati. Se uno vuole
proprio programmare l'AmigaDos, deve ricorrere all'accesso del Kickstart
tramite indirizzi, cosa alqunto allucinante.

C'est à dire (espressione dialettale propria del Guatemala che significa
'C'è da dire') che se si facesse esattamente come spiegato prima, il programma
funzionerebbe praticamente solo sul proprio computer, perchè basterebbe una
diversa revisione del Kickstart o ad esempio un drive esterno per rendere
incompatibile il demo su altri computer. Per questo si cerca di rendere i
programmi più vicini all'AmigaDOS utilizzando, quando non viene compromessa la
velocità o qulache parte del codice, routine di sistema. Questo avviene
comunque poche volte, generalmente all'inizio del programma per ottenere
l'accesso alle librerie in ROM.


Fine dell'introduzione. Vediamo ora il linguaggio macchina proprio del 68000

Allora, come già saprete, il 68000 funziona a 16/32 bit, cioè internamente
funziona completamente a 32 bit, infatti i registri dati sono a 32 bit, ma
indirizza la memoria a 16 bit, cioè accede ad essa 2 Byte per volta e non può
accedere a più di 16 Mb di RAM. Il 68000 ha 18 registri. I registri sono memorie
interne al processore, lunghi 32bit. Il processore accede in modo istantaneo ai
registri, perchè sono interni ad esso e può manipolarli con una serie di
istruzioni in molti modi. Queste istruzioni sono i comandi, che gli permettono
di interagire anche con indirizzi e locazioni di memoria.

I registri sono divisi in due serie: 8 registri dati chiamati D0 - D7 che
contengono semplicemente numeri, e 8 registri di indirizzi A0 - A7. Il registro
A7 ha la funzione di stack. Vi sono poi altri due registri: PC contiene un
numero che indica l'indirizzo dell'istruzione correntemente elaborata;
SR è il registro di stato: ogni suo bit indica una condizione particolare del
processore (se è in guru, ecc).

D0                      A0                      PC   Program Counter
D1                      A1                      SR   Status Register
D2    Registri          A2      Registri
D3                      A3
D4      Dati            A4      Indirizzi
D5                      A5
D6                      A6
D7                      A7

Quando si accede ad un registro dati, si pone un valore al suo interno, come
una semplice variabile. I registri di indirizzo, possono solo contenere
indirizzi di memoria. Vengono considerati non per il valore numerico dell'
indirizzo che contengono, ma per il valore numerico della locazione di memoria a
cui punta l'indirizzo. (Chiaro, no?... E' come il simbolo * davanti ad una
variabile in C... Che casino)

Tipi di dati: a differenza del C i tipi sono solo 4, e dipendono dalla
lunghezza in bit del dato.

BIT     2^1 - 1   Val. Max. = 1
NIBBLE  2^4 - 1   Val. Max. = 15 (non usato negli indirizzamenti)
BYTE    2^8 - 1   Val. Max. = 255
WORD    2^16 - 1  Val. Max. = 65535
LONG    2^32 - 1  Val. Max. = 4294967296

Come in C gli identificatori sono messi davanti al numero: il più usato è il
simbolo $, che indica un numero esadecimale, ed è usato per indicare molto
spesso locazioni di memoria. Un altro indentificatore è #, che indica che il
valore che segue è un valore numerico e non un indirizzo.
Vediamo allora la prima istruzione, la più importante, che permette di
scrivere un valore numerico in un registro o in un indirizzo di memoria.
Questa istruzione è MOVE. L'istruzione move, come in moltissimi altri comandi
Assembler,  può essere seguita da un puntino ed una lettera B, W oppure L.
Serve per specificare se l'operazione coinvolge un Byte, una Word oppure una
Long.
Intanto, è un occasione per vedere i vari modi di indirizzamento:

MOVE.L    #$10000, D0   Muove il valore esadecimale 10000 nel registro D0

MOVE.L    $10000,D0     Muove il 4 Bytes (una long) a partire dall'indirizzo
                        $10000 nel registro D0

MOVE.L    #$20000,$1000 Muove il valore esadecimale 20000 all'indirizzo di
                        memoria $1000.

MOVE.L  A0,D0           Muove l'indirizzo contenuto in A0 nel registro D0.

MOVE.L  (A0),D0         Questo si chiama ARI (indirizzamento indiretto): cioè
                        la LONG il cui indirizzo
                        si trova in A0 viene copiata in D0

MOVE.L  (A0)+,D0        Come il comando precedente, ma viene fatto un
                        postincremento: dopo aver compiuto la funzione MOVE,
                        il registro A0 viene incrementato di 1 LONG in modo
                        da puntare alla long successiva.

MOVE.L    (A0)+,(A1)+   Questo comando è molto importante perchè copia la
                        memoria: infatti, entrambi i registri di origine e di
                        destinazione subiscono un postincremento, quindi se
                        ad esempio il comando viene ripetuto per 1024 volte,
                        il risultto sarà la copiatura di 1 K di memoria a
                        partire dall'indirizzo contenuto in A0 all'
                        indirizzo contenuto in A1.

MOVE.L  #0,(A0)+        Altra applicazione del postincremento: all'indirizzo
                        contenuto in A0 viene messo il valore decimale 0
                        (vengono azzerati 32 bit). Poi il registro A0 viene
                        incrementato di una LONG (di 4 Bytes) e punta alla
                        LONG successiva. Se si ripete il comando, verrà
                        azzerata la LONG successiva. Quindi, si può azzerare
                        una zona di memoria semplicemente inserendo in A0 il
                        suo indirizzo di partenza e ripetendo questo comando
                        un numero di volte pari al numero di LONG che
                        costituiscono la lunghezza del blocco di memoria.

MOVE.L -100(A0),D0      Altro indirizzamento fondamentale: lo scostamento.
                        In D0 viene messo il valore contenuto all'indirizzo
                        dato dalla sottrazione di 100 LONG all'indirizzo
                        contenuto in A0. Come, impropriamente:
                        MOVE.L (A0 - 100),D0.

MOVE.L 123(PC),A1       Il PC contiene l'indirizzo di memoria dell'istruzione
                        correntemente elaborata. Quindi l'istruzione mette
                        in A1 l'indirizzo PC addizionato di 123.
                        Non è molto usato, ma serve principalmente per
                        'fare tornare i conti' all'assemblatore in caso che
                        si scriva un programma AmigaDOS rilocabile da parte
                        del Sistema Operativo in base alle esigenze del
                        MultiTasking.
                        Si usa poco nel caso di programmazione di demo, in
                        quanto si assembla il sorgente ad un ben preciso
                        indirizzo di memoria, senza attendere 'il permesso'
                        dell'AmigaDOS.

MOVEM.L A0-A6/D0-D7,-(SP) Questo comando apparentemente strano, è
                          fondamentale alla partenza di un demo: esso infatti
                          'salva' nello Stack tutti i registri del
                          processore, in modo che all'uscita del demo possano
                          essere ripristinati evitando un bel Guru. Il - davanti
                          al registro SP, come visto prima, decrementa il
                          puntatore allo stack prima di mettere un nuovo registro
                          in esso: infatti, lo stack ha una struttura Last In
                          First Out (il primo ad essere immesso è l'ultimo ad
                          essere ripreso, come il caricatore di una pistola
                          automatica)

MOVEM.L (SP)+,D0-D7/A0-A6  Il comando complementare al precedente: preleva
                           dallo stack i registri 'salvati' e li ripristina
                           correttamente.

MOVEQ     #0,D0         Questo è un move particolare: q sta per 'quick'=veloce.
                        Il comando opera soltanto su bytes, però è molto più
                        veloce del move.b. E' molto usato nei loop per
                        guadagnare velocità.

Altro comando importante è LEA (Load Effective Address) e può avere come
secondo argomento solo un registro di indirizzi: mette in questo registro l'
indirizzo di qualcosa o un indirizzo a piacere:

LEA  $70000,A0   Mette il valore $70000 nel registro A0. Il registro A0
                 punterà alla locazione $70000 in memoria (Equivale a
                 MOVE.L #$70000,A0)
LEA  ZIOPINO,A0  Mette in A0 l'indirizzo della parte del codice sorgente
                 indicato da una label chimata ZIOPINO.

Nel programma vi possono essere delle Label, come in Basic o in C, che
identificano una parte di programma. Questi nomi devono finire con due punti.
All'interno del programma, usando questi nomi è come usare l'indirizzo di quel
punto di programma. Infatti il caso visto prima, l'istruzione LEA che come
primo operando accetta un indirizzo, può accettare anche un nome di label.
Vi sono istruzioni che consentono di modificare il flusso del programma:

BSR  ZIOPINO   Salta alla subroutine ZIOPINO poi ritorna quando trova
               un istruzione RTS
JSR  $70000    Salta all'indirizzo in memoria $70000 e prosegue ad
               eseguire il codice lì assemblato.

In assembler vi sono alcuni salti condizionali alle label: in caso che si
verifichi una condizione, il salto a quella subroutine avviene.
Esiste il comando CMP .L .B .W  che confronta due operatori.
L'istruzione seguente è quella che effettua il salto ad una determinata
condizione: Bcc, in cui cc rappresenta la condizione che ci interessa:

principali tipi di cc:
     EQ   uguale a  =         ->   BEQ
     GE             >=        ->   BGE
     GT             >         ->   BGT
     LE             <=        ->   BLE
     LT             <         ->   BLT
     NE             != (diverso)   ->   BNE

Ve ne sono altri, meno comunemente usati.
Quindi ad esempio, il comando di un salto condizionale avviene in questo modo,
come nell'esempio qui sotto che azzera la memoria CHIP dall'indirizzo $50000
all'indirizzo $51000, utilizzando un loop:

     lea.l     $50000,a0      carica in A0 l'indirizzo di partenza
Cancella:
     clr  (a0)+               pone 0 nell'indirizzo puntato da A0
                              e poi lo incrementa
     cmp.l     #$51000,a0     compara il valore $50000 con il registro A0
     bne  Cancella            se A0 non è uguale a $50000 torna a Cancella:
                              e ripete daccapo.
                              (BNE = Branch if Not Equal, salta se diverso)

Oltre alla comparazione fra due operandi, i salti di tipo Bcc sono condizionati
anche dalla verifica dei bit di una locazione di memoria: l'istruzione in tal
caso anzichè essere CMP è BTST, che testa un bit qualunque di un numero.
Ad esempio il seguente esempio attende la pressione di untasto del mouse.
Dal manule ROM Kernel dell'Hardware si legge che il bit numero 6 della
locazione di memoria &bfe001 rappresenta lo stato del bottone sinistro del
mouse. Se questo bottone viene premuto, il bit in questione viene portato a 1.
L'istruzione BTST controlla se questo avviene:

Aspetta:btst #6,$bfe001      legge in bit no. 6. se è = a 1
        bne  Aspetta         Se non è uguale,torna ad Aspetta: se no prosegui
                             (BNE = Branch if Not Equal, salta se diverso)

Le funzioni matematiche dell'Assembler sono solo le operazioni principali:
Addizione Sottrazione Moltiplicazione e Divisione.

ADD.L     D0,D1          Addizione:                         D1 = D1 + D0
ADDA.L    A0,A1          Addizione di indirizzi:            A1 = A1 + A0
ADDQ      #$4,D0         Addizione di una costante bytes:   D0 = D0 + 4
ADDI.L    #$45000,D0     Addizione di una costante          D0 = D0 * $45000

... la stessa forma si applica alle operazioni: come per la addizione il
comando base è ADD, per la sottrazione è SUB.
Per la moltiplicazione i comandi sono solo MULS e MULU, rispettivamente per
operazioni con segno o senza segno. Analogamente per la divisione, i comandi
sono solo due: DIVS e DIVU.

Per altre funzioni matematiche o trigonometriche si deve ricorrere
necessariamente alla math.library del kickstart.

Allora, entriamo nel vivo della spiegazione delle funzioni di libreria: per
usarle, si deve innanzitutto 'aprire' la libreria necessaria. Per aprire la
libreria, si deve conoscere l'indirizzo a cui questa fa riferimento, detto
(importante) BASE. A partire da questa base, conoscendo la posizione ad essa
relativa delle altre routine, si possono richiamare le funzioni di quella
libreria.
L'unica libreria che non deve essere aperta e' la EXEC.LIBRARY, che viene
automaticamente aperta dal Kickstart all'accensione.
Al momento dell'accensione, il Kickstart mette la BASE della exec.library
all'indirizzo di memoria 4 nella CHIP. In numero esadecimale che contiene
la CHIP all'indirizzo 4 è detto ExecBase.
L'indirizzo 4 è l'unico indirizzo 'sicuro' e costante di tutta
l'architettura Amiga. Infatti, tutto il sistema operativo, per essere
multitasking, deve essere rilocabile in memoria, quindi non si può
essere mai sicuri che una certa routine sia allocata in memoria ad un certo
indirizzo. Ad esempio, il VBR (Vector Base Register), cioè le 'fondamenta'
dell'AmigaDOS, tabelle di indirizzi ecc. sono generalmente nella CHIP, ma
se uno ha FAST vengono trasferite in questa dal S.O. per avere più velocità
e più CHIP libera. Ma anche nella FAST la posizione non può essere sicura,
vi sono routine che gestiscono i device, i monitor, ecc.che potrebbero
rilocare il VBR in un altro indirizzo. Quindi tutti gli indirizzi che ci
serviranno per il Sistema Operativo (non per i chip custom) verranno
richiesti all'exec.library, che è la struttura che fa da supervisore a
tutte le routine in memoria.
L'indirizzo di exec, però non lo si poteva 'chiedere' a nessuno all'
accensione, quindi viene memorizzato dal Kickstart all'indirizzo 4.

Le librerie, come la exec.library, sono insiemi di routine che fanno cose ben
precise. Il loro elenco e spiegazione si trova in 5 libroni chiamati ROM Kernel,
la cui lettura è piuttosto impegnativa... (circa 2000 pagine in tutto!...)
L'indirizzo base della libreria ExecBase, IntuitionBase, ecc. non 'punta'
alla locazione di memoria dove comincia la libreria, ma dove questa
finisce. Quindi, le routine che compongono la libreria SI TROVERANNO SEMPRE
AD UN INDIRIZZO INFERIORE ALLA BASE. Per accedere a queste routine, basta fare
un'istruzione JSR all'indirizzo della routine desiderata. Ma come sapere questo
indirizzo se non sappiamo dove sono in memoria?
Qui ci vengono in aiuto le tabelle dette LVO LIBRARY VECTOR OFFSET.
Questi valori, standard, definiscono lo scostamento di una routine rispetto
alla Base della libreria. Per quello che ho detto prima IN MAIUSCOLO, gli
scostamenti sono sempre NEGATIVI. Ad esempio, prendiamo una funzione
qualsiasi della exec.library: AllocMem. Questa funzione serve per allocare
una quantità di memoria ('come' lo vedremo dopo). Dalle tabelle LVO vediamo
che ha un offset di -198. Sappiamo dunque che è posta 198 byte prima della
ExecBase.
Come fare a raggiungerla?
Guardate il codice che segue, che utilizza i modi di indirizzamento prima
spiegati:

MOVE.L    4,A6  Muove ExecBase, la LONG contenuta all'indirizzo di
                memoria 4 in A6
JSR  -198(A6)   Salta all'indirizzo a cui punta A6, sottratto di 198.
                In pratica, salta alla locazione di memoria A6 - 198 Bytes.

Così si richiama una funzione di libreria.
La funzione di libreria per funzionare ha bisogno che le si passino dei
parametri. Questi parametri devono essere preenti nei registri del processore.
Ad esempio, la funzione AllocMem deve sapere QUANTA memoria allocare e che tipo
(CHIP, FAST, QUALSIASI). La funzione, a sua volta restituisce in un registro di
tipo Dx l'indirizzo del segmento di memoria allocato. AllocMem richiede:

in D0     la quantità di memoria da allocare;
in D1     il tipo di memoria:      1 = Qualunque
                                   2 = CHIP
                                   4 = FAST

e, dopo la chiamata, restituisce in D0 l'indirizzo del segmento di memoria
allocato. Ad esempio, proviamo ad allocare 200K di CHIP
Quindi:

MOVE.L    #204800,D0     200K = 204800; valore messo in D0
MOVE.L    #2,D1          2 = CHIP; valore messo in D1
MOVE.L    4,A6           ExecBase in A6
JSR       -198(A6)       Salta alla subroutine
MOVE.L    D0,Buffer      Mette nella variabile Buffer l'indirizzo del
                         segmento di memoria.

Nell'esempio prima visto, si usa una variabile, Buffer. In Assembler le
varibili non sono inizializzate automaticamente, come in basic e in C, ma si
devono definire. Per definirle, si usa la funzione DS (acronimo
di 'DEFINE SPACE'):

quindi per definire la variabile Buffer, si sarebbe dovuto fare così:

Buffer:   DS.L   1   Assemblando, lascia nel codice una LONG libera all'
                     indirizzo Buffer
MOVE.L    #204800,D0
MOVE.L    #2,D1
MOVE.L    4,A6
JSR       -198(A6)
MOVE.L    D0,Buffer  Muove il contenuto di D0 all'indirizzo di Buffer
                     (già vuoto perchè inizializzato)

C' è anche il comando DC simile a DS, ma che definisce una costante, numerica
o alfanumerica. Se numerica il numero viene considerato tale, se fra '' viene
considerato il suo carattere ASCII:

Numero:   DC.L $40000         Definisce $40000 all'indirizzo identificato
                              dalla label Numero:

Parola:   DC.B 'ELIO',0,0     Pone a partire dall'indirizzo identificato
                              dalla label Parola: i 4 byte che compongono
                              il nome ELIO più altri due byte uguali a 0.

Vediamo ora come aprire una libreria che non sia exec (quella sempre aperta).
Innanzitutto, si apre richiamando la funzione OpenLibrary, che ha un offset di
-552. Questa richiede che nel registro A1 ci sia un indirizzo che punti ad una
locazione di memoria che contiene il nome in ASCII della libreria da aprire.
Dopo aperta la libreria fornisce nel registro D0 la Base della libreria aperta;
se D0 è 0 la libreria non è stata aperta per qualche motivo. Quando una libreria
non è più usata, si deve chiudere con la funzione CloseLibrary, che ha un LVO
di -414 e richiede in A1 la Base della libreria dachiudere.
Vediamo per esepio come aprire la Intuition.Library:

Nome:DC.B 'intuition.library',0,0  All'indirizzo Nome: c'è i caratteri ASCII
                                   che rappresentano il nome della libreria da
                                   aprire, seguiti da due zeri che indicano
                                   la versione richiesta della libreria:
                                   0 = qualunque
IntBase:DS.L   1                   Definisce uno spazio libero (usato come
                                   variabile) lungo 1 LONG e chiamato
                                   IntBase. Conterrà la Base
                                   della libreria Intuition.

LEA       Nome,A1                  Mette in A1 l'indirizzo del Nome
MOVE.L    4,A6                     ExecBase in A6
JSR       -552(A6)                 Chiama OpenLibrary
MOVE.L    D0,IntBase               Mette D0 in IntBase (è IntuitionBase)

     ....

MOVE.L    IntBase,A1               Mette IntuitionBase in A1
MOVE.L    4,A6                     ExecBase in A6
JSR       -414(A6)                 Chiama CloseLibrary


Se si vuole rendere più leggibile il programma , si può sostituire agli LVO il
loro nome definendo delle costanti numeriche all'inizio del programma con
l'istruzione EQU. Es.:

AllocMem  EQU  -198

D'ora in poi quando si scriverà AllocMem sarà come scrivere -198.


Proviamo a fare un semplicisimo programmino: apriamo l'intuition.library, e
richiamiamo una sua routine, che faccia lampeggiare lo schermo come quando c'è
un errore AmigaDOS. Sarà un programma piccolo che dovrà essere lanciato da una
SHELL, quindi dovrà essere progrmmato secondo le regole dell'AmigaDOS.
Essendo un programmino facile facile, questo non pone difficoltà.



; Che bello il mio primo programma in SEKA Assembler !!
;  Chissà perchè mi va in guru.. forse sono le cache...
;   ... porcamiseriasul500funzionava  e  sul4000inveceno!!!! Grazie, 68040!

OpenLibrary    equ  -552        ; definisce gli LVO
CloseLibrary   equ  -414
DisplayBeep    equ  -96

Start:    movem.l   a1-a6/d1-d7,-(sp)   ; salva i registri

lea  IntName,a1                  ; carica l'indirizzo del  nome in A1
     move.l    4,a6              ; ExecBase in A6
     jsr  OpenLibrary(a6)        ; apre la libreria
     tst.l     d0                ; testa d0 se è uguale a 0
     beq  Fine                   ; se è = 0 c'è un errore e va a Fine:
                                 ; se no avanti
     move.l    d0,IntBase        ; mette in IntBase valore di IntuitionBase
     move.l    IntBase,a6        ; IntuitionBase in A6
     jsr  DisplayBeep(a6)        ; richima la funzione DisplayBeep
     move.l    IntBase,a1
     jsr  CloseLibrary(a6)
Fine:     movem.l   (sp)+,a1-a6/d1-d7
     rts

     even
IntBase:dc.l   0
IntName:dc.b   'intuition.library',0,0

Visto il successo, passiamo ad altro... ehm...

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

La programmazione dell'hardware grafico dell'Amiga si basa sullo sfruttamento
dei coprocessori grafici, il blitter ed il copper. Il primo esegue tracciamenti
di linee, riempimenti di aree, e soprattutto copia di più porzioni di memoria
combinandole fra loro in vari modi.

La programmazione del Blitter e del Copper è alquanto complicata, e tralascio.

Non faccio esempi di CopperList, in quanto ho già provato e dato che uso un
accesso illegale ai registri del Copper, il nostro caro 1200/4000, che ha i
chip AGA con i registri modificati rispetto al 500, mi dice cortesemente:
'CHE CAVOLO FAI? Mi fai male...' e mi ringrazia con un bel GURU!
Infatti, questi 'maltrattamenti' dei coprocessori il 500 li accettava e ne era
contento, ma stì fetenti degli AGA mi sputano in faccia.
Volevo andare avanti con altri esempi, ma al ventitreesimo Guru mi sono
stancato, ho spento il 4000 e mi sono messo anch'io in meditazione con un
quadratino rosso che mi lampeggiava sulle lenti degli occhiali.


dOPO QUATTRO ORE CHE SCRIVO SONO ORMAI FUSO. (Quest'uomo è un eroe!!! ndKle)

cAPITANO pICARD A PLANCIA...
cOMANDANTE dATA, CURVATURA OTTO, AL MIO COMANDO TELETRASPORTATE ME
ED IL MIO CONIGLIETTO...


arrGGGHHHHH!

                                                            @{b}Deep Red@{ub}
@endnode

@node corsoc "I FONDAMENTI DELLA PROGRAMMAZIONE C"

@{b} ------------------------------INTRODUZIONE AL C--------------------------------
                         ---------BY DEEP RED-----------@{ub}

/* ======================================================== *
 * IZIO    ___                                              *
 * SOFT   / //    UNA VELOCISSIMA INTRODUZIONE AL C         *
 * ___   / //     Senza la pretesa di essere esaustiva      *
 * \ \\ / //      ma solo a scopo informativo...            *
 *  \ \/ //                                                 *
 *   \__//                        (c)1998 Maurizio DEEP RED *
 *                           SAS/C v6.51 Development System *
 * -------------------------------------------------------- *
 * DATA: Domenica 17-Mag-98 9:25:58   VER ...               *
 * S.O. / HW .....                    REV ...               *
 * NOTE: Do, Re, Mi, Fa... (boiata: ammetto che l'ho        *
 *                          aggiunta io!!! ndKle)           *
 * ======================================================== */


Bisogna sempre iniziare i programmi C con un commento.
I comenti possono essere sempre presenti in ogni parte di un programma e
quello che racchiudono viene sempre ignorato (come il REM in basic).
I commenti sono delimitati dai caratteri: /* e */

/*  Questo è un commento:         */
/*  "Salve, sono il commento... " */

I programmi in C sono composti principalmente da tre parti:

Commento iniziale, Comandi preprocessore e Routine principale. Del
commento iniziale ne ho già parlato, i comandi preprocessore sono comandi
 preceduti da '#' e definiscono costanti (#define) procedure e inclusioni
(#include) di file esterni detti Include (quelli .h).
La routine principale deve essere chiamata main(). Come tutte le routine
del programma è racchiusa tra parentesi graffe. Le graffe racchiudono
molti comandi che verranno trattati come un unico comando.
IMPORTANTE: il compilatore, come UNIX, riconosce sempre la differenza fra
caratteri maiuscoli e minuscoli, quindi se si scrive #Include anzichè
#include darà un messaggio di errore.

Struttura del programma:



/*   Commenti iniziali   */

#include < .. nome file ..>
#define PI 3.1415  /* Definisce una costante dandole un nome */

main()
{

    /* ...  blocco della routine ... */

}


I principali file che si devono quasi sempre includere con il comando
#include a seconda delle funzioni richieste dal programma:

#include <stdio.h>        Abilita le funzioni di I/O standard
#include <stdlib.h>       Abilita alcune funzioni per librerie standard del C
#include <string.h>       Abilita la gestione delle stringhe
#include <math.h>         Abilita la gestione delle funzioni matematiche
#include <exec/types.h>   Abilita la differenziazione tra tipi di dati


Quando si lavora con una libreria, si deve includere il rispettivo file.h.
es. con la Intuition.library: #include <intuition/intuition.h>

Le variabili in C hanno una gestione un po' diversa dal Basic: le variabili
sono solo uno spazio di memoria che contiene bytes. Sta al programmatore
dire al compilatore come interpretare i dati che trova. Ad esempio, una
variabile di 4 Bytes (32 bit) può contenere un unico numero a 32 bit oppure
due numeri a 16 bit. Il compilatore distingue questi casi al momento dell'
inizializzazione della variabile, tramite una parola chiave.
Vi sono variabili a 1, 2, 4, 8, 16, 32 e 64 bit.
Ovviamente, le variabili da 1 byte sono velocissime da gestire da parte del
processore, ma possono contenere un limitato intervallo di valori (256); al
contrario, le variabili a 32 o 64 bit sono pesanti da gestire, ma offrono
un intervallo elevatissimo o un grande numero di cifre dopo la virgola.
Il problema si pone poco per il 68040, perchè gestisce efficentemente
variabili a 32 bit di dati e variabili a 64 bit per il coprocessore
matematico. Comunque, utilizzare una corretta inizializzazione consente un
sensibile aumento di velocità per le variabili coinvolte in loop o in
contatori.

Per dichiarare una variabile, si usa questa sintassi:

(CHIAVE), TIPO, nome;

Nota che come tutti i comandi del C (esclusi i preprocessore) devono
terminare con ";".
CHIAVE è una distinzione per indicare al compilatore dove allocare lo
spazio per la variabile:

Extern:   Indica che la variabile non è correntemente usata, ma viene
          usata in un programma esterno che verrà incluso con
          #include. (E' poco usato).

Register: Se è possibile, il compilatore assegna la variabile ad un
          registro della CPU: questo consente una elevatissima velocità
          operativa, dato che il dato è già presente in CPU e non deve
          essere prelevato dalla memoria. In caso di loop con calcoli a
          32 bit se le variabili coinvolte sono tutte Register, si
          hanno velocità di calcolo spaventose. Il problema è che la
          variabile viene assegnata solo se c'è un registro della CPU
          che sia costantemente libero, cosa che con il multitasking
          è molto rara.

Auto:     Le variabili Auto vengono memorizzate nello stack, cioè
          vengono attivate solo all'inizio di una procedura, e
          all'uscita di questa vengono disattivate. E' l'attributo
          di default.

Static:   Queste variabili sono memorizzate nell'area dati generale
          del programma, sono temporanee, poco veloci, ma hanno il
          pregio che sono invisibili dal compilatore, che quindi non
          le può modificare.

Tipi di dati con i quali è possibile dichiarare variabili:
---------------------------------------------------------------------------
TIPO DI DATI       INTERVALLO DI VALORI                         OCCUPAZIONE
---------------------------------------------------------------------------
char               -127              fino a   128                    1 Byte
unsigned char      0                 fino a   255                    1 Byte
short              -32768            fino a   32767                  2 Byte
unsigned short     0                 fino a   65535                  2 Byte
int                -2147483648       fino a   2147483647             4 Byte
unsigned int       0                 fino a   4294927296             4 Byte
float              +/- 10e-37        fino a   +/- 10e38              4 Byte
double             +/- 10e-307       fino a   +/- 10e308             8 Byte
---------------------------------------------------------------------------

Questi sono i tipi di dati standard per l'Amiga. Ve ne sono altri
ammissibili, introdotti per garantire la compatibilità con programmi scritti
per altri computer. Ad esempio, il tipo 'int' è 4 Bytes sull'Amiga, ma
sull'MS-DOS è solo 2 Bytes. Gli altri tipi possono essere utilizzati
includendo il file <exec/types.h>.

Quindi, per dichiarare una variabile, il comando è il seguente:

      int Ziopino;

Ora, la variabile Ziopino può essere usata come in basic per contenere
numeri che non eccedano il suo intervallo di valori. (es.:  Ziopino = 1234;).
Si possono dichiarare più variabili con un unico comando, seprandole con una
virgola:

      int Topolino, Pippo, Minni;

Saranno tutte variabili di tipo int. Si può inoltre dichiarare una matrice
dando dopo il nome la dimensione della matrice fra parentesi quadre.

Per le variabili di tipo unsigned char c'è una posibilità in più: dato che
possono contenere il codice ASCII di un carattere, si possono assegnare in
due modi: con il codice ASCII del carattere o con il carattere voluto messo
fra ' '. Infatti, il C riconosce un carattere o un insieme di caratteri
racchiusi da ' ' non come una stringa ma come il valore numerico dei
caratteri. Le stringhe vengono racchiuse invece da "".
es.:
      unsigned char Pippero;
      Pippero = 'A';  /*  equivale a:  Pippero = 65  */


Vi sono in C due identificatori particolari che si antepongono alle
variabili per dare una interpretazione particolare al valore che contengono:
sono * e &. E' facile confondersi fra queste due perchè hanno una funzione
apparentemente simile, ma in pratica complementare fra loro.

& significa indirizzo di...:

                     es.:   a = &b; a contiene l'indirizzo
                                    in memoria di dove
                                    è allocata la variabile
                                    cioè dove è immagazzinato
                                    il valore di b.

* significa puntatore ad un indirizzo: posto davanti ad una variabile,
indica che il valore che contiene è un indirizzo. E' più facile con un
esempio:

                                 es.:   a = 20000;
                                        *a = 3; metterà il valore 3 all'
                                                indirizzo di memoria 20000.

quindi, se a = &b (a contiene l'indirizzo di b), il comando *a = 12 metterà
il valore 12 nella variabile b. (Chiaro, no?... Oddiomisifumailcervello...)
(Limpido direi!!! Stò scherzando, è chiarissimo!!! :-) ndKle)

Quando si assegna un numero ad una variabile, si può usare un delimitatore
per inserire il dato nella forma più corretta o desiderata.

0xNUMERO:       Precedendo un numero con '0x', il compilatore interpreterà il
                numero come esadecimale
0NUMERO:        Precedendo un numero con '0' il compilatore lo interpreterà
                come ottale.
NUMEROL:        Mettendo una L in coda ad un numero, lo si forza ad essere di
                tipo 'long'.
(tipo)NUMERO:   Mettendo un tipo tra parentesi prima di un numero lo si forza
                ad appartenere a quel tipo: es.:  long a; a = (long)10;

All'interno delle stringhe ci possono essere dei caratteri di controllo:
sono preceduti dalla barra rovesciata \ per non essere interpretati come
cartteri. Sono quelli che comunemente otteniamo con i tasti CTRL-LETTERA.

    \n       Line Feed
    \r       Carriage Return
    \b       Cancella un carattere indietro (BackSpace)
    \t       Tabulazione
    \g       Emette un beep

Dato il particolare significato dei cratteri " ' e \, questi cratteri vengono
rappresentati all'interno delle stringhe preceduti da \  \\ \" e \'.
All'interno di una stringa, si può inserire un qualsiasi carattere mettendo
il suo codice ASCII dopo la barra:  es.: \65 corrisponde ad 'A'


OPERATORI:
        +, -, *, /  Operatori comuni (come in basic);
        %  Modulo;
        &  AND bit-per-bit  &&  AND logico
        |  OR bit-per-bit   ||  OR logico
        ^  XOR bit-per-bit
        <<  Shift a sinistra
        >>  Shift a destra
        !  NOT logico
        ~  Complemento ad uno
        -  Negazione
        ++ Addiziona 1 ad una variabile:   es.: a++
        -- Sottrae 1 ad una variabile:     es.: a--
        () Chiamata di funzione
        [] Elemento di una matrice
        .  Accesso ad un elemento di una struttura di variabili tramite il
        nome dell'elemento;
        -> Accesso ad un elemento di una struttura di variabili tramite il
           puntatore all'elemento;

OPERATORI DI CONFRONTO:
     ==  Uguale a...          !=  Diverso da...
     <   Minore di...         >  Maggore di...
     <=  Minore o uguale      >= Maggiore o uguale

OPERATORI DI ASSEGNAZIONE:
     =       es.:    a = b    Significato:   a = b
     +=              a += b                  a = a + b
     -=              a -= b                  a = a - b
     *=
     /=                ecc.                    ecc.
     %=
     >>=
     <<=
     &=
     |=
     ^=

OPERATORI PARTICOLARI:
     ? :  ha tre operandi:       Espr1 ? Espr2 : Espr3
          L'espressione Espr1 può essere algebrica o condizionale
          se Espr1 ha un valore > 0 o, se condizionale, è vera, allora
          l'operatore ? ritorna il valore di Espr2, altrimenti ritorna
          il valore di Espr3
     ,    la virgola serve per per determinare la sequenza delle espressioni
          es.: a = (b = 1, b =+ 2);
          produce questo effetto: a = 3  e  b = 3


CONDIZIONI:

     COMANDO IF: es.:                        COMANDO SWICTH: es.:

     IF (Condizione) ELSE ...                SWICTH (Espressione)
                                             {
        oppure:                                Case Variabile1: Comando1;
                                                                   break;
     IF (Condizione)                           Case Variabile2: Comando2;
     {                                                             break;
            ... Comandi...                     ecc...
     }
     ELSE                                      Default: ComandoDefault
     {                                       }
            ... Comandi...
     }

LOOPS:

     -    Loop FOR:

     FOR (iniz.Variabile; condiz.; modif.variabile);  Iniz.var. es.: n=0;
     {                                                condiz. es.: n < 80;
         ... Comandi...                               modif.var. es.: n++
     }

     -  Loop WHILE:                             -  Loop DO..WHILE:

     WHILE (Condizione);                        DO
     {                                          {
         ... Comandi...                             ... Comandi...
     }                                          }
                                                WHILE (Condizione);

SALTO:    Comando GOTO (Etichetta);     Etichetta = Nome seguito da :

Il comando BREAK; fa uscire dal corrente ciclo di condizioni { }.


TABELLE PRESE DALL'HELP DEL SAS/C:


%' specifiers for formatted input, according to the ANSI standard.

   Specifier      Meaning
   ---------      -------
   d,i            signed integer
   o              octal unsigned integer
   u              unsigned integer
   x              hexadecimal unsigned integer
   e,f,g          floating point
   s              any string of non-whitespace characters
   [              any non-empty sequence of characters from specified set;
                  can optionally include leading ^ to specify NOT in set
   c              any character
   p              pointer value
   n              number of characters read from input
   %              exact match for percent (%) character


'%' specifiers for formatted output, according to the ANSI standard.

   Specifier      Meaning
   ---------      -------
   d,i            'int' argument is converted to a signed decimal string
   o              'unsigned int' argument is converted to octal string
   u              'unsigned int' argument is converted to decimal string
   x              'unsigned int' argument is converted to lowercase
                  hexadecimal string
   X              'unsigned int' argument is converted to uppercase
                  hexadecimal string
   f              'double' argument is converted to a decimal string
   e,E,g,G        'double' argument is converted to a decimal string using
                  scientific notation
   c              'int' argument is converted to an unsigned char
   s              argument is a pointer to a NULL terminated array of
                  character type (C-style string)
   p              argument is printed as a pointer, using lowercase
                  hexadecimal characters
   P              argument is printed as a pointer, using uppercase
                  hexadecimal characters
   n              argument is a pointer to an integer into which will be
                  written the number of characters output so far
   %              a percent sign (%) will be written


STRUTTURE:

Nella programmazione in C dell'Amiga, sono di importanza vitale le strutture.
Sembra difficile, ma una volta entrati nell'ottica della loro utilizzazione
si riveleranno uno strumento molto comodo.
Una struttura è un insieme i dati, ordinati uno dopo l'altro, raggruppati con
un solo nome. Ogni dato che compone la struttura ha un proprio nome. Per fare
un paragone, è come un dischetto con tante directory. E' più facile fare un
esempio:

struct
{
     char Nome[20];
     char Cognome[20];
     char Via[40];
     short Numero;
     int NTel;
} CavolacciComePompaIlPippero;

(Noto che a Deep Red piace, come a me, dare nomi assurdi alle variabili:
dovreste vedere la faccia del mio professore quando vede cose tipo
Bella_Variabilona_mia o Il_Nostro_Bello_Stack_Simpatico_E_Carino!!! ndKle)

Allora, la struttura dati chiamata CavolacciComePompaIlPippero,
(da qui abbrevviata con CCPIP...), è composta da matrici, una short e un int.
Le matrici contengono massimo 20 caratteri. Trattando le matrici, Nome indica
la matrice nella sua totalità, mentre ad esempio Nome[5] indica solo il quinto
carttere del Nome.

Ai membri della struttura, trattati normalmente come variabili, si può accedere
in due modi: tramite il nome o l'indirizzo della struttura. Se vogliamo mettere
nel campo Nome il nome ELIO, possiamo fare in questo modo:

        CavolacciComePompaIlPippero->Nome = 'ELIO';

(E l'abbreviazione??? :-) ndKle)

Cioè: il simbolo -> permettere di accedere ad un elemento della struttura
partendo dal nome di questa e conoscendo il nome dell'elemento.
Se vogliamo ricavare il valore da un elemento della struttura, ad esempio il
numero di telefono, possiamo fare così:

     short NumeroDiTelefono;
     NumeroDiTelefono = CavolacciComePompaIlPippero->Numero;

Se invece non si ha il nome della struttura, vi si può accedere tramite il suo
indirizzo. Se l'indirizzo è contenuto nella variabile chiamata Rocco, si può
accedere utilizzando al posto del simbolo -> il simbolo '.'
es.:
     Rocco.Nome = 'ELIO';


Tutte le parti del sistema operativo sono gestite da strutture. La definizione
di queste viene fatta includendo i relativi file include, che spiegano anche
cosa sono le varie voci che le compongono.


Termino qua la discussione, in quanto approfondire gli argomenti richiederebbe
uno spazio molto elevato, e un notevole impegno in termini di tempo. Credo
comunque che sia sufficiente per farvi capire come 'ragiona' il C e che tipo di
linguaggio esso sia.

Se volete un pò di utili listati d'esempio, premete @{"qui" system "execute >NIL: data/script/copy_listati"} e scegliete dove
copiarli (OCCHIO, saranndo copiati nella dir che scegliete, senza crearne
un'altra al suo interno!!!)

E non è finita! Un pò da contorno a questo articolo e un pò come regalo eccovi i
sorgenti due semplicissimi programmini in C, con tanto di codice sorgente: uno
serve a salvare il Kiskstart su un file (TGIK), l'altro (3DIZIO) estrae da un
file TDDD Imagine i dati che corrispondono a vertici, spigoli e facce e li salva
in tre files in formato RAW. (Su Amy non serve a niente, ma è utilissimo a chi
programma routine 3D utilizzando DirectX su PC). Premete @{"qui" system "execute >NIL: data/script/copy_progs"} e scegliete dove
copiarli (ricordate che non verrà creata una directory!!!).

Ho impiegato due ore a scrivere questo testo, esattamente il tempo che ci hanno
messo gli infermieri della neuro a trovarmi, nascosto com'ero in un baule della
soffitta. Ora mi hanno trovato, e mi invitano cortesemente ad andare con loro.
Credo che se mi lasceranno libere le braccia e mi porteranno un terminale potrò
scrivere qualcosa in futuro, fra un'elettroshock e l'altro.

NON TIRATEEEE!!!! VI SEGUO DA SOLOOOOOO!!!!!!

                                                            @{b}Deep Red@{ub}
@endnode

@node risate "RISATE, RISATONE E RISATISSIME!!! (E ANCHE RISOTTI!!!)"

@{b} ----------------------------L'ANGOLO DELLA RISATA------------------------------
                      ---------BY UN PO' DI GENTE---------@{ub}

Questa volta ci facciamo quattro risate in faccia al caro Bolletta Cancelli,
ovvero Bill Gates & Company, con alcuni pezzi umoristici raccolti sui newsgroup
italiani dall'onnipresente Deep Red e a loro volta diffusi da altre persone, che
ringraziamo molto: Michele Puccini, Marco Vitale, Giuseppe Ammndolia e Alfredo
D'Angelo.

Si dia inizio alle risate:

-Bill Gates sta' facendo l'amore quando la compagna gli dice: "Caro non godo
per niente !"
E lui: "Annullo, Riprovo, Ignoro o Tralascio?"

-Bill Gates va' da Divine Brown e le dice: "Divine, mi faresti lo stesso
lavoretto che hai fatto a Hugh Grant ?!"
Divine risponde: "Cosa ? Mandarti in galera ?!"
"No," dice Bill, "Mi piacerebbe il tuo trattamento orale, e sono pronto a
pagare bene per il privilegio...."
"Certo," dice Divine, lanciandosi voracemente su Bill.
Pochi minuti dopo Bill e' soddisfatto e dice alla sua partner: "Ora capisco
perche' ti chiamano Divine - Divina di nome e Divina di fatto...."
"Bravo," replica Divine, "ed ora capisco perche' hai fondato una compagnia
che si chiama Microsoft (PiccoloSoffice)."

-La cacciata dal paradiso avvenne quando Adamo rubò l'Apple dall'albero.
Dio gli disse: "Mi hai disobbedito! Per punizione verrai scacciato dal
Paradiso Terrestre! E in piu' sarai costretto a creare un Sistema Operativo
del cavolo che solo vagamente ricorda quello del frutto proibito; e tutta la
tua progenie sara' condannata ad usarlo per sempre!".
Da quel giorno, Adamo si fece chiamare: BILL GATES e per punirlo Dio gli
diede il limite di 640 k...

-Dio non ha un Mac, semmai, poichè Dio è onnipresente necessita di un sistema
multitasking, potremmo scegliere tra SunOS/AIX/Linux/Amiga e anche OS/2, ma
se poi fosse un mainframe?

-Se la Microsoft facesse tostapane.... Ogni volta che compri il pane, devi
comprare un tostapane.
Non ci sarebbe bisogno di ritirare il tostapane, ma dovresti ugualmente
pagarlo. Tostapane '95 peserebbe 7.500 chili (necessitando perciò di un
rinforzo d'acciaio), userebbe tanta energia elettrica quanta ne servirebbe
per illuminare una città di piccole dimensioni, occuperebbe il 95% dello
spazio della tua cucina, e pretenderebbe di essere il primo tostapane che ti
permette di controllare quanto chiaro o scuro sarà il tuo toast, ed
interrogherebbe di nascosto gli altri elettrodomestici per sapere chi li ha
costruiti.
Tutti odierebbero i tostapane Microsoft, ma nondimeno li comprerebbero lo
stesso, poichè il pane più buono funziona soltanto con i loro tostapane... I
piani di produzione prevedono un rilascio dello standard per il 2010 quando
finalmente uscirà la versione definitiva del Tostapane '97.

-"Hiroshima '45, Chernobil '86, Windows '95 "

-Tempo fa negli USA girava una barzelletta con il papa, Eltsin e Bill Gates
(dopo il "divorzio" fra Microsoft e IBM).
Dio: "Ho scelto voi tre per annunciare a tutto il mondo che sono scontento
di come vanno le cose sulla Terra e quindi fra un mese manderò il secondo
Diluvio Universale".
Dopo il ritorno sulla terra il Papa proclama: "Ho due notizie da darvi, una
buona e una cattiva. La buona è che Dio esiste, la cattiva è che fra un mese
ci sarà il Diluvio Universale".
Eltsin: "Ho due notizie da darvi, entrambe cattive. La prima è che Dio
esiste, la seconda è che fra un mese ci sarà il Diluvio Universale".
Gates: "Ho due notizie da darvi, entrambe buone: la prima è che Dio esiste,
la seconda è che fra un mese non avremo più problemi per quanto riguarda
Windows 95"

-Windows e' un virus?
No, Windows non e' un virus, ecco cosa fanno i VERI virus.
Si replicano velocemente. Ok, lo fa anche Windows.
I virus usano molte risorse del sistema e rallentano il computer. Ok, lo fa
anche Windows.
I Virus, a volte rovinano il disco fisso. Ok, lo fa anche Windows.
I Virus rendono, occasionalmente, lento il computer (Vedi punto 2) e
l'utente acquistera' altro hardware. Ok, lo fa anche Windows.
Fino ad ora, sembra che Windows *SIA* un Virus, ma ci sono fondamentali
differenze.
I virus sono programmi ben supportati dagli autori, girano su *tutti* i
computer, il loro codice e' veloce, compatto ed efficiente e tendono a
diventare piu' sofisticati con il tempo.
Quindi, Windows *NON* e' un virus

Ed ora un pò di cronaca nera (fatti REALMENTE accaduti, non barzellette!):

-Il giornale di oggi riportava la notizia della presentazione di Win 98
Bill ha fatto una figuraccia di proporzioni mondiali: il computer gli si
e' bloccato al momento di usare lo scanner!!

Il giornalista ha detto che Bill era visivamente molto teso ed ha cercato
di sdrammatizzare dicendo che win 98 ha ancora dei problemi ed e' per
questo che ancora non e' uscito.

Certo fare la presentazione ufficiale alla stampa ed asserire che ancora
hanno problemi.... :-))))

-Ciao M_Vittorio , il 21-Apr-98 16:23:53 scrivevi:
>Se avete una parabola siete ancora in tempo a vedere la faccia
>di Bill Gates in EURONEWS

>Stamani mi sono fatto delle risate vedendolo a Euronews
>il pseudo OS del 98
>(e anche vedendo le facce delle persone che gli ridacchiavano dietro)

>Queste sono le piccole cose belle della vita (hehehehehe)

>http://www.repubblica.it/online/tecnologie/gates/crash/crash.html

>Speriamo che con le nuove versioni di AmigaOS non distruggano
>il Santone (guru)
>Ormai i crash vanno di moda e sono ritenuti professionali

Il 20 Aprile 1998 rimarra' un giorno storico grazie alla figuraccia di zio Bill.

Bisognera' festeggiare le ricorrenze alla grande.

@endnode

@node startrek "HOUSTON ABBIAMO UN PROBLEMA...NO, HO SBAGLIATO STORIA!!!"

@{b} ------------------WINCESS '98 SULL'ENTERPRISE - LA TRAGEDIA--------------------@{ub}

Questa storiella proviene da Fidonet: grazie a Deep Red per avercela prontamente
"palleggiata"!!!

--------------------------------------------------------------------------------
Diario del Capitano, Data astrale 9802.1beta


Abbiamo intercettato una astronave Borg ai confini del quadrante Menphis. La
nave sembra abbandonata: non c'è traccia di vita e abbiamo rilevato solo
deboli segni di macchine in attività. Il signor Data, il signor Worf, il
signor LaForge e sua cugina Gill Bates si sono teletrasportati a bordo per
un'esplorazione più accurata. Li stiamo seguendo dal ponte dell'Enterprise.


PICARD:   Signor Worf, ancora niente?

WORF:     (dall'astronave Borg) Niente Capitano. Pare proprio che se ne
          siano andati.

PICARD:   I loro computer?

WORF:     Per quello che ne capisco di tecnologia Borg, qui è tutto spento.
          Se non ci fossimo portati le torce non ci sarebbe nemmeno la luce.

DATA:     Forse non hanno pagato la bolletta!! Ah! Ah!

PICARD:   Data, disattivi quel dannato chip emozionale!

DATA:     Agli ordini... *CLICK* ... Ma che...? *CLICK* ...Non si disattiva...
          *CLOCK* ...Ah! Fatto.

PICARD:   Data, a volte non la invidio.

RIKER:    Capitano, lei una volta è stato assimilato dai Borg. Era in grado di
          sentire le loro comunicazioni...

PICARD:   Sì, Numero Uno, ma ora non capito nulla. I Borg non sono qui.
          Consigliere?

TROI:     Non avverto alcun pensiero, a parte quelli dei nostri amici.

LAFORGE:  Capitano, abbiamo trovato qualcosa!

PICARD:   Che cosa?

LAFORGE:  Capitano, abbiamo trovato qualcosa!

PICARD:   Ho capito! Che cosa avete trovato?

LAFORGE:  Un piccolo disco piatto, argentato, con un buco in mezzo. Non sembra
          tecnologia Borg, per quello che ne capisco. Sopra c'è scritto
          "Beta 2 DDK".

PICARD:   Non è Borg senz'altro. Prendetelo e tornate subito a bordo.


Più tardi, sul ponte, l'equipaggio esamina il disco.

PICARD:   Mai visto niente di simile...

WORF:     E'sicuramente terrestre. I Klingon non farebbero mai una cosa così
          assurda: una ciambella di plastica!

DATA:     Se mi posso permettere, Capitano, credo di sapere che cosa è.

PICARD:   Sì?

Data prende il disco e lo lancia.

DATA:     E'un disco... volante!!! Ah! Ah!

PICARD:   Data! Mi sembrava di averle ordinato di disattivare il suo chip
          emozionale!

DATA:     Mi scusi, Capitano... *CLOCK*... Fatto.

PICARD:   Allora, sa davvero qualcosa su quel disco?

DATA:     Certo: è un CD-ROM.

RIKER:    Un cidìcosa?

DATA:     Un CD-ROM, Signore. Un antiquato supporto terrestre per l'archiviazione
          dei dati, risalente, credo, alla seconda metà del ventesimo secolo.

LAFORGE:  Ventesimo secolo?!?

PICARD:   Possiamo leggerne il contenuto?

DATA:     Non con il computer dell'Enterprise, ma il dottor Soong ha installato
          al mio interno un antico lettore CD-ROM. Lo usava per farmi cantare
          vecchie canzoni.

PICARD:   Ci vorrà molto?

DATA:     Moltissimo, purtroppo. Forse anche un secondo. Il mio lettore CD è
          molto lento: è solo a unmilionequarantottomilacinquecentosestupla
          velocità.

PICARD:   E' pericoloso?

DATA:     Oh, no. Che danni potrebbe causare un CD-ROM, signore?

PICARD:   Allora ci provi, per favore.

DATA:     Geordi, ho bisogno del tuo aiuto. Sai dov'è il mio lettore?

LAFORGE:  Certo. Tirati giù i pantaloni... Ecco fatto.

DATA:     No. E'al contrario. Capovolgilo.

LAFORGE:  Scusa... Ora è a posto?


Silenzio.

PICARD:   Data?

DATA:     Attendere. Riconoscimento nuovo hardware in corso. L'operazione
          potrebbe richiedere qualche minuto.

RIKER:    Che cosa significa? Geordi, che sta facendo?

LAFORGE:  Sta leggendo il disco. Forse è la registrazione di un programma.

DATA:     Per rendere effettive le nuove impostazioni è necessario riavviare il
          computer. Riavviare il computer ora?
          Si/No.

PICARD:   Il computer? Bates, Data è collegto al computer dell'Enterprise?

BATES:    No, signore.

PICARD:   Allora riavvii, Data.

DATA:     BEEP! frrr.... frrr.... frrr....

LAFORGE:  Deve aver disattivato la gestione del linguaggio.

DATA:     Suggerimento... E' possibile diminuire l'affaticamento del collo
          posizionando lo schermo all'altezza degli occhi.

WORF:     Eh???

PICARD:   Data, questo fa parte della registrazione?

DATA:     Si desidera la registrazione?

PICARD:   Certo, che domande sono?

DATA:     Connessione in corso...

BATES:    Capitano, Data si è collegato al computer!

PICARD:   Lo disconnetta subito!

BATES:    Computer disconnesso, signore.

DATA:     Impossibile trovare l'applicazione SignUp per trasmettere le
          informazioni di registrazione.

RIKER:    Vuole dire che la registrazione non è leggibile?

DATA:     Chi è lei?

RIKER:    Non mi riconosce?

DATA:     Attenda, la sto rilevando automaticamente... Niente. Mi fornisca
          il disco contenente il driver del produttore del suo hardware.

WORF:     Data, mi riconosce? Sono Worf.

DATA:     Word? Una applicazione di Office.

PICARD:   Data, quel CD sta interferendo con le sue funzioni. Cancelli tutto
          quello che ha trasferito in memoria!

DATA:     Errore durante la rimozione di Windows 98. Deinstallazione terminata.

WORF:     Windows 98!

PICARD:   Worf! Di che si tratta?

WORF:     Per la verità, signore, è una vecchia leggenda Klingon. Si dice che
          molto tempo fa un nostro incrociatore sia esploso dopo aver avuto a
          che fare con un misterioso nemico chiamato "Windows 98". Si credeva
          fosse una nuova arma terrestre, ma poi non se ne seppe più nulla.

BATES:    Signore, ho controllato con il nostro computer. Sembra che anche la
          prima Enterprise avesse incontrato "Windows 98".

PICARD:   E come se la cavarono?

BATES:    Non lo so. Il dossier è incompleto, signore.

PICARD:   Contatti la Federazione. Comunichi la nostra situazione e chieda
          maggiori informazioni.

DATA:     La periferica specificata è già utilizzata da un'altra connessione
          di Accesso Remoto. Chiudere l'altra connesione e riprovare.

BATES:    Capitano! Non riesco a collegarmi con la Federazione! Data si è
          inserito nel computer.

PICARD:   Data! Si disconnetta subito!

DATA:     Questa nave contiene un'applicazione di tipo mime/warp. Si sta
          scaricando il plugin relativo.

LAFORGE:  Capitano! Instabilità del nucleo a curvatura!

PICARD:   Data! Si fermi!

DATA:     Non è possibile rimuovere Internet Explorer. Questa applicazione è
          in uso dal sistema.


Appare Q.

Q:        Certo che voi terrestri non imparerete mai.

PICARD:   Q! E'opera sua, questa?

Q:        E le sembra forse che io possa concepire qualcosa di così
          irrazionale? No, Capitano Picard: questi sono i frutti di quello
          che chiamate "il genio terrestre"!

PICARD:   Ma può aiutarci?

Q:        Anche se potessi, non lo farei. Ma, mi creda, non posso proprio.
          Come dite voi? Chi è causa del suo mal...


Q scompare. Data si mette a svitare una mensola.

PICARD:   Data, ora che sta facendo?

DATA:     Svuotamento del cestino in corso.

PICARD:   Data, non c'è nessun cestino!

DATA:     Impossibile eliminare Cestino. Disco pieno o protetto da scrittura.
          Conferma eliminazione files?

BATES:    Capitano! Data sta teletrasportando l'equipaggio nello spazio!

PICARD:   Worf! Gli spari!


Worf estrae una pistola e spara a Gill Bates.

LAFORGE:  Gill!!!

PICARD:   Worf! Non doveva sparare a lei, ma a Data!

WORF:     Scusi, Capitano. ma era tanto che desideravo farlo! Non so perchè,
          ma non l'ho mai sopportata. Forse per il nome. E poi avrebbe dovuto
          morire comunque, prima della fine dell'episodio.

PICARD:   Morire? Perchè?

WORF:     Perchè è il personaggio che nessuno conosce: appare all'inizio
          dell'episodio e poi muore. E' un classico.

DATA:     Attendere. Arresto del sistema in corso.

LAFORGE:  Rottura del nucleo a curvatura!!!

PICARD:   Abbandonare la nave!!! Abbandonare la...


Più tardi, su Deep Space Nine...

O'BRIEN:  Comandante, l'Enterprise è scomparsa improvvisamente dagli schermi
          dei radar. Forse è entrata in un nuovo tunnel spaziotemporale.

SISKO:    Qualche messaggio?

O'BRIEN:  Solo uno, trasmesso nel momento stesso in cui sono scomparsi.

SISKO:    E che cosa dice?

O'BRIEN:  "E' ora possibile spegnere il computer".

SISKO:    Ma guarda un po'. Adesso l'Enterprise deve far sapere a tutta la
          galassia quando spegne un computer? Come se non avessimo niente da
          fare. Lasci perdere e venga con me al bar di Quark. C'è stata una
          nuova rissa per della birra andata a male.

--------------------------------------------------------------------------------

Pensate...meditate su cosa può accadere, le catastrofi che può causare la
diffusione eccessiva delle Finestre maledette: altro che Bug del Duemila!!!

@endnode

@node antims "LA LOTTA E' SENZA SOSTA: DEEP RED ALL'ATTACCO!!!!!"

@{b} -------------------------GLI SCRIPT ANTI-MICRO$OFT!!!--------------------------
                         ---------BY DEEP RED---------@{ub}

Cuccatevi questi script, che impediscono la lettura di un documento HTML da
parte di Internet Explorer!!! Utilissimi per fare un pò del male a certa
gente...

--------------------------------------------------------------------------------
<html>

<head>

<title>Anti Micro$oft</title>
<CENTER>
<h1>Vietato utilizzare Internet Exploder</h1>

<i>

Tre simpatici Java script per impedire la lettura di una pagina HTML utilizzando Internet
ExploDer.<BR> Usateli spesso, a favore di Nescape.</I>

<h2>SCRIPT n.1</h2>~<br>Vai al sito di Netscape!<br>

</center>

<xmp>

<---------INIZIO--------->

<script LANGUAGE="JavaScript"><!--

                                var uagent=navigator.userAgent;

                                if (uagent.indexOf("MSIE") == 25)

                                {

                                document.writeln('<META HTTP-EQUIV="REFRESH"

                                CONTENT="2; URL=http://www.netscape.com/">');

                                }

                                //-->

                                </script>

<-------FINE--------->

</xmp>

<hr size="2"><center>

<h2>SCRIPT n.2</h2>~<br>Vietato usare M$IE<br>

</i></center>

<xmp>

<---------INIZIO--------->

<script language="JavaScript">
                                var

                                uagent=navigator.userAgent;

                                if (uagent.indexOf("MSIE") == 25) { alert("STOP ! Stai utilizzando

                                M$ Internet Exploder!"); alert("e questa pagina non te lo

                                permette."); if (confirm("Vuoi visitare il sito di Netscape

                                per scaricare GRATUITAMENTE l'ultima release?"))

                                {locaction.href="http://www.netscape.com" } else { ("OK,

                                ritorna quando userai

                                Netscape Navigator!"); self.close(); } }

                                </script>





<--------FINE---------->

</xmp>

<hr size="2"><center>

<h2>SCRIPT n3</h2>~<br>Forzatamente Netscape<br>

</i></center>

<xmp>

<--------INIZIO---------->

<script LANGUAGE="JavaScript"><!--

                                var uagent=navigator.userAgent;

                                if (uagent.indexOf("MSIE") == 25)

                                self.close()

                                </script>

<-------FINE--------->

</xmp>

<hr size="2">





</body>

</html>
--------------------------------------------------------------------------------

Volete subito il file HTML qui mostrato per utilizzarlo al meglio? Allora
premete @{"qui" system "execute >NIL: data/script/copy_html"} e scegliete dove copiarlo!!!

                                                            @{b}Deep Red@{ub}
@endnode

@node 16k "I CLUSTER MALEDETTI DEL PIKKIO: CHE RISATE!!!!!!!!!!!!!!"

@{b} --------------------------LA MALEDIZIONE DEI CLUSTER---------------------------
                         ---------BY DEEP RED---------@{ub}

Eccoci qua, cari amici Amighisti, ad esaminare un' altra simpatica quanto
inquietante caratteristica di Wincess 95 (o, meglio, MS-DOS).

Il problema (uno dei tanti) questa volta lo troviamo nel modo in cui il nostro
caro MS-DOS, e di conseguenza Windows, gestiscono lo spazio su HD.

Non mi dilungherò annoiandovi con noiose spiegazioni tecniche, ma dovete sapere
alcune cose di base per apprezzare al meglio la boiata immane che incombe sui
nostri HD del picchio.

L'HD è suddiviso in tante piccole unità di allocazione, cioè il più piccolo
spazio allocabile su HD dal file-system, dette @{b}CLUSTERS@{ub}.
Il cluster ha una dimensione variabile in base alla capacità dell'unità di
massa.
Dato che il file system dell'MS-DOS è a @{b}16 bit@{ub} (FAT16), in un'HD potranno
esserci al massimo @{b}65536@{ub} unità di allocazione, per un massimo di @{b}2 Giga@{ub}. In
questo caso la dimensione del cluster sarà:

2.147.483.648 / 65536 = 32768 Kb.

Mi spiego meglio: nel caso precedente, dato che la minima dimensione allocabile
è di 32K, se scrivete un file lungo ad esempio 2K l'HD perderà 1 cluster, cioè
32K. Bello, eh?

Le dimensioni dei cluster variano da un minimo di 8Kb fino a 32Kb per MS-DOS e
Windows 95 rev.A. Con la rev.B del Windows (OSR2) è stata introdotta la FAT32,
cioè il file system a 32 bit. Con questa grande scoperta la dimensione del
cluster è 4Kb oppure 8Kb/16Kb in caso di HD di dimensioni spropositate.

Ora, provate ad osservre l'immagine che ho incluso: si tratta di un piccolo
esperimento che ho fatto sul mio picchio in occasione dell'ultima formattazione.
Ho intenzionalmente formattato l'HD in modalità FAT16, per rallegrarmi con la
ricerca dei files presenti sull'HD con dimensione <= 16Kb.
I risultati che ho ottenuto li potete vedere nell'@{"immagine" system "data/visage >NIL: data/16k.jpg"}:

Ricerca per dimensione file minore o uguale a 16Kb.
Risultato: @{b}2.063@{ub} file trovati, per una dimensione totale di quasi 9 Mb.

Facciamo ora un piccolo calcolo: se ognuno di essi in realtà 'mangia' 32Kb
all'HD, quanto essi in realtà occupano?

Il mio C:, della dimensione di 1 Gb, ha i cluster da 16Kb, quindi:

16.384 * 2.063 = 33.800.192.  Miiii, @{b}34Mb@{ub} fumati!!!!!!!!!!!

La cosa più rassicurante è che Windows è zeppo di collegamenti (link *.lnk) che
occupano 1 solo Kb su HD. Che spreco...

                      :)    :)    :)    :)

E' d'obbligo un paragone con Amiga, anche se questo si chiama infierire sui
vinti!
Vi chiederete quale sia la dimensione del cluster su Amiga?
Bene, aprite il fido HDToolbox, e selezionate PARTITION DRIVE. Scegliete una
partizione qualsiasi già esistente ed attivate il gadget ADVANCED OPTIONS.
Compariranno così tante informazioni aggiuntive fra di esse il gadget CHANGE.
Premetelo. Troverete la voce FILE SYSTEM BLOCK SIZE, con un gadget ciclico che
mostra la dimensione del nostro 'cluster': Miiii, @{b}512 bytes@{ub}! GRANDE!!!

Ciò significa che il massimo spreco teoricamente realizzabile su un file di
Amiga salvato su HD è di 511 bytes (salvando un file da 513 bytes).

Pensate a Windows, con la miriade di files piccoli che si ritrova, quanti Kb si
fuma ad ogni installazione!!! E non è finita qui: il discorso non si limita ai
files più piccoli di 16Kb, ma anche ai files più grandi: un files da 20 Kb, sul
mio HD, se ne fuma 32! Certo, in proporzione è inferiore, ma non giustifica
niente.

Vabbe, direte, ci sono le solite scuse: MS-DOS è vecchio di 15 anni... sapete,
la compatibilità all'indietro...

Nessuna scusa: Amiga 10 nni fa aveva già i cluster da 512 bytes, e che dire di
UNIX che li aveva 20 anni fa? (quando gli HD erano prototipi del MIT da 1 Kb...)
Per trovare 512 bytes di cluster dobbiamo andare su Windows NT, che a parte
l'interfaccia ha molte più cose in comune con UNIX che con Windows.
Ah, dimenticavo: Windows 98 (ammesso che funzioni) non cambierà la situazione
attuale.


CIAOOOOO e... alla prossima!


P.S.
----

Già da tempo AT ha rilasciato la nuova versione (preliminare) del file system
di Amiga. Cercate sul sito AT (e forse su Aminet) i files

FFS43_xx.LHA        FastFileSystem ultima revisione 64bit, unità >4Gb;
FFSTD64.LZX         TrackDisk a 64 bit;
SCSI43_xx.LHA       Aggiornamento per scsi.device.

I nomi spero siano questi... ma il contenuto non cambia!!!
Ho provato questo nuovo File System solo su una piccola partizione del mio HD,
da 20 Mb dedicata a test di questo tipo, notando un sensibile incremento di
velocità e di prestazioni in generale.

                                                            @{b}Deep Red@{ub}
@endnode

@node help "TOTAL AMIGA MAGAZINE ONLINE DICTIONARY SUPER HELP SYSTEM"

@{b} -----------------------------THE TAM ONLINE HELP-------------------------------@{ub}

Per i meno documentati...

Dal grande dizionario "T.A.M.N.S.D. (Total Amiga Ma Non Solo Dictionary)":

"@{b}ZONZARE@{ub}"
@{i}Andare a zonzo, gironzolare. (Lo ammetto, me lo sono inventato al momento! ndKle)@{ui}

"@{b}PORCONE@{ub}"
@{i}Insulto, imprecazione, maledizione ecc. ecc.@{ui}

"@{b}QUITTARE@{ub}"
@{i}Tornare al Workbench da un gioco, da una demo o da un programma, al momento
dell'uscita dallo stesso.@{ui}

@endnode

@node bugs "NON CI POSSO CREDERE!!! MA NO! SONO SOLO IMMAGINI STATICHE!!! O NO?"

@{b} -------------------------------------BUGS--------------------------------------@{ub}

Questo gioco merita una menzione particolare per come sono rimasto dopo averne
visto un paio di foto su CU Amiga e aver appreso che non si trattava di immagini
statiche!!! In effetti questo gioco, a prima vista, sembra proprio una specie di
@{b}Mario 64@{ub}, ovvero un platform completamente tridimensionale dalla grafica
mozzafiato: per ora quello che si sà è che gli autori si chiamano @{b}Prey@{ub} e che il
gioco sarà in effetti una specie di platform misto a Worms: quello che lascia
allibiti, come ho già detto, è la sola vista delle schermate: mi chiedo proprio
come si possa muovere tutto ciò, anzi, se non è una bufala (non si sà mai) non
mi stupirei se uscisse solo per PowerPC: certo l'intraprendenza di questi
programmatori amighisti è lodevole, e magari mi stò sbagliando: può darsi che
uno 030 basti e avanzi!!! Come ho già detto, per ora non si sà molto, vedremo
come si evolverà la situazione: questo gioco potrebbe rappresentare una
rivoluzione!!!

Comunque sia, non ci vorrà una "tredìeffecs"!!!

                                                            @{b}Kle@{ub}
@endnode

@node siliconpc "LA TRISTE SORTE DEI SILICON GRAPHICS: SALVATELI!!!"

@{b} ------------------------I PC INVADONO ANCHE I SILICON--------------------------@{ub}

Questa cattiva notizia, fortunatamente, non riguarda l'Amy, ma i sistemi
Silicon, molto amati e stimati da molti amighisti, me compreso: pare infatti che
i dirigenti della Silicon Graphics, analizzato il mercato, hanno concluso che,
@{b}dato l'aumentare di richieste per sistemi WindowsNT, le prossime nuove
workstation Silicon di fascia bassa saranno basate sul Pentium II più potente
(Merced) e su un'architettura firmata da Intel@{ub}. La produzione, anche di fascia
alta, verrà gradualmente convertita in piattaforme Intel-based. Come se non
bastasse, le dannosissime DirectX verranno portate anche sul mitico IRIX, il
granitico sistema operativo di Silicon, credo intaccandone profondamente la
solidità.

Con queste prospettive, crolla il mito: niente più processori MIPS, mai più
IRIX, ma un cuore PC. Ciò vuol dire che la Silicon per sopravvivere deve
sopportare un così grande ricatto: o ti adegui, o chiudi. Adeguarsi a cosa? A un
bus AGP che non funziona? Il bus proprietario Silicon viaggia a 2 Gb/sec, e
funziona. A un'architettura a memoria unificata che non riesce a prendere piede
sul mercato perchè è più incompatibile di Windows stesso? Alle periferiche USB
che, dopo due anni che è stato definito lo standard, non se ne vede l'ombra
neanche a pagare? Oppure ai processori Pentium, CISC che macinano un Windows di
130 Mb compilato per 386? I MIPS invece sono dei RISC che il Pentium lo vedono
appena come un possibile gestore delle cache.

Se la Ferrari smettesse di produrre F355 mettesse sul mercato delle Panda con il
motore preparato a costi improbabili? Non venderebbe più. Molti comprerebbero
una Panda usata e la elaborerebbero come le Panda-Ferrari. La concorrenza
sarebbe spietata, rimarrebbe solo il marchio. Rimarrà solo il marchio, a
distinguere fra tanti quelli che una volta erano i migliori.

Grazie, Bill. (PUAH!!!!! ndKle)

                                                            @{b}Deep Red@{ub}
@endnode

@node virus_checker "IL GRANDE RITORNO DI VIRUS CHECKER"

@{b} ---------------------------E' TORNATO VIRUS CHECKER----------------------------@{ub}

Molti di voi lo sapranno già, ma mi sembra giusto "celebrare" adeguatamente il
ritorno del mitico Virus Checker, uno dei più diffusi e amati antivirus per il
nostro computer, che circa tre anni fa fu "venduto all'asta" dal suo autore @{b}John
Veldthuis@{ub}, che non poteva più continuarne lo sviluppo: i preziosi sorgenti
furono acquistati da @{b}David Dustin@{ub}, che gentilmente li offrì al @{b}Virus Help Team
Denmark@{ub}: ora lo sviluppo è portato avanti da uno dei membri di questo team,
ovvero @{b}Alex Van Niel@{ub}: questo bravo amighista ha sfornato un'ottima nuova
versione, che quindi riporta fra noi questo mitico programma, davvero rimpianto
ai tempi della sua "quasi-caduta": sostanzialmente l'interfaccia è la stessa,
anche se è diventata più bella da vedere grazie alla bgui.library, e anche le
altre ottime caratteristiche di sempre sono state mantenute e migliorate:
davvero una buona notizia per chi, come me, ha sempre amato questo antivirus,
preferendolo decisamente all'antagonista VirusZ, in generale molto simile a VC
ma decisamente più "invadente", oltre che alquanto impalloso!!!

Mai più virus con @{b}Virus Checker II@{ub}!!! (Messaggio promozionale...)

                                                            @{b}Kle@{ub}
@endnode

@node uin98 "EH SI', WINDOWS SI' CHE INNOVA E RINNOVA..."

@{b} ---------------------WINZOZ 98 - THE REVOLUTION CONTINUES----------------------@{ub}

Vi racconto una bella notiziola che mi ha fatto scompisciare dalle risate: uno
dei piani della Microsoft per le prossime release del suo "S.O." è la
@{b}RILOCABILITA'@{ub}. Cioè, se tu installi un programma in una directory, non sei
obbligato a mantenerlo lì. Lo potrai successivamente spostare da un'altra parte
o in un'altra unità, senza che smetta di funzionare. Questo grazie ad un
database interno che usa dei percorsi relativi. Hanno scoperto l'acqua calda!!!
Forse qualche programmatore della Microsoft ha giocherellato con l' A1000 di suo
nonno e si è esaltato scoprendo la potenza del comando @{b}ASSIGN@{ub}.
Se questo è il futuro siamo in buone mani...per mantenere aggiornato e
funzionante un ipotetico database dei percorsi relativi o una miriade di link, o
qualsiasi altra cavolata che si dovranno inventare per emulare il comando ASSIGN
dell'AmigaDOS penso che ci vorrà la potenza di un PentiumII che viaggi a
frequenze da forno a microonde. (Vale a dire: sempre più memoria occupata,
sempre più spazio su HD sprecato e, last but not least, sempre più frullaggio
inutile dell'hard disk, da sempre una delle caratteristiche più indisponenti e
"pittoresche" di Uindoz!!! ndKle)

Queste sono belle notizie: ci copiano, ma lo fanno sempre a modo loro, cioè
@{b}MALE@{ub}!!!

                                                            @{b}Deep Red@{ub}
@endnode

@node 1000modi "I MILLE SOPRANNOMI DI WINDOWS!!!"

@{b} -------------------------MILLE MODI PER DIRE WINDOWS---------------------------
                            ---------BY KLE--------@{ub}

E' abitudine comune chiamare le persone più care con un soprannome: noi amiamo
molto Windows, anche se non è una persona, e gli diamo molti soprannomi: ecco un
glossario completo:

@{b}WINDOZ@{ub}: è un'abitudine stranamente comune quella di mettere le Z al posto delle
S: quindi questa dicitura è molto "stilosa"!!!

@{b}WINDOWZ@{ub}: vedi sopra, anche se questa è più difficile e meno "elegante" da
pronunciare!!!

@{b}WINDOWZE@{ub}: molto usato nelle riviste Amiga inglesi!!!

@{b}UINDOVS@{ub}: cambiando le lettere, la pronuncia non cambia!!!

@{b}UINDOZ@{ub}: derivato dai precedenti...

@{b}WINCESS@{ub}: questo nome mette in risalto le caratteristiche "igieniche" del caro
"sistema operativo"!!!

@{b}WINZOZ@{ub}: questo nome ben si adatta alla proverbiale "pulizia" di Windows!!!

@{b}WINZOZZONE@{ub}: rafforzativo del precedente.

@{b}VENTOWS@{ub}: "wind" significa "vento", quindi 2+2...

@{b}VINCIDOWS@{ub}: "win" significa "vinci", ariquindi 2+2...

@{b}FINTOFZ@{ub}: simpatica variante "tetesca ti Cermania"!!!

@{b}WINDOW$@{ub}: si adatta bene a Micro$oft!!!

@{b}WINDAUS@{ub}: altra variante delle varianti!!!

@{b}WINDAUZ@{ub}: variante del precedente (quindi variante della variante delle
varianti!!! Non mi passa proprio...)

@{b}WINDOS@{ub}: molto diffuso nella bergamasca!!! (Teeeee, tal set che o cumprat
l'öltima versiù del Windos!!! A ghe det pò ol Internet Esplorer e töte i
animassiù che i gà pias al me scetì!!! TRADUZIONE: Ehi tuuuuu (più o meno), lo
sai che ho comprato l'ultima versione di Windows!!! C'è anche Internet Explorer
e tutte le animazioni che piacciono al mio bambino!!!)

@{b}UANDOWS@{ub}: "uan" nel senso di "one", ovvero il sistema operativo unico al mondo,
naturalmente per le vaccate che fa!!!

@{b}WINDOSSO@{ub}: per intendere l'ostacolo che Windows rappresenta nell'evoluzione della
società!!!

@{b}WINGROS@{ub}: per esaltare le immani dimensioni di questo roccioso S.O.!!!

@{b}FINESTRE@{ub}: italianizzazione esasperata!!! (Altra caratteristica famosa di Windows
stesso).

@{b}DISASTROS@{ub}: non deriva direttamente da Windows, ma sarebbe un nome
azzeccatissimo!!! (DisastrOperating System).

@{b}WINTEL@{ub}: termine molto famoso, che unisce alla grande Windows+Intel, il mitico
duetto colpevole dei nostri incubi!!!

Ovviamente le varianti e le combinazioni sono molteplici, quindi sbizzarritevi
e, se trovate qualche altro soprannome carino, fatecelo sapere!!!

Ed ora, per concludere in bellezza, una bella variante "autocelebrativa" del
mitico @{"The Micro$oft Sound" system "data/play16 >NIL: data/winzoz.8svx"}!!!

                                                            @{b}Kle@{ub}
@endnode

@node assurdo "FOLLIE IN CASA AI: MA STANNO SCHERZANDO O COSA??????????"

@{b} ------------------------------MOMENTI DI FOLLIA--------------------------------@{ub}

Certe volte mi chiedo perchè la gente impazzisce: alcool, droga, problemi in
famiglia...i motivi possono essere molteplici: stà di fatto che Petro e soci non
possono essere che impazziti: infatti al World Of Amiga '98 hanno fatto un
annuncio: hanno annunciato la prossima creazione di @{b}un vero nuovo Amiga@{ub}!!!
Questa è la notizia che molti aspettavano da tempo, ma c'è un però, e che però:
questo nuovo "Amiga" @{b}sarà in realtà un PC@{ub}... prima di lanciarvi a mandare
un'E-mail di @{"porconi" link help 10} o qualcosa di simile, lasciate che vi spieghi: questa nuova
super-macchina sarà qualcosa di innovativo, ma come già avrete capito, sarà
basata su un'@{b}architettura x86, ossia un PIKKIO MALEDETTO!!!@{ub} Quello che ha
lasciato esterrefatti tutti gli amighisti è stata la naturalezza con cui AI per
prima cosa non ha assolutamente supportato le grandi iniziative di Phase 5 per
quanto riguarda il PowerPC, da tutti considerato il processore ideale per il
futuro, e in secondo luogo con questa sparata che, oltre a essere una
dichiarazione ufficiale, è la più grande cagnata che potessero farci dopo anni
di lotta per difendere l'"@{b}Intel Outside@{ub}"!!! E' chiaro che non si possono fare
conclusioni troppo affrettate, anche se in effetti tutto ciò sembra veramente
un'assurdità: in effetti lo staff di AI ha precisato che @{b}lo sviluppo della nuova
tecnologia avviene su x86@{ub}, mentre @{b}le macchine definitive non saranno basate su
Intel@{ub}: questa affermazione chiaramente non è chiara e quindi prima di fare
valutazioni errate, aspetto di sentire ulteriori sviluppi, anche se rimango
confuso e amareggiato: mi sembrerebbe incredibile che gli amighisti
intransigenti come me si trovassero a doversi ribellare addirittura alla casa
madre, "solo" perchè ci vuole propinare un futuro targato Intel!!!
Mah, aspettiamo e vediamo, e intanto supportiamo @{b}Phase 5-Haage & Partner@{ub}
(l'altro "polo", sostenitore del PPC) che sicuramente hanno le idee più chiare e
hanno capito veramente cosa vogliamo!!!

@{b}---------------------------------------------------------------------------------
--------------------!!!!!!!!!!INTEL OUTSIDE PLEASE!!!!!!!!!!---------------------
---------------------------------------------------------------------------------

Non buttiamo via così quello che abbiamo fatto in più di 10 anni!!!

                                                                Kle
                                                          "Il desperado"@{ub}
@endnode

@node se_ne_vanno "GENTE CHE VIENE, GENTE CHE SE NE VA..............."

@{b} -------------------------------CHI CI LASCIA...--------------------------------@{ub}

La vita da amighisti spesso è dura, specie per chi ci guadagna sopra, o
perlomeno cerca di farlo: purtroppo dobbiamo spesso salutare qualcuno che ci
lascia, segnato da esperienze negative, o semplicemente dalla voglia di
guadagnare facilmente e di più: salutiamo quindi gli @{b}Invictus Team@{ub}, che
fuggono dopo l'esperienza stranamente negativa di Onescapee, e anche i @{b}Black
Blade Design@{ub}, che non hanno di fatto annunciato di abbandonare l'Amy, ma dopo
l'ottimo The Shadow Of The 3rd Moon intendono produrre giochi anche per PC, Mac
e altri sistemi alternativi, il che al 90% significa: niente più Amiga!!!
A questi si aggiungono anche i @{b}Deimos Design@{ub}, che senza nemmeno aver completato
il loro @{b}Maim & Mangle@{ub} hanno dato forfait e si sono buttati a pesce sul Pikkio...
pusillanimi!!!!!

Che dire...peccato!!!

Vorrei però puntualizzare una cosa: come si potrà ristabilire un mercato
redditizio, per quanto riguarda i giochi, se nessuno si dà da fare per
ristabilire una rete di vendita umana, specie qui in Italia??? Io Onescapee o
TSOTTM li avrei comprati a occhi chiusi, ma potendolo fare in modo degno di tal
nome, non ordinandoli a centinaia di chilometri di distanza, se non addirittura
all'estero!!!

                                                            @{b}Kle@{ub}
@endnode

@node enforce "ENFORCE - IL PRIMO CONCORRENTE DI QUAKE!!!!!!!!!!!"

@{b} -----------------------------------ENFORCE-------------------------------------@{ub}

Un nuovo giocone alla Doom (o meglio alla Quake) è in fase di produzione per
mano degli @{b}Insanity@{ub}, un gruppo di programmatori della Repubblica Ceca: il motore
3D sembra veramente all'avanguardia, oltre che più veloce di quello di Quake
(per Amy): saranno presenti anche elementi RPG che daranno maggiore profondità
al gioco: le foto sono veramente belle, e ricordano sia Quake che The Killing
Grounds.

Per ora non si sà molto di più, ma state in campana!!! E se proprio non sapete
aspettare, tenetevi pronti per Genetic Species!!!

                                                            @{b}Kle@{ub}
@endnode

@node shell_e_basta "DATEMI UNA SHELL...CHE COSA CI VUOI FARE???"

@{b} -------------------------------VIVERE DI SHELL---------------------------------
                            ---------BY KLE---------@{ub}

La shell è una componente di AmigaDos che da sempre rappresenta una delle
maggiori differenze rispetto ai concorrenti principali (PC e Mac): infatti il
Pikkio, escludendo l'MS-DOS (?!), non ha nessun genere di shell, almeno per
default: non escludo che esistano dei programmi appositi, ma non credo: lo
stesso vale per il Maccointosc, che di shell non ne vuole sapere: invece noi
amighisti abbiamo questo utile strumento che, sfruttato in tutta la sua potenza,
può veramente diventare pratico e utile, sebbene sulle prime possa sembrare
scomodo rispetto al normale uso "finestre+puntatore": vediamo come si può creare
un ambiente shell veramente funzionale.

Voi direte: <<Cominciamo ad aprire una shell!!!>>: vi sembrerà strano, ma non
basta!!! In effetti la shell standard è ben poco pratica, e manca di alcune
funzioni molto importanti ad un uso produttivo: è necessario procurarsi del
software in grado di estendere le funzionalità della shell "di base": esistono
sostanzialmente due tipi di tale software: i sostituti quasi completi (come
ZShell, X-Shell ecc.) e i "vitaminizzanti" (dove regna sovrano il famosissimo
KingCON): ebbene, noi analizzeremo la prima possibilità, per l'esattezza ci
riferiremo a @{b}ZShell 2.7@{ub}, un'ottima shell "nuova di zecca", creata da Paul Hayter
e Martin Gierich, che permette un sacco di cose interessanti in più ristetto a
quella "liscia": forse la mia scelta è un pò controcorrente, dato che va molto
più di moda KingCON, ma mi trovo talmente bene con ZShell, che non mai deciso di
provare il suddetto KingCON: c'è da dire che comunque gli scopi prefissi dai due
programmi sono gli stessi, e in molti casi quello che si dice per uno vale,
univocamente o quasi, anche per l'altro.

Ma bando alle cispole e veniamo al sodo: procuratevi ZShell (l'avevamo incluso
nella TAM 1, ammesso che siate riusciti ad averla): la prima cosa da sistemare è
l'aspetto generale della finestra: cliccate (una volta) sull'icona @{b}"ZShell"@{ub} e
selezionate @{b}"Informazioni"@{ub} dal menù @{b}"Icone"@{ub}: il primo tooltype, @{b}SCRIPT=...@{ub},
permette di specificare uno script da eseguire all'avvio: ci soffermeremo su
questo in seguito: per ora limitiamoci a dare un titolo alla finestra della
nostra super-shell: cliccate sul secondo tooltype, @{b}WINDOW=CON:...@{ub} e, fra il
quarto ed il quinto slash ("/") potete digitare il titolo che più vi aggrada:
ora, avviando la ZShell con un doppio clic sulla sua icona, potrete vedere il
vostro titolo sulla barra superiore: per ora può bastare. Se volete modificare
la posizione in cui si deve aprire la finestra, sperimentate con i parametri
@{b}XPOS@{ub} e @{b}YPOS@{ub}: ricordatevi di eliminare le parentesi, per renderli attivi!!!

Bene, ora abbiamo la nostra bella ZShell, col bel titolo e che si apre nella
sua bella posizione: vediamo però cosa ci offre in più: la cosa che
probabilmente risulta più utile e pratica è il "completamento del nome": per
digitare il nome di un file nella linea di comando, non bisogna necessariamente
scriverlo per intero: basta digitarne le prime lettere e premere il tasto @{b}TAB@{ub}
(quello sopra CTRL): ZShell completerà automaticamente il nome: se ci sono più
files con le stesse iniziali che avete digitato, saranno elencati e potrete
scegliere quello voluto, semplicemente digitando la lettera che lo distingue
dagli altri e ripremendo TAB, oppure premendolo un pò di volte, passando in
rassegna i vari nomi: così se per esempio avete un file che si chiama
"Ciccioformaggio_cips_e_sgnaps" non soffrirete a scrivere tutto il nome: davvero
geniale!!! Ricordo quando il mio professore di informatica, descrivendo Unix
(che implementa questa funzione), era tutto esaltato nel farci vedere come
MAGICAMENTE si completava il nome premendo TAB: e io ridevo dato che lo facevo
già da tempo sul mio piccolo Amy: piccole soddisfazioni...

Bene, dopo la piccola parentesi di vita vissuta vediamo un'altra caratteristica
fondamentale della nostra shell: gli @{b}ALIAS@{ub}: infatti è possibile assegnare dei
nomi "simbolici" a dei comandi altrimenti noiosi da scrivere: ad esempio:

 alias tammami "multiview work:mags/TAM_3/tam3.guide"

Digitando "tammami" seguito da invio eseguirò "multiview work:mags/TAM_3/
tam3.guide", senza doverlo scrivere per intero: ovviamente gli alias possono
riferirsi anche ai semplici comandi, per esempio:

 alias mv multiview

Ora potrò usare "mv work:mags/TAM_3/tam3.guide", anzichè scrivere tutte le volte
"multiview".

E' utile scrivere tutti gli alias in un file di testo da eseguire ad ogni avvio
di ZShell: basta specificare tale file nel tooltype @{b}SCRIPT=...@{ub}, citato in
precedenza: ad ogni avvio di ZShell avremo così tutti i nostri alias pronti da
usare: ad esempio se ho salvato il mio file di avvio come work:alias.txt, dovrò
inserire:

 SCRIPT=work:alias.txt

Gli alias possono essere molto utili per lanciare programmi con diversi
parametri, anche se è necessario fare delle considerazioni: come avrete notato
se a volte usate la shell, la maggioranza dei programmi, una volta lanciati, si
"attaccano" alla shell, che non può più essere utilizzata fino a quando tale
programma non viene chiuso: questo può essere evitato usando il comando @{b}"run"@{ub}:
se per esempio lancio multiview in modo "liscio", ovvero:

 multiview <file>

Non potrò più utilizzare la shell, a meno di chiudere la finestra di multiview:
se invece uso:

 run >NIL: multiview <file>

Multiview si "staccherà" dalla shell!!! Bisogna però fare attenzione ad una
cosa: ZShell implementa alcuni comandi comuni (run, assign, dir ecc.) in modo
custom, ovvero ha i suoi comandi che, pur essendo analoghi a quelli soliti
(almeno come scopo) sono diversi e hanno i loro difetti: guardacaso "run" è uno
dei comandi peggio implementati, dato che non permette il passaggio di parametri
del programma da "runnare": vale a dire che se imposto un alias in questo modo:

 alias tammami "run >NIL: multiview work:mags/TAM_3/tam3.guide"

Eseguendo "tammami" sarà lanciato multiview, ma verrà ignorato il suo parametro
(work:mags/TAM_3/tam3.guide): se invece specifichiamo l'uso del "run" di
sistema, quello che si trova nella directory C:, ovvero:

 alias tammami "c:run >NIL: multiview work:mags/TAM_3/tam3.guide"

Avremo il risultato voluto, ovvero l'apertura della TAM 3 da parte di multiview,
che oltretutto si "staccherà" dalla nostra shell!!! Spettacolo!!!

In generale è sempre meglio usare il run normale, in quanto quello di ZShell è
veramente infelice: per comodità si può impostare un alias del tipo:

 alias rn "c:run >NIL:"

Così si potrà usare "rn" invece di "run", e si userà sempre il run "bello"!!!
Come avrete capito è sempre meglio lanciare i programmi con il run, in modo da
staccarli dalla shell.

Converrete con me che, con poco sforzo, è possibile creare un ambiente shell in
grado di farci quasi dimenticare l'uso "point & click" del Workbench: l'unico
"sforzo" richiesto è quello di ricordarsi gli alias, ma una volta fatta
l'abitudine vi verrà tutto naturale.

Un'altra caratteristica utile di ZShell è il @{b}"review-buffer"@{ub}: è infatti
possibile utilizzare un buffer per memorizzare il testo che "passa" sulla shell,
ovvero quello che viene visualizzato in modo standard nella finestra: basta
utilizzare il comando:

 rewiew <grandezza del buffer in bytes>

ad esempio "review 10000" si imposterà un buffer di 10000 bytes: è utile
inserire il comando nello script di avvio, insieme agli alias: a questo punto,
appena si vuole vedere il contenuto del buffer, basta premere @{b}SHIFT-TAB@{ub} e
scorrere il buffer con i tasti freccia: per tornare al prompt basta premere @{b}ESC@{ub}:
questa funzione è molto utile ad esempio per vedere con calma il risultato di
lunghi DIR o comandi simili, che generano un output troppo veloce e lungo da
leggere "al volo": il buffer è ovviamente limitato alla dimensione indicata e
quindi potrete vedere solo una parte dell'output: c'è da dire che non tutti i
programmi e i comandi generano un output "rivisitabile": non conosco l'esatta
ragione di questo, anche se si tratta solo di rari casi, quindi è un male
minore.

Saprete che per "tornare indietro" alla directory superiore è necessario
scrivere @{b}"cd /"@{ub}, scomodissimo!!! Conviene impostare un'alias del tipo:

 alias cd.. cd /

In modo da utilizzare il pratico @{b}"cd.."@{ub} di MS-DOSsiana memoria.

Alcuni comandi di ZShell possono essere usati in modo "ricorsivo", ovvero
entrando in tutte le sottodirectory: quelli più utili in questo caso sono @{b}DIR@{ub} e
@{b}DELETE@{ub} (che con gli appositi alias possono diventare D e DEL), che possono
essere utilizzati in modo ricorsivo aggiungendo @{b}"-r"@{ub}, ad esempio:

 dir work:mags    -> dir di work:mags
 dir -r work:mags -> dir di work:mags e di tutte le sue sottodirectory

 delete work:cips    -> cancello un file
 delete -r work:mags -> cancello una directory e tutto il suo contenuto

Per comodità si possono creare due alias del tipo:

 alias dirtree "dir -r"
 alias deltree "delete -r" (sempre l'MS-DOS in mezzo ai piedi!!!)

Naturalmente "dirtree" e "deltree" sono solo degli esempi: io ad esempio uso
"dt" e "delt".

Un'altra opzione utilissima si può aggiungere tramite un piccolo programma
esterno: infatti spesso capita di trovare dei files, magari senza estensione, di
cui non si conosce il tipo: tramite un programmino chiamato @{b}CFX@{ub} (ma ce ne
saranno sicuramente altri) è possibile vedere in un batter d'occhio il tipo dei
files che vi interessano, e CFX ne conosce un sacco, anche i più assurdi:
procuratevelo e create un'alias del tipo:

 alias cfx "c:cfx/cfx"

Quindi potrete digitare @{b}"cfx"@{ub} per avere il tipo di tutti i files della dir
corrente, oppure specificare i files voluti: leggete la documentazione di CFX
per le varie opzioni.

Per finire vi ricordo un'altra utile caratteristica della shell di Amiga (anche
quella standard): potete selezionare parte del contenuto con il mouse e copiarlo
nella clipboard premendo @{b}Amiga Destro-C@{ub}, per poi incollarlo dove volete, oppure
copiare del testo da un'altro programma e incollarlo nella shell con @{b}Amiga
Destro-V@{ub}!!! Ricordate però che se copiate del testo su più linee, incollandolo
nella shell i caratteri di fine linea saranno interpretati come pressione del
tasto Invio!!!

Naturalmente le possibilità sono infinite e utilizzando altri programmi esterni
è possibile estendere ancora di più le capacità della nostra shell, roba da far
invidia a Unix!!! Il segreto è sempre quello: provare e sperimentare!!!

Bene, è tutto, buon shellamento!!!

                                                            @{b}Kle@{ub}
@endnode

@node inst_ciddo "INSTALLIAMO UN BEL CIDDO TUTTI INSIEME!!!!!"

@{b} -------------------INSTALLAZIONE DI UN CD-ROM SCSI SU A1200--------------------
                            ---------BY KLE---------@{ub}

Questo articolo vuole essere, senza molte pretese, una piccola guida
all'installazione di un @{b}CD-ROM SCSI@{ub} su Amy 1200, tramite la porta @{b}PCMCIA@{ub},
sicuramente una delle soluzioni più diffuse per quanto riguarda il nostro caro
gioiellino, specie dall'uscita della famosa interfaccia @{b}Squirrel@{ub}, che ha avuto
un grande successo ed ha "aperto le porte" allo SCSI a molti possessori di Amiga
1200/600: io stesso ho adottato questa soluzione e quindi mi appresto ad
illustrarvi il, seppur semplice, procedimento, che può sempre riservare qualche
perplessità o difficoltà (come è successo a me...ehm...).

Prima di cominciare voglio espletare un dubbio che mi assilla da anni ed anni:
come ciaps si pronuncia PCMCIA?????????? Io prima dicevo "picìemmecìia", ma poi
pensandoci credevo che "pisìemsìaiei" fosse più "professionaleeeeeeee", anche se
mi sembrava troppo da "secchione": poi ho sentito qualcuno che diceva
"picìemcìa", ma non sono ancora convinto...meglio che mi rassegni: era solo per
dimostrare la mia preparazione sull'argomento... (?!)

Dopo il solito delirio (vi abituerete) passiamo alle cose serie: vediamo cosa ci
serve se vogliamo attaccare questo benedetto ciddo-rom al nostro 1200 (normale,
non towerizzato, anche se va di moda):

-il @{b}ciddo-rom@{ub} (incredibilmente), ovvero il lettore in sè, ovviamente SCSI (es.,
come nel mio caso, un Power CD-ROM da Power Computing)

-un @{b}case autoalimentato@{ub} per, appunto, alimentare il CD-ROM, che comunque al 99%
viene fornito con il lettore, già montato e pronto, a meno che non si richieda
esplicitamente il contrario, e il relativo cavo di alimentazione.

-@{b}l'interfaccia SCSI@{ub} (es. Squirrel)

-@{b}terminatori SCSI@{ub} (non sempre necessari, come vedremo in seguito)

-il @{b}software di gestione SCSI@{ub} (fornito, si spera, con l'interfaccia)

-un pò di @{b}pazienza@{ub} (non troppa)

Dovrebbe bastare...

Come ho già detto, con tutta probabilità il lettore sarà già inserito nel case
esterno autoalimentato: in caso contrario leggete le istruzioni (ehm...) e
inseritelo voi, anche se non è un'operazione da niente e, come ho già detto, se
il vostro fornitore ha un pò di buon cuore, lo farà per voi: si tratta solo di
collegare il cavo di alimentazione alla presa sul retro e quindi alla presa di
corrente (interessante!!!): ma aspettate ad accendere!!! Prima occorre collegare
l'interfaccia, e per prima cosa occorre inserire la stessa nella porta PCMCIA o
come diablo si pronuncia: questa operazione va fatta con cura, specie se non
siete "smanettoni" (come me, del resto) e ci tenete a non fare disastri: vi dò
un consiglio: fatevi venire un pizzico di curiosità tecnica e date un'occhiata
all'interno della porta PCMCIA: noterete i vari piedini che, detto fra noi, sono
moooolto delicati e potrebbero benissimo essere piegati o rotti: io stesso ne ho
trovato uno piegato e quindi, se fosse il vostro caso, cercate, con @{b}MOLTA@{ub}
cautela, di raddrizzarlo/i, usando qualche arnese abbastanza piccolo: non è
un'operazione impossibile, ma è meglio essere @{b}MOLTO@{ub} prudenti e al massimo
lasciare tutto com'è: è risaputo che, seppur mancante di certi piedini, la
PCMCIA funziona lo stesso: vedete voi!!! Se, come dovrebbe essere, tutti i
piedini sono al loro posto, si può procedere all'inserimento dell'interfaccia,
che in genere ha una forma rettangolare, con una parte sottile e una più grossa:
indovinate quale và inserita nell'Amiga???

    -----------------------------------|  ---\  |----------------------
    | INTERFACCIA      ----------------|  ---/     PORTA PCMCIA
    |                  |                        |----------------------
    --------------------

Inserite lentamente l'interfaccia nella porta, fino a quando notate di aver
raggiunto i piedini: a questo punto, con una pressione leggera ma decisa,
spingete ancora, magari muovendo leggermente l'interfaccia a destra e a
sinistra, per facilitare l'inserimento: essendo inserita fino in fondo, la parte
sottile dell'interfaccia dovrebbe sporgere dall'Amiga per circa un centimetro:
occhio, parlo sempre della Squirrel, anche se non penso che ci possano essere
grosse differenze di dimensione!!!

Ora basta collegare il grosso connettore presente al capo del cavo dell'
interfaccia ad uno dei due connettori presenti sul retro del lettore:
precedentemente abbiamo parlato di @{b}terminatori@{ub}: ebbene, la terminazione è
una particolarità dello SCSI: infatti le periferiche connesse tramite SCSI
costituiscono una @{b}"catena"@{ub}, che in qualche modo deve "finire" con un'apposita
terminazione: nei casi peggiori si tratta di una specie di "tappo" da connettere
all'altra presa SCSI, mentre nei casi migliori il CD-ROM è @{b}auto-terminante@{ub} (come
nel caso del Power CD-ROM), per cui se è alla fine della catena o è l'unico
elemento della stessa, funge anche da terminatore: very goodful and wellful!!!

Un'ultima cosa: dovete sapere che ogni elemento di una catena SCSI ha in numero
di identificazione, detto @{b}SCSI ID@{ub}, che varia da 1 a 7 (o da 0 a 6... OPS!!! Non
mi ricordo, comunque sono 7, quante storie!!!): leggete sul manuale quale è l'ID
"preferito" del vostro lettore: il Power CD-ROM va impostato preferibilmente
sull'ID 3, ma, essendo (per ora) l'unico elemento della catena SCSI, qualsiasi
ID dovrebbe andare bene: ma come si cambia tale ID: ebbene, qualche anno fa si
usavano dei noiosi @{b}jumper@{ub}, ma il progresso avanza e quindi sul retro del lettore
dovreste trovare una finestrella con un numero e un qualche meccanismo per
cambiarlo (tasti, rotelle, mulini ad acqua...), per cui si tratta di un gioco da
ragazzi!!!

Bene, cavi collegati, catene terminate, ID impostati: è tutto a posto!!!
Proviamo ad accendere il CD-ROM e quindi l'Amiga: se non ci sono cortocircuiti
(esagera!!!) o altre stranezze, per ora non dovreste notare alcuna differenza
nel boot del vostro Amy: per fare in modo che si "accorga" della presenza del
lettore, occorre installare il software!!! Per fortuna non siamo su un WC e
quindi per "installare il software" non intendiamo sconvolgere la configurazione
del sistema, ma installare pochi ma necessari files: in particolare serve un
"dispositivo" o @{b}"device"@{ub}, che possiamo intendere come il driver del controller
SCSI, un @{b}file di mount@{ub} che serve a fare riconoscere il CD al Workbench e un @{b}file
system@{ub} per CD-ROM (come il celeberrimo @{b}AmiCDFS@{ub}): se avete acquistato la Squirrel
o un altro controller degno di tale nome, avrete sicuramente uno o più dischetti
con il software, provvisto di un installer, possibilmente quello standard di
Amiga. Anche se, come ho già detto, l'installazione non è nulla di
trascendentale, è bene assicurasi di quello che "combina" l'installer, in modo
da riuscire a ripristinare la situazione precedente nel caso che qualcosa vada
storto: quindi è sempre meglio attivare il @{b}"log file"@{ub} dell'installazione, in
modo da poter controllare in seguito (se necessario) le operazioni effettuate.

Bene, quindi l'installazione dovrebbe fornirci:

-un @{b}device@{ub} (es. SquirrelSCSI.device) da mettere in @{b}DEVS:@{ub}

-un @{b}file di mount@{ub} (CD0) da mettere in @{b}DEVS:DOSDrivers@{ub} (o in Storage, a seconda
se lo volete eseguire ad ogni avvio o "a mano" solo quando volete)

-un @{b}file system@{ub} (es. AmiCDFS) da mettere in @{b}L:@{ub}

Probabilmente nell'installazione del software del ciddo sarà compreso anche un
file system, anche se è consigliabile installare proprio AmiCDFS, che è
Shareware (quindi lo trovate su Aminet o sui CD delle riviste) ed è uno dei
migliori, se non il migliore: una volta procurato e installato avremo quindi
quanto detto sopra, e resta da configurare il file di mount: ma cos'è codesto
file??? Si tratta di un semplice file di testo (chiamato CD0) che contiene le
informazioni necessarie per riconoscere e configurare correttamente il CD-ROM:
in generale si presenta così, anche se questo è quello specifico di AmiCDFS che
aggiunge il campo "control" (in genere non presente):

/* $VER: CD0 2.15 (24.04.96)
 *
 * CD-ROM filesystem mount entry
 */

Device         = squirrelscsi.device
Unit           = 3
FileSystem     = L:AmiCDFS
Flags          = 0
BlocksPerTrack = 32
BlockSize      = 2048
Reserved       = 0
LowCyl         = 0
HighCyl        = 11000
Surfaces       = 1
Buffers        = 64
BufMemType     = 1
Mask           = 0x7fffffff
GlobVec        = -1
Priority       = 10
DosType        = 0x43444653
StackSize      = 600
Mount          = 1

Control        = "BL=8 FB=32"

/* Control field template:
 *
 * LC=LOWERCASE/S,TD=TRACKDISK/S,
 * BL=BUFFERLINES/K/N,FB=FILEBUFFERS/K/N,
 * DC=DISKCHANGE/K/N,TDC=TDCHANGE/S,
 * TOSHIBA/S,OLDMODE/S
 */

Sostanzialmente si tratta di editare i prmi tre campi:

-come @{b}"device"@{ub} va messo il @{b}nome del device@{ub} (spettacolo!!!)

-come @{b}"unit"@{ub} va messo lo @{b}SCSI ID@{ub} del CD-ROM

-come @{b}"filesystem"@{ub} il @{b}nome del file che rappresenta il file system@{ub}

Il resto non va toccato se non in casi particolari: vi consiglio comunque di
leggere bene la documentazione del vostro hardware e software per essere sicuri
di tutto.

Bene, se tutto è stato fatto correttamente, con un doppio clic sull'icona CD0
dovreste vedere il CD-ROM che "reagisce" e si avvia, e il dispositivo CD0
dovrebbe aggiungersi a quelli presenti: provate a digitare @{b}"info"@{ub} da shell e
vedete se è presente nella lista: se tutto fila liscio, provate a inserire un CD
e, se appare la sua icona, siamo a posto!!! Naturalmente, se avete messo l'icona
CD0 in Devs:DOSDrivers, il mount sarà lanciato automaticamente ad ogni avvio
(rallentando un pò il boot): se invece la mettete da un'altra parte
(preferibilmente in Storage, ma solo per questione di "ordine"), potrete
lanciarla voi quando vi serve (consigliabile a chi ha poca RAM).

Ora potrete accedere al dispositivo @{b}CD0:@{ub} (anche da shell) come a qualsiasi altro
(DF0:, DH0:, RAM: ecc.), anche se solo in lettura, ovviamente!!!

Inoltre se installate AmiCDFS non avrete nessun problema (o quasi) fra CD-ROM,
CD Audio, ibridi, incroci e mutazioni genetiche!!!

Questo è quanto: spero di essere stato utile a qualcuno, e mi scuso per la
spiegazione un pò "maccheronica", anche se dopotutto non c'è niente di
particolarmente difficile, quindi...
In ogni caso ricordate che non mi assumo responsabilità per Amiga violentati
brutalmente con un'interfaccia SCSI o altri atti di violenza e/o distruzione!!!

Se qualcuno avesse comunque dubbi o problemi, mi @{"contatti" link contributi 13} pure e io sarò al suo
servizio!!!

Bene, buona continuazione!!!

                                                            @{b}Kle@{ub}
@endnode

@node elp "VI PREGO AIUTATEMI!!!!! PREGATE PER ME!!!!!!!!!!!!!!!!!!!!!"

@{b} ---------------------------------I NEED HELP!!!--------------------------------@{ub}

Eh sì, fra @{b}45 ore@{ub} ho l'esame orale di maturità (Panta l'ha avuto circa 20 ore
fa) e sono qui a scrivere per la TAM!!!

Che grande notizia eh!!!!!

A parte gli scherzi: @{b}SAMBADI ELP MI PLIZ!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!@{ub}

                                                            @{b}Kle@{ub}

Uff...è andata!!! E adesso chi ci ferma più???

@endnode

@node olocoso "OLOFIGHT - IL PICCHIADURO DEL 2000"

@{b} -------------------------OLOFIGHT - WORK IN PROGRESS---------------------------@{ub}

Continua il lavoro dei @{b}The Real Ologram@{ub}, che ormai da un anno lavorano al loro
@{b}Olofight@{ub}, il grande picchiaduro che promette @{b}3000@{ub} colori su schermo e una
caterva di notevoli caratteristiche tecniche e giocose, fra cui:

-@{b}10@{ub} personaggi, ognuno con @{b}400@{ub} frame di animazione e @{b}10@{ub} mosse speciali
-animazioni a @{b}25 fps@{ub}
-parallasse "totale" (pavimento prospettico compreso!)
-fondali animati
-musica che segue l'andamento dell'azione
-ombre realistiche
-possibilità di giocare su @{b}Internet@{ub} (!!!)

...e molto ancora!!! Assolutamente eccellente!!!

Ultimamente è reperibile su Aminet il primo demo giocabile, che ho provato e che
lascia davvero ben presagire: l'unico appunto che mi sento di fare, per ora,
riguarda il design di alcuni personaggi, piuttosto scarno e decisamente non in
linea con la bellezza dei fondali.

Comunque sia questo gioco farà sicuramente una gran bella figura!!!

Buon lavoro ai The Real Ologram e speriamo di vedere presto il gioco finito: si
parla di Dicembre, quindi calma e pazienza...

Colgo l'occasione anche per dire due parole sullo sviluppo di altri due gioconi
made in Italy, ovvero @{b}Virtual GP@{ub} e @{b}Traumazero@{ub}: il primo, ovvero l'ex Alien F1,
procede soprattutto per quanto riguarda la conversione digitale delle piste
reali: anche la grafica è stata ulteriormente migliorata (almeno "a occhio") ed
è stata introdotta la possibilità di giocare in alta risoluzione!!!

Traumazero dal canto suo è ormai un capolavoro annunciato, pare che comunque i
programmatori abbiano inserito ulteriori tocchi di classe, che rendono questo
gioco ancora più spettacolare: davvero grandioso!!!

                                                            @{b}Kle@{ub}
@endnode

@node cdidz "VOGLIO UN SACCO DI CDID!!! E SUBITO!!!"

@{b} --------------------DO YOU WANT A CDID? YES, OF COURSE!!!----------------------
                            ---------BY KLE---------@{ub}

Per prima cosa una nota per chi non conosce i CDID: con l'avvento dei CD-ROM su
Amiga si sono diffusi diversi programmi per il playing dei normali CD audio:
naturalmente col tempo si crearono diverse caratteristiche interessanti, come
quella di poter digitare e salvare i nomi delle canzoni di ogni CD, in modo che,
all'inserimento, il programma potesse "riconoscere" il CD e visualizzare i
titoli: per facilitare la gestione e lo scambio di questi titoli si è creato uno
standard chiamato appunto CDID: in pratica un CDID è un piccolo file di testo
che come nome ha tutte le informazioni necessarie ad identificare univocamente
un CD, mentre al suo interno è strutturato in questo modo:

Nome dell'artista o del gruppo
Titolo del CD
Titolo traccia 1
Titolo traccia 2
Titolo traccia 3
...e così via per tutte le tracce

Per comodità il nome dell'artista e il titolo del CD sono inseriti anche nel
commento del file.

In pratica se possedete il CDID di un certo CD, se vi capiterà un giorno di
inserirlo nel vostro lettore, nella GUI del vostro player preferito appariranno
automaticamente tutti i titoli, a patto che tale player supporti i CDID: fra
questi ci sono @{b}ACDPlay@{ub}, @{b}OptyCDPlayer@{ub}, @{b}MegaCDPlayer@{ub} e altri: dovete solo copiare
i CDID nella directory dove il programma li "pesca" e il gioco è fatto!!!

Esiste già una vastissima collezione di CDID su Aminet (anzi, forse ce ne sono
svariate), ma i nostri si riferiscono a CD di musica @{b}rock/metal@{ub}, che più
difficilmente si trovano nelle collezioni più diffuse: i titoli sono:

Angra - Holy Land
Cromwell - Burning Banners
HammerFall - Glory To The Brave
Joe Satriani - Crystal Planet
Narnia - Awakening
Rhapsody - Legendary Tales
Stratovarius - Episode
The Offspring - Ixnay On The Hombre
Theatre Of Tragedy - Aégis
Theatre Of Tragedy - Theatre Of Tragedy
Theatre Of Tragedy - Velvet Darkness They Fear

C'è solo un appunto da fare: alcuni programmi visualizzano distintamente il nome
dell'artista ed il titolo del CD, e quindi salvano i CDID come descritto sopra:
altri invece (come MegaCDPlayer) mettono entranbe le informazioni in un unico
campo, e quindi lasciano vuota la prima riga, mettendo nome+titolo insieme nella
seconda linea, ovvero:

                                             <-- LINEA VUOTA!!!
Nome dell'artista o del gruppo+Titolo del CD
Titolo traccia 1
Titolo traccia 2
Titolo traccia 3
...

Quindi, prima di copiare i CDID, controllate quale formato "preferisce" il
player che usate, e quindi:

@{"Premete qui per copiare i CDID nel formato standard!!!" system "execute data/script/copy_cdid_1"}
@{"Premete qui per copiare i CDID nel formato speciale!!!" system "execute data/script/copy_cdid_2"}

Alla prossima con altri CIDDI-ID!!!

                                                            @{b}Kle@{ub}
@endnode

@node concludendo "LE ULTIME PAROLE (ANCHE SE NON FAMOSE)..."

@{b} --------------------------------IN CONCLUSIONE---------------------------------@{ub}

Bene, anche questo numero di TAM è concluso: siamo molto contenti di aver
ricevuto un certo "feedback"dai lettori, fra cui alcuni (incluso l'immenso Deep
Red) disposti a collaborare con noi per rendere TAM ancora migliore: noi
speriamo sempre di poter migliorare per continuare a contribuire alla vivacità
della "scena" amighista italiana, che è sempre fervente anche se in "background"
rispetto alla realtà informatica comune, che tutti sappiamo come è messa...WC+
Micromorbida e nulla più: ma ci siamo noi amighisti a fare la differenza, siamo
gli unici su cui la suddetta Microsoffice non ha ancora messo le mani (GIU' LE
ZAMPE!!!) e continueremo a lottare per la nostra causa, rimanendo superiori
all'ignoranza dettata dall'era del consumismo e dei "nuovi monopoli"!!!

Basta con le frasi da filosofo, meglio che vi saluti e vi rimandi l'appuntamento
al prossimo numero e a @{b}Pianeta Amiga '98@{ub} (26/27 settembre), anche se
probabilmente quando leggerete queste righe sarà già troppo tardi.

Ciao a tutti, alla prossima e @{b}CONTINUATE A LOTTARE PER AMIGA@{ub}!!!

                                                            @{b}Kle@{ub}

@endnode

@node golem "VOGLIAMO THE GOLEM...VOGLIAMO THE GOLEM...VOGLIAMO..."

@{b} ------------------------CHE FINE HA FATTO IL GOLEM???--------------------------
                            ---------BY KLE---------@{ub}

L'incredibile giocone degli @{b}Underground Software@{ub}, che sembrava dovesse uscire "a
breve" già l'anno scorso (era stato mostrato anche a Pianeta Amiga), è invece
rimasto in sospeso per tutto questo tempo: ora sembra che sia finalmente
imminente (stavolta sul serio!) la pubblicazione (su @{b}2 ciddi@{ub}!!!) di questo gioco
che sicuramente farà ancora bella mostra di sè a Pianeta Amiga '98, prima di
arrivare sui monitor degli amighisti di tutto il mondo: è bello sapere che
durante l'anno il mitico Leonardo...no...Lorenzo Di Cap...Leonardo C...@{b}Lorenzo
Caprio@{ub} (mica Leonardo Di Capra, cosa pensavate, che si fosse messo a programmare
su Amy fra un Titanic e l'altro???) non ha interrotto lo sviluppo dell'@{b}XFL@{ub}, ma
l'ha ulteriormente migliorato: ora si chiama @{b}PowerMovie@{ub} ed è già pronto a fare
impallidire QuickTime, MPEG e tutta la marmaglia!!!

Comunque sia presto dovremmo avere questo Golem pubblicato, come sembra, da
Power Computing: speriamo che non ci facciano aspettare un altro anno!!! Se vedo
morire un progetto così vado in pellegrinaggio-digiuno-meditazione-isolamento
sul vulcano Cracatoa!!!

                                                            @{b}Kle@{ub}

@endnode

@node corso_cg "IL SUPER CORSO DI COMPUTER GRAFICA"

@{b} --------------------------CORSO DI COMPUTER GRAFICA----------------------------
                           ---------BY PANTA---------@{ub}

Il tutorial che andremo a realizzare quest'oggi è molto semplice ed immediato,
ma di sicuro impatto in quanto nostro primo approccio all'animazione. Tutto
quello che andremo ad animare oggi è una semplice stella (no, non ancora una
massa di gas incandescenti, ma una semplicissima ed infantile stellina con un
numero a piacere di punte). Il perchè della stella è molto semplice:
apparentemente sembrerebbe piuttosto complesso modellare correttamente un
poligono con tali caratteristiche, in realtà con un paio di piccoli trucchetti
(che sono ormai ovvi per gli utenti più esperti, ma possono non esserlo per i
neofiti) la modelleremo in un paio di colpi di "maus". Lo stesso trucchetto,
leggeremente rielaborato lo utilizzeremo in fondo al tutorial per realizzarne
una versione realmente tridimensionale.

L'animazione in quanto tale è ridotta all'osso e consiste nella semplice
applicazione di un "effetto speciale" di quelli forniti di serie con l'imagine.
Questi effetti vanno da i più semplici (come quello di oggi, dedicato alla
rotazione di un oggetto) a quelli più complessi capaci di gestire sistemi
particellari e/o esplosioni.

@{b}           TUTORIAL N°3: ANIMAZIONE DI UNA STELLA CHE RUOTA SU STESSA

                  REALIZZAZIONE DELL'OGGETTO DA DETAIL EDITOR@{ub}

Per creare la stella che successivamente animeremo, partiamo da un @{b}disco@{ub} di 5
sezioni (ma anche 200...), che si ottiene premendo @{b}PRM (Object/Add/Primitive)@{ub} e
selezionando @{b}"disk"@{ub} dal requester che appare (ricordandosi di inserire il numero
delle sezioni e premere invio).

Selezioniamo ora i profili esterni (vedi l'@{"approfondimento" link approfondimiento}) in modalità @{b}Pick
Edges@{ub} e invochiamo il comando @{b}Fracture@{ub} (dal menu object), che andrà a spezzare
in due ogni profilo selezionato. Andiamo in modalità @{b}Pick Points@{ub} e selezioniamo
i punti appena creatisi (tenendo premuto shift per la multi-selection) (rivedi
l'@{"approfondimento" link approfondimiento}) ed eseguiamo un ridimensionamento sugli assi x e z (pulsante
@{b}Sc@{ub} disattivando l'asse y). La figura sullo schermo inizia così a prendere una
forma stellata nella vista @{b}Front@{ub}. Sempre in modalità @{b}Pick Points@{ub} prendiamo il
punto centrale e lo muoviamo sull'asse y in modo che nella vista prospettica si
veda un oggetto dotato di spessore. Ora non ci resta che fare la copia speculare
dell'oggetto appena creato per avere ciò che desideravamo. Per far ciò, torniamo
in modalità @{b}Pick Objects@{ub}, copiamo l'oggetto nella clipboard (@{b}Object/Copy@{ub}) e dal
requester @{b}Transformation@{ub} (che appare premendo il bottone @{b}Trns@{ub} o selezionando
@{b}Transformation@{ub} dal menu @{b}Objects@{ub}) attiviamo la casella @{b}Scale@{ub} ed inseriamo il
valore -1 nella casella corrispondente all'asse y. Incolliamo l'oggetto nella
clipboard ,li selezioniamo entrambi e con la funzione @{b}Merge@{ub} (dal menu @{b}Object@{ub}) li
uniamo.

Gli attributi sceglieteveli pure da soli, ma ricordatevi di @{b}disattivare il Phong
Shading@{ub} (una stella sta bene se appuntita!).

                     @{b}ANIMAZIONE MEDIANTE L'AGGIUNTA DI F/X@{ub}

Quello che ci accingiamo a fare è l'impostazione del movimento del nostro
oggetto. Per far ciò, agiremo essenzialmente in @{b}Action Editor@{ub}, di cui abbiamo
già utilizzato la sezione Globals nel tutorial delle tre sfere. Andiamo in
@{b}Project Editor@{ub} e creiamo un nuovo progetto (@{b}project-new@{ub}) ed andiamo quindi in
@{b}Stage editor@{ub}, carichiamo l'oggetto, impostiamo le luci (@{b}Add-Ligthsource@{ub}) e la
telecamera, ricordandosi di tracciarla sull'oggetto (per maggiori indicazioni
consigliamo di rifarsi a quanto è esposto nella sezione "Impostazione della
scena e resa finale" del tutorial precedente). Salviamo i cambiamenti (dal menu
@{b}Project@{ub} selezioniamo @{b}Save changes@{ub}) ed andiamo in @{b}Action Editor@{ub}. Da qui
clicchiamo sulla casella in alto a sinistra per impostare il numero totale di
fotogrammi che andranno a comporre la sequenza finale (60 vanno benissimo).
Estendiamo la barra @{b}Actor@{ub} del nostro oggetto e delle varie luci fino all'ultimo
fotogramma (per far ciò clicchiamo sulla barra (quadratino) actor già esistente
e impostiamo 60 come end frame). Premiamo dunque il pulsante @{b}Add@{ub} dalla
pulsantiera in basso e facciamo click sulla casella corrispondente al primo
fotogramma della banda @{b}"f/x 1"@{ub} corrispondente all'oggetto che vogliamo ruotare
(che si chiamerà @{b}disk@{ub}). Comparirà un browser da cui dobbiamo scegliere l'effetto
da applicare all'oggetto. Selezioniamo @{b}rotate2@{ub} (dalla directory @{b}imagine\effects@{ub})
e premiamo Ok; quindi inseriamo 360 nella casella che ci chiede di quanti gradi
dovrà essere la rotazione e selezioniamo un asse qualsiasi (per esempio x) e 60
come "end frame". La stessa operazione va ripetuta con @{b}"f/x 2"@{ub}, impostando però
un altro asse (per esempio y). Ricordiamoci di salvare i cambiamenti con save
changes.

Le barre della action editor vengono comunemente chiamate @{b}timelines@{ub} (linee
temporali) ed indicano la presenza o meno di un certo oggetto o di un certo
effetto speciale in un determinato fotogramma; se impostassimo come durata
totale dell'animazione 60 fotogrammi, ma lasciassimo le barre attore dei vari
oggetti estese solo al primo fotogramma, avremmo il nostro oggetto con tanto di
effetto speciale solo al primo fotogramma e negli altri la scena sarebbe vuota.
La presenza della barra actor in un certo fotogramma indica la presenza
dell'oggetto, ed è quindi necessaria, mentre non è necessaria la presenza delle
altre barre (@{b}position/alignment/size@{ub}), in quanto il programma farà riferimento
alla posizione, allineamento e dimensione del primo fotogramma, o comunque
dell'ultimo frame in cui esse sono state indicate (naturalmente almeno in un
frame esse devono essere presenti). In questo caso quindi, dove posizione e
dimensione restano costanti, e l'allineamento viene modificato dall'effetto,
possiamo fare a meno di estenderle fino all'ultimo frame.

                            @{b}PREVIEW DELL'ANIMAZIONE@{ub}

Prima di passare al render dell'animazione possiamo ottenerne un @{b}preview@{ub}, ovvero
una rappresentazione veloce in modalità @{b}Wireframe@{ub} o @{b}Solid@{ub} direttamente nella
vista prospettica. Ciò può esser utile se vogliamo avere un'idea di quale sarà
il risultato finale e apportare eventuali modifiche senza dover attendere che
venga realizzato un render completo. Andiamo in @{b}Stage editor@{ub} e, inserendo un
qualsiasi valore in @{b}"frame number"@{ub} otterremo la visualizzazione di quel
fotogramma. Selezionando @{b}Solid@{ub} (dal menu @{b}display@{ub}) ed utilizzando la funzione
@{b}Animation-Make@{ub}, verrà calcolato il preview. Il significato di @{b}Start Frame@{ub} e @{b}End
Frame@{ub} è facilmente intuibile, mentre @{b}step@{ub} indica di quanti fotogrammi dovrà
"saltare" nell'animazione: se inserissimo 2 come valore di step verrebbero
renderizzati un fotogramma si e uno no e così via, mentre valori negativi
farebbero procedere l'animazione in senso inverso. Nel nostro caso impostiamo
1,56,1 e premiamo Invio. Terminata la fase di calcolo, possiamo vedere
l'animazione con @{b}play loop@{ub} (loop vuol dire ciclo). Dal requester che appare
possiamo impostare la velocità o vedere singolarmente alcuni fotogrammi. Se
l'animazione sembra procedere a scatti anche alla massima velocità, conviene
tornare in action editor ed aumentare il numero di fotogrammi; viceversa, se
alla massima velocità l'animazione è fluida ma troppo lenta, tale numero va
ridotto.

                                 @{b}RENDER FINALE@{ub}

Il preview, oltre ad essere una rappresentazione semplificata, non può essere
salvato su disco. Pertanto se vogliamo conservare l'animazione finale e non solo
il progetto dobbiamo eseguire un render completo. Andiamo in @{b}Project Editor@{ub} e
creiamo un nuovo sottoprogetto e impostiamo i consueti parametri di risoluzione
ed aspetto. E' bene notare, però, che nelle animazioni non conviene spingersi
troppo in alto come risoluzione per non cadere nell'inconveniente di avere
filmati che procedono a scatti. In questo caso può andar bene una risoluzione di
640x512 o 320x256 punti (se non avete una scheda grafica ed un Amiga molto
potente è meglio rimanere su quella più bassa che comunque con un po' di
antialias va benissimo). Rispetto alle immagini statiche, nell'animazione va
scelto anche il tipo di file che a formare la nostra sequenza e selezioneremo
@{b}ANIM@{ub}. Con @{b}range@{ub} selezioniamo 1,56,1 (come era stato fatto per il preview) e
premiamo il tasto @{b}Generate@{ub}. Selezioniamo @{b}"Lock to 1st"@{ub} ad indicare che la
palette dell'animazione sarà uguale a quella del primo fotogramma.

Una volta calcolati tutti i frames potete andare a comporre l'animazione
all'interno dell'Imagine con il comando @{b}"Make"@{ub} e poi playarla con gli appositi
comandi, o meglio comporla con un programma esterno come @{b}Rend24@{ub}, @{b}MainActor
Broadcast@{ub} o uno di quelli dedicati alle schede video; con programmi esterni
potrete decidere se ridurre la risoluzione, il numero di colori o fotogrammi a
vostro godimento. Se costruirete l'animazione all'interno dell'Imagine, senza
scheda grafica è perlomeno consigliato il play da un programma esterno. Il file
sarà collocato nella directory @{b}"imagine\nome_progetto.imp\nome
sottoprogetto.pix"@{ub} e si chiamerà @{b}"anim"@{ub}.

                                   @{b}APPENDICE@{ub}

Per modellare stelle realmente in 3D, quindi derivanti da un solido e non da un
poligono (per intenderci partendo da una sfera e non da un disco) e quindi
ottenere oggetti molto complessi (simili a dei ricci di mare) possiamo procedere
nel seguente modo. Aggiungiamo una sfera poligonale di 4x4 sezioni. Seguendo il
trucco relativo alla selezione automatica dei punti nuovi spiegato
nell'@{"approfondimento" link approfondimiento} (in questo caso assolutamente necessario) selezioniamo
tutti i punti, vediamo quanti sono, fratturiamo tutte le facce (stavolta essendo
un solido non i profili), selezioniamo con @{b}"Pick Range"@{ub} i punti nuovi (partendo
dal numero originale di punti+1) e li scaliamo ottenendo interessantissimi
effetti. Naturalmente aumentando il numero di sezioni della sfera originale,
aumenteremo il numero di punte della stella e la complessità dell'oggetto.

Alla prossima!!!

                                                         @{b}Panta@{ub}

Alt! Cogliamo l'occasione per ricordarvi che il concorso lanciato con la TAM 2
(quello del Mech) è ancora valido!!! Non avete letto la TAM 2?!? Male:
fiondatevi subito su Aminet alla directory docs/mags e scaricate tam2.lha!!!

@endnode

@node approfondimiento "APPROFONDIMENTO SULLA SELEZIONE DI PUNTI E PROFILI"

@{b} -------------------------------APPROFONDIMENTO---------------------------------@{ub}

Un modo un po' più macchinoso per selezionare i profili esterni da
fratturare è quello di:

-selezionare tutte le facce in modalità @{b}Pick Faces@{ub}
-renderle un sottogruppo (@{b}Functions/Make/Make Subgroup@{ub})
-Andare in modalità @{b}Pick Edges@{ub} ed invocare il comando @{b}"Pick/Pick Subgroup"@{ub},
selezionare il nostro sottogruppo e scegliere come profili i @{b}"Boundary Edges"@{ub}
(profili esterni).

Tutto ciò è sicuramente più macchinoso per poligoni con poche sezioni, ma
assolutamente più comodo per poligoni con molte facce. Ma la vera macchinosità,
per poligoni con molti lati (se per esempio volessimo fare una stella a 100
punte!) non è tanto selezionare i profili esterni da fratturare quanto
selezionare i nuovi punti che si creano dopo la frattura dei profili. Per fare
questo è sufficiente procedere in tal modo:

-andare in modalità @{b}Pick Points@{ub} prima di effettuare la frattura, invocare il
comando @{b}"Pick/Pick All"@{ub} e tenendo premuto il tasto shift osservare sulla barra
in alto il numero indicato in parte a "multi, ". Questo è il numero totale dei
punti del nostro oggetto, e lo appuntiamo da qualche parte.
-effettuiamo quindi tutte le nostre operazioni di frattura ed invochiamo il
comando @{b}"Pick/Pick Range"@{ub}; la sintassi di questo comando è "punto iniziale,
finale, passo". Se per esempio scriveremo "1,20,2" verranno selezionati, tra i
primi 20 punti, un punto si ed uno no. Siccome il nostro scopo è quello di
selezionare i punti creatisi dopo la frattura, scriveremo nel requester: "N°
punti originali+1, N° punti attuali,1"; una volta selezionati codesti punti,
possiamo procedere al ridimensionamento.

@endnode

@node cloanto "LE NEWS DALLA CLOANTO MI PIACCIONO DAVVERO TANTO!!!"

@{b} ---------------------------------CLOANTO NEWS----------------------------------
                            ---------BY KLE---------@{ub}

La Cloanto è sempre rimasta vicina all'Amiga, anche nei momenti di "panico", e
si è sempre imposta come una delle migliori software house italiane e non: dopo
l'impegno profuso nel lancio di Amiga Forever, ovvero l'evoluzione commerciale
del famoso UAE, la Cloanto si ributta nel "vero" software Amiga, e pare quindi
prossima l'uscita di @{b}Personal Paint 8@{ub}, la nuova grandiosa versione del mitico
programma di paint, ormai diventato lo standard, come degno erede di Deluxe
Paint: non conosco ancora le caratteristiche innovative di questa nuova
versione, ma c'è ragione di aspettarsi grandi cose!!!

Oltre a PPaint la Cloanto ha annunciato un nuovo e rivoluzionario programma, di
cui però non si hanno ancora notizie precise, anche se probabilmente mentre
leggerete si sarà chiarito tutto.

                                                            @{b}Kle@{ub}

@endnode

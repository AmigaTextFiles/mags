<HTML>
<HEAD>
<TITLE>
Amiga STORM => broj 8 => AS Special => Mama, I wanna be a coder!
</TITLE>
</HEAD>
<BODY background="../gfx/back.gif" link="red" vlink="red">

<table border="0" cellspacing="0" cellpadding="2" align="left" width="100%" cols="3" rows="3">
<tr><td width="115" align="center" valign="top">

<p align="center">
<img src="../gfx/as_8.gif" alt="8" width="106" height="106">
<br>
<br>
<img src="../gfx/najave.gif" alt="NAJAVE" border="0" width="106" height="19"><br><br>
<center>
<a href="theprophet.html">The Prophet</a><br>
<a href="magewars.html">Mage Wars</a><br>
<a href="darkage.html">NEX - Dark Age</a><br>
<a href="scavangers.html">Scavangers</a><br>
<a href="seaside.html">Seaside</a>
</center>
<br>
<img src="../gfx/novosti.gif" alt="NOVOSTI" border="0" width="106" height="19"><br><br>
<center>
<a href="blueblacksolution.html">Blue Black Solution</a></br>
<a href="superfrog.html">Superfrog</a><br>
<a href="themegagripii.html">The Megagrip II</a><br>
<a href="epicmarketing.html">Epic Marketing</a><br>
<a href="crystalsoftware.html">Crystal Software</a><br>
<a href="dafelbloodline.html">Dafel Bloodline</a><br>
<a href="napalmupdate.html">Update: Napalm</a><br>
<a href="theworldfoundry.html">The World Foundry</a><br>
<a href="phase5.html">phase5</a><br>
<a href="settlersii.html">Settlers II</a><br>
<a href="delsydsoftware.html">Delsyd Software</a><br>
<a href="amiga.html">Update: Amiga</a><br>
<a href="joyride.html">JoyRide</a><br>
</center>
<br>
<img src="../gfx/opisi.gif" alt="OPISI" border="0" width="106" height="19"><br><br>
<center>
<a href="napalm.html">Napalm</a><br>
<a href="amigaamp.html">Amiga AMP v2.1</a><br>
<a href="starbirds.html">Starbirds</a><br>
<a href="strangers.html">The Strangers</a><br>
<a href="tinytroops.html">Tiny Troops</a><br>
<a href="ioblix.html">IOBlix</a><br>
<a href="virtualgp.html">VGP Demo</a>
</center>
<br>
<img src="../gfx/interview.gif" alt="INTERVIEW" border="0" width="106" height="19"><br><br>
<center>
<a href="lambdateam.html">Lambda Team</a><br>
<a href="delsydint.html">Delsyd Software</a>
</center>
<br>
<img src="../gfx/zznicnews.gif" alt="ZZNIC NEWS" border="0" width="106" height="19"><br><br>
<center>
<a href="303tracker.html">303tracker</a>
</center>
<br>
<img src="../gfx/demoscope.gif" alt="DEMO SCOPE" border="0" width="106" height="19"><br><br>
<center>
<a href="wildlife.html">Wildlife</a><br>
<a href="1000%.html">1000%</a>
</center>
<br>
<img src="../gfx/asspecial.gif" alt="AS SPECIAL" border="0" width="106" height="19"><br><br>
<center>
<a href="pisma.html">Pisma èitatelja</a><br>
<a href="ce_4.html">Mala ¹kola C-a</a><br>
<a href="xrage.html">www.xrage.com</a><br>
<a href="amiga99.html">Amiga99 Show</a><br>
<a href="asm1.html">Mama, I wanna be a coder!</a><br>
<a href="otvorenapisma.html">Otvorena pisma (??)</a><br>
<a href="nagradnaigra.html">Nagradna igra</a><br>
<a href="dosta.html">DOSTA !!!!</a>
</center>
<br>
<img src="../gfx/ashelp.gif" alt="AS HELP" border="0" width="106" height="19"><br><br>
<center>
<a href="dungeonmaster.html">Dungeon Master</a>
</center>
</p>
<td width="450" valign="top">
<p>
<br>
<table width="100%" border="1">
<tr>
<td bgcolor="#b43100" colspan="2">
<font size="+2" color="#ffffff"><b><em>
<center>
Mama, I wanna be a coder!
</center>
</em></b></font>
</td>
</tr>
</table>
<p>
<br>
<br>
</p>

<P>	Evo  jo¹  jedne  programerski  orijentirane serije èlanaka, pored male
¹kole  C-a.   Za  razliku  od  nje, ova æe se baviti programiranjem u
najni¾em programskom  jeziku,  ma¹inskom jeziku tj.  ma¹incu.  Prvih nekoliko tekstova
æe  biti namijenjeno totalnim poèetnicima.  Takoðer, htio bih da napomenem da
æe naglasak  u  ne¹to  kasnijim  tekstovima  biti stavljen na programiranje raznih
stvari  primjenjivih  u  demoima,  kao  ¹to  su  mod-player rutine, c2p, razni
efekti, optimizacije, itd.
<P>	Pa da poènemo...


<H3>PROCESOR</H3>
<P>	Amiga  u  sebi  sadr¾i Motorolin procesor iz serije MC680x0, a u novije
vrijeme  i  PPC60x.   Mi  æemo  se  baviti samo programiranjem 68k procesora i to
<B>MC68020</B> ili novijim, jer su prethodni procesori ipak zastarjeli.
<P>  Motorole  MC68k  imaju  ¹esnaest  32-bitnih  registara,  od  toga je osam
namijenjeno  za smije¹tanje i manipulaciju podacima, dok je ostatak zadu¾en za rad
s  memorijskim  adresama.  Data registri, tj.  registri za podatke su registri
koji  nose  nazive  od  <B>D0</B>  do <B>D7</B>, dok su adresni od <B>A0</B> do
<B>A7</B>, pri tom treba imati na umu da se A7 koristi kao sistemski pokazivaè
steka,  pa  se najèe¹ce ne koristi u druge svrhe.  A7 se mo¾e oznaèiti i kao
SP  (eng.   steck pointer).  Inaèe, stek je dio memorije koji je rezerviran za
privremeno  smije¹tanje  podataka.  <P> Pored ovih ¹esnaest registara postoji i
<B>PC</B>  (eng.  program counter) registar koji uvijek sadr¾i adresu instrukcije
koja  tek  treba  da se izvr¹i.  I poslijednji <B>SR</B> (eng.  status register)
sadr¾i  bitove  koji  oznaèavaju  "stanje"  u  kojem  se procesor nalazi.  To su
takozvani  flegovi  (eng.   flegs), uz pomoæ kojih npr.  procesor "zna" da jedan
registar  sadr¾i  veæi  broj  od drugog, da je broj u nekom registru negativan,
itd.   <P>  Za¹to  su registri uopæe potrebni?  Razlog le¾i u tome ¹to kada
procesor  pristupa  odreðenom podatku u memoriji, potrebno je neko vrijeme da bi
se  to  dogodilo.   To  vrijeme  je  uslovljeno fizièkom distancom, ¹to æe
reæi registri  se nalaze u samom procesoru tako da æe on znatno br¾e raditi s njima
nego s podacima iz memorije.


<H3>BROJNI SISTEMI</H3>
<P>  68k  procesor ne mora da obraðuje uvijek svih 32 bita nekog registra.
Mo¾e da  radi i samo u prvih 16 bitova ili samo u privih 8.  Inaèe, kao ¹to znate,
8  bitova  èini  <B>BAJT</B>,  dok  16  èini  <B>WORD</B>,  a  32  bita  daju
<B>LONGWORD</B>.   <P>  Kod  programiranja  u  ma¹incu,  najèe¹ce se koriste
binarni  i  heksadecimalni  brojni  sistemi.   Ako  ih  usporedimo s decimalnim
sistemom,  primjetiti æemo  da  je  praktièno jedina razlika u osnovi, koja je kod
decimalnog  10.   Kod  binarnog  sistema osnova je 2, a kod heksadecimalnog 16.
<P>  Da  pojednostavimo,  zamislite da imamo brojaè posjeæenosti nekog sajta na
internetu  i on izgleda ovako 0000.  Ako za njega koristimo decimalni sistem, u
kome  imamo  cifre  od 0 do 9, nakon stanja brojaèa 0009 dolazi 0010.  Sto se
ustvari  dogodilo?   Prva  znamenka (uvijek gledamo sa desne strane) je pre¹la svoj
maksimum (9) i opet se vratila na svoju poèetnu vrijednost (0), a znamenka desno od
nje  se  uvecala za jedan.  Na isti naèin funkcionira i binarni sistem, s tom
razlikom  ¹to  postoje samo dvije znamenke 0 i 1.  Znaèi poèetni brojaè pokazuje
0000,  zatim  0001,  pa  onda  0010, 0011, 0100, 0101, 0110, 0111, 1000, i tako
dalje.   <P> Da bi ste broj iz binarnog sistema pretvorili u decimalni potrebno
je  da  znate  da  setovani  bitovi,  odnosno bitovi èija je vrijednost 1, imaju
vrijednost  2^n,  gdjee  je n redni broj bita, s tim da je prvi bit sa desne strane
nulti  bit  tj.   n=0.   Dobijene  vrijednosti  setovanih  bitova se zbroje i eto
decimalnog  broja.  <P> Na primjer %01010110 = 2^1+2^2+2^4+2^6 = 2+4+16+64 = 86.
Ispred  binarnog  broja  se  nalazi  znak  za posto (%) kojim se u asembleru
oznaèava  binarni  broj.   <P>  Analogno ovim sistemima, heksadecimalni brojni
sistem  ima  16 znamenki, to su brojevi od 0 do 9 i slova od A do F.  Tako je A u
heksadecimalnom sistemu isto ¹to i 10 u decimalnom a F isto ¹to i 15.  Ovakvi
brojevi   se   obilje¾avaju   predznakom   dolara   ($).    Npr.    $73F26D36  =
%110110100110110 = 1945267510.
	


<H3>ASEMBLER</H3>
<P>	Odavno   je  pro¹lo  vrijeme,  kada  su  se  ma¹inski  programi  pisali
uno¹enjem  kodova  instrukcija.   Zatim  su  se  pojavili monitori, programi u
kojima  se  moglo  pisati  samo direktno na odreðenim memorijskim adresama.  A
nakon  njih  pojavili  su  se  asembleri,  programi  koji  slu¾e za prevoðenje
tekstualnog  sors  koda  (eng.   source code) u procesoru razumljiv, ma¹inski,
jezik.   Ali  i  dan  danas  su  se zadr¾ali nazivi kodiranje i programiranje u
ma¹incu,  ali  se  oni  ne  odnose  na  gore  pomenute  situacije veæ na rad u
asembleru.
<P>	Jedna  od  rijetkih  sfera  u kojoj Amiga danas ne oskudijeva su asembleri.
Neki  od  njih  su  <b>PhxAss</b>,  <b>StormASM</b>,  <b>AsmOne</b>,  <b>AsmPro</b>,...  Koji asembler
æete koristiti  je  va¹a  odluka,  samo  nemojte  koristiti  stare  asemblere tipa
<b>MasterSeka</b>  i  sl.   Ja koristim <b>AsmPro</b> koji je nezvanièni
nasljednik <b>AsmOne-a</b>.
On  u sebi ima integriran veoma dobar editor, disasembler, debugger i jo¹ neke
veoma  fine  stvarèice,  ali  nemojte  pomisliti  da ¾elim da utièem na va¹u
odluku.  Ni sluèajno.  =) (<b>PhxAss</b> i <b>AsmPro</b> mozete naci i na aminetu.) Najbolje
bi  bilo  da  dok  pratite  ove tekstove ipak koristite <b>AsmPro</b> jer on prikazuje
sadr¾aje registara nakon izvr¹enja programa.
<P>	Evo i kratkog opisa <b>AsmPro-a (AsmOne)</b>.  Sve opcije se nalaze u menijima
ali svakoj mo¾ete pristupiti i sa tastature.  Na samom startu, program vas pita
koliko  memorije  ¾elite  da  alocirate  i  kog  tipa  treba  da bude memorija.
Izaberite PUBLIC memoriju.  Onda æe asembler koristiti FAST memoriju ukoliko je
imate,  ako  ne  onda  ÈIP.   Da ste odabrali ÈIP i FAST tip onda bi asembler
koristio   iskljuèivo   tu  vrstu  memorije.   ABSOLUTE  æe  koristiti  fiksne
memorijske  adrese,  zato  ovo  izbjegavajte,  bar  za  sada.   Sa ESC ulazite i
izlazite  iz  editora i komandne linije.  U njoj mo¾ete zadavati naredbe npr.
<b>A</b> (asembliranje), <b>R</b> (ucitavane sorsa), <b>W</b> (snimanje), itd.  Znaèi, kada napi¹ete
program,  preðite  u komandnu liniju, otkucajte A (i enter naravno), ako je sve
uredu,  sa  J  startujete  program  s poèetka sorsa, ili sa J [ime] od
labele. Nakon  zavr¹etka  va¹eg programa pojaviti æe se spisak svih registara i
njihovih vrijednosti.

<H3>INSTRUKCIJE</H3>
<P>	Na¹  prvi  program  neæe  biti  HelloWorld  jer  bi  takav primjer imao
isuvi¹e  kompliciran source za poèetak.  Zato kreæemo s neèim jednostavnijim,
npr.  zbrajanje dva broja.

<P>
<PRE>
*********** amigastorm! *********************

start				;labela
	move.l	#$10,d0		;stavlja $10 u D0
	move.l	#$20,d1		;stavlja $20 u D1
	add.l	d0,d1		;zbraja sadr¾aj D0 sa D1, rezultat ide u D1
	rts			;izlazi iz programa

*********************************************
</PRE>

<p>	Asemblirajte i startujte program. Dobiti æete:

<P>
<PRE>
D0:  00000010 00000030 ....
A0:  .........
.....
</PRE>

<P>	Rezultat zbrajanje je $30 i nalazi se u registru D1.
<P>	Kao  ¹to  ste mogli da primjetite komentari se pi¹u iza zvjezdice (*) i
iza  znaka  toèka-zarez  (;).  "start" je labela, s koje ste mogli startovati
va¹  program sa "J start" ali to nije potrebno jer se "start" nalazi na poèetku
sourcea.
<P>  Kao  ¹to  sama  rijeè ka¾e, <B>MOVE</B> (eng.  pomjeri) "pomjera" broj $10 u
registar  D0.   Taraba  (#) ispred $10 oznaèava da treba staviti ba¹ vrijednost
koja se nalazi iza nje u D0.  Isto tako u D1 se stavlja vrijednost $20.  Zatim se
one  instrukcijom  <B>ADD.L D0,D1</B> zbrajaju i to tako da se sadr¾aj registra
D0  dodaje  sadr¾aju  registra D1.  <P><B> U ma¹incu je uvijek destinacija, onaj
registar  koji se nalazi sa desne strane zareza!</B> <P> Znaci ADD.L D0,D1 bi u
BASIC-u  bilo  D1=D1+D0.   I  na kraju instrukcija RTS (ReTurn from Subroutine)
zavr¹ava  izvr¹avanje  programa.  <P> Sufiks .L na instrukcijama oznaèava da
se  radi  o LONGWORD-ovima (32 bita), kada bismo pisali sasvim pravilno trebali
bi da napi¹emo:  <PRE>
	move.l #$00000010,d0
	move.l #$00000020,d1
</PRE>	
<P>	Ali  nule  se  ignoriraju kao i u decimalnom sistemu.  Treba da znate da, 
iako ste napisali samo $20, asembler preostali dio desno popunjava nulama.

<P>
<PRE>
*************** jo¹ jedan primjer **********

start
	move.l	#$ffffffff,d0	     ;stavlja $ffffffff u D0
	clr.l	d1		           ;bri¹e D1
	clr.l	d2		           ;bri¹e D2
	clr.l	d3		           ;bri¹e D3
	move.w	d0,d1		   ;premje¹ta word iz D0 u D1
	move.b	d0,d2		    ;kopira bajt iz D0 u D2
	rts			            ;kraj

*********************************************
</PRE>

<P>	A ¹to  se ovdje dogodilo?  Stavljamo $ffffffff u D0 bri¹emo D1,D2 i D3 i
premje¹tamo samo WORD iz D0 u D1 i samo BAJT iz D0 u D2.  Registri daju:

<PRE>
D0: ffffffff 0000ffff 000000ff 00000000 ...
</PRE>

<P>	Nije  bilo  te¹ko  zakljuèiti  da  sufiksi .W i .B oznaèavaju WORD i
BAJT.  Ukoliko se sufiks ne navede, podrzumijeva se da su u pitanju WORDovi!
<P>	<B>CLR</B>  sluzi za brisanje data registara, i moze da brise
cijeli registar(.l) ili samo word(.w) ili samo bajt(.b) u registru.

<P>
<PRE>	
*********** another one **********************

start
	clr.l	d0		;bri¹e D0
	clr.l	d1		;D1
	clr.l	d2		;D2
	clr.l	d3		;D3
	clr.l	d4		;i D4
	lea	text,a0		;adresu "text" upisuje u A0
	lea	textend,a1	;adresu "textend" upisuje u A1
	move.b	(a0),d0		;sa adrese "text" kopira bajt u D0, slovo "s"
	add.l	#1,a0		;uveæava adresu iz A0 za 1
	move.b	(a0),d1		;sa adrese "text+1" kopira bajt u D1, slovo "t"
	sub.l	#1,a1		;umanjuje adresu iz A1 za 1
	move.b	(a1),d4		;sa adrese "textend-1" kopira bajt u D4, "m"
	sub.l	#1,a1		;umanjuje adresu u A1 za 1
	move.b	(a1),d3		;kopira bajt, "r"
	sub.l	#1,a1		;-1
	move.b	(a1),d2		;"o"
	rts			;kraj


text	dc.b	'storm'		;alocira 5 bajtova i puni ih
textend

************************************************
</PRE>

<P>  Ovdje  se  pojavljaju dvije nove instrukcije: <B>LEA</B> i <B>SUB</B>.  LEA je
instrukcija koja smje¹ta neku adresu u adresni registar, u ovom sluèaju adresu
"text"  u  A0,  i  "textend"  u A1.  <P> SUB je suprotna instrukcija ADD-u, tj.
oduzimanje.   <P> "text" i "textend" su labele koje oznaèavaju adrese na kojim
poèinje  i  zavr¹ava se rijeè "storm".  <P> Sa <B>DC.B</B> direktno u memoriju
upisujemo  podatke  i  to  bajtove.  U ovom sluèaju to je 5 bajtova koji èine
rijeè "storm".  Oni su smje¹teni od adrese "text" do adrese "textend".  Kao ¹to
vidite, adrese nisu apsolutne, tj.  nisu izra¾ene u brojevima.  Zamislite da su
adrese brojevi, kao na primjer:

<P>
<PRE>
$504342 dc.b 'storm'	;text
$504347    		;textend
</PRE>
	
<P>	Mozda  æe se nakon asembliranja "storm" ba¹ naæi na ovim adresama, ali
ovakav source nikad neæete vidjeti.
<P>	Za¹to?   Pa ima nekoliko razloga.  Prvo, ne radimo u monitoru, u njemu
biste  morali  da  na  adresu  $504342  upi¹ete  "storm", a gore gdje pi¹e LEA
textend,A1  biste  upisali  LEA  $504347,A1.  I ¹ta da promijenite rijeè u "amiga storm". 
Onda biste morali da mijenjate i LEA $504347,A1 u LEA $50434D,A1 jer je
rijeè  du¾a  za 6 bajtova.  I zamislite da treba isto uraditi na vi¹e od jednog
mjesta.   U sluèaju da se jo¹ ne¹to nalazilo iza $504347, sve to biste morali
ruèno da pomijerate.  Ali u asembleru, se neæete time optereæivati.
<P>	Druga  stvar je u tome ¹to Amiga programe nikada ne uèitava na fiksne
adrese.   Kako biste startali dva programa ako bi se jedan uèitao u memoriji
od adrese $100 do $500, a drugi od $200 do $500.  Drugi bi skoro preklopio prvi
¹to  bi  najvjerovatnije  izazvalo  pad sistema.  Zbog toga koristimo relativno
adresiranje.

<P>	Sto ustvari ovaj program radi?
<P>	Bri¹e  registre  od  D0  do D4 (CLR.L).  Adresu "text" stavlja u A0, a
"textend"  u  A1  (LEA).   Kopira  bajt  sa  adrese koja je smej¹tena u A0 u D0
(MOVE.B).   Uveæava  adresu  iz  A0  za  1 (ADD.L).  Kopira ponovo bajt koji se
nalazi  na  adresi, smje¹tenoj  u A0, u D1, tj.  kopira bajt sa adrese "text+1"
(MOVE.B).   Oduzima 1 od adrese u A1 (SUB.l) i zatim kopira bajt sa adrese koja
je  smje¹tena  u A1 na D4 (MOVE.B).  Ponovo oduzima 1, i kopira opet.  I sve to
jo¹ jednom.
<P>	Instrukcija  MOVE.B  (A0),D0 prenosi bajt koji se nalazi na adresi koja
je  smje¹tena  u  A0,  na  D0.   Ako se u A0 nalazi adresa $3747 onda æete u D0
dobiti bajt koji nalazi na toj adresi.  Isto biste postigli i instrukcijom MOVE
$3747,D0.

<P>	Dobijeni registri nakon zavr¹etka programa izgledaju ovako:

<P>
<PRE>
D0: 00000073 00000074 0000006F 00000072 0000006D ....
</PRE>

<P>	To  su  ascii  kodovi  rijeèi "storm", ¹to mo¾ete provjeriti iz komandne
linije u AsmPro-u sa "?  $73" itd.
<P>	Ako  ¾elite  da  vidite  koliko  je  dugaèak  va¹ asemblirani program
otkucajte "?  textend-start" .


<P>	Do  sada  smo  koristili  nekoliko  varijacija  instrukcije MOVE, pa da
vidimo jo¹ neke moguce.


<H3>MOVE</H3>

<P>Instrukcija MOVE X,Y u su¹tini premje¹ta sadr¾aj iz X u Y, a X i Y mogu biti:

<P>[legenda:]
<PRE>
An    - adresni registar (A0-A7)
Dn    - data registar (D0-D7)
[ea]  - adresa ili registar
#n    - apsolutna vrijednost
Reg   - registar (ili An ili Dn)
</PRE>

<P>Evo nekih moguæih naèina adresiranja, ali se neæemo zamarati njihovim imenima:

<DL>
<DT>
<H5>MOVE	#n,[ea]</H5>
</DT>
<DD>
stavlja vrijednost n na adresni ili data registar
<DD>
<P>
MOVE.B #10,D7 ;stavlja 10 u D7
<DD>
MOVE.L #$ffff2,A3 ;stavlja $ffff2 u A3
<DD>
MOVE.W #255,255 ;stavlja 255 na adresu 255
</DL>

<DL>
<DT>
<H5>MOVE	[ea],[ea]</H5>
</DT>
<DD> stavlja vrijednost prvog registra ili adrese na drugi
			  registar ili adresu
<DD>
<P>
MOVE.L A0,D5 ;stavlja vrijednost A0 u D5 
<DD>
MOVE.L D1,A1 ;vrijednost D1 u A1
<DD>
MOVE.B D0,D1 ;premje¹ta bajt iz D0 u D1
</DL>

<DL>
<DT>
<h5>MOVE	#n,(An)</h5>
</DT>
<DD>
stavlja vrijednost n na adresu koja je u registru An
<DD>
<P>
LEA $40,A6 
<DD>
MOVE.B #$F,(A6) ;stavlja $f na adresu $40
<DD>
<p>
				
LEA "text",A0
<DD>
MOVE.L #$7ff7f7f7,(A0) ;stavlja $7ff7f7f7 na "text"
</DL>


<DL>
<DT>
<h5>MOVE	[ea],(An)</h5>
</DT>
<DD>stavlja vrijednost sa adrese ili  vrijednost registra na 
		  adresu iz adresnog registra An
<DD>
<P>
 LEA  start,A2
<DD>
				MOVE.B adr,(A2) ;na adresu "start" kopira bajt
				sa adrese "adr"
<DD>
<P>
				LEA  adr,A6
<DD>
				MOVE #$7f,D4
<DD>
        MOVE D4, (A6) ;stavlja $7f na adresu "adr"	
</DL>


<DL>
<DT>
<H5>MOVE	#n,(An)+</H5>
</DT>
<DD>stavlja vrijednost n na adresu koja je u registru An
			  i tek onda uveæava adresu u An za 4(.L), 2(.W) i 1(.B)
<DD>
<P>
 LEA buf,A0
<DD>
				MOVE.L #$12345678,(A0)+
<DD>				MOVE.L #$9abcdef0,(A0)+ ;na dva longworda stavlja
				broj $123456789abcdef0 poèev¹i od adrese "buf"
</DL>

<DL>
<DT>
<H5>MOVE	[ea],(An)+</H5>
</DT>
<DD>stavlja adresu ili vrijednost registra na adresu iz adresnog
			  registra An i tek onda uveæava adresu u An za 4(.L), 2(.W)
			  ili 1(.B) 
<DD>
<P>  LEA source,A0
<DD>				LEA dest,A1
<DD>				MOVE.B (A0),(A1)+ ;kopira bajt sa adrese "source"
				na adresu "dest" i uveæava A1 za 1
</DL>

<DL>
<DT>
<H5>MOVE	(An)+,[ea]</H5>
</DT>
<DD>
<P>
èita vrijednost s adrese sadr¾ane u An, uveæava An u
			  zavisnosti od sufiksa i smje¹ta proèitanu vrijednost u
			  [ea]
<DD>
<P>
 LEA rnd,A0 
<DD>				MOVE.B (A0)+,A0 ;kopira bajt sa adrese "rnd", 
				uveæava A0 za 1 i stavlja bajt u A0
<DD>
<P>
				LEA x,A4
<DD>				LEA y,A2
<DD>				MOVE.L (A4)+,(A2)+ 
<DD>				MOVE.l (A4),(A2) ;kopira 2 longworda sa adrese "x"
				na adresu "y"
</DL>

<DL>
<DT>
<H5>MOVE	#n/[ea]/-(An) , -(An)/-(An)/[ea]</H5>
</DT>
<DD>
analogno prethodnim sluèajevima s tim ¹to do
			  oduzimanja dolazi PRIJE nego ¹to se proèita podatak sa
			  adrese
<DD>
<P>
  LEA bljak,A7
<DD>				MOVE.B #2,-(A7) ;stavlja bajt 2 na adresu "bljak-1"

<DD>
<P>
				LEA sid,A1
<DD>				LEA mod,A2
<DD>				MOVE -(A1),(A2)+ ;kopira word sa adrese "sid-2" na
				adresu "mod" i A2 uveæa za 2
</DL>
				
<DL>
<DT>
<H5>MOVE	x(An),[ea]</H5>
</DT>
<DD>
èita podatak sa adrese dobijene zbrajanjem vrijednosti
			  x i sadr¾aja An i stavlja dobijeni podatak u [ea]
<DD>
<P>  LEA yalp,A1
<DD>				LEA tf,A2
<DD>				MOVE.W 2(A1),(A2)+
<DD>				MOVE.W -2(A1),(A2)+ ;sa adrese "yalp+2" kopira word
				na adresu "tf" i sa adrese "yalp-2" kopira word na
				adresu "tf+2"
<DD>
<P>			
				LEA yo,A6
<DD>				MOVE.B -2(SP),3(A6) ;kopira bajt sa adrese steka
				umanjene za 2, na adresu "yo+3"
</DL>

<DL>
<DT>
<H5>MOVE	(An,Dn.y),[ea]</H5>
</DT>
<DD>sa adrese iz (An+Dn), i to ako je umjesto y pi¹e w onda zbraja
			  s wordom iz Dn, a ako umjesto y stoji l onda sa longwordom, 
			  èita podatak i stavlja ga u [ea]
<DD>
<P>
  LEA xoom,A0
<DD>				MOVE.L #5,D0
<DD>				LEA member,A1
<DD>				MOVE.B (A0,D0.l),-(A1); kopira bajt sa adrese
				"xoom+5" na adresu "member-1"

<DD>
<P>				LEA c64,A1
<DD>				MOVE #%10101010,D4
<DD>				MOVE.L (A1,D4.w),text ;kopira longword sa adrese
				"c64+170" na adresu "text"
</DL>

<DL>
<DT>
<H5>MOVE	[ea],x(An,Dn.y)</H5>
</DT>
<DD>iz [ea] kopira na adresu dobijenu zbrajanjem x+(An+Dn.w) 
<DD>
<P>
LEA global,A6
<DD>				MOVE #3,D2
<DD>				MOVE textend,7(A6,D2.w) ;stavlja word sa adrese
				"textend" na adresu "global+3+7"
<DD>
<P>
				LEA urban,A1
<DD>				MOVE.L #$753af,D1
<DD>				MOVE.B (SP)+,1(A1,D1.l) ;kopira bajt koji je posljednji
				stavljen u stek na adresu "urban+$753af+1" 
</DL>

<DL>
<DT>
<H5>MOVE	x(An,Dn.y*n),[ea]</H5>
</DT>
<DD>sa adrese dobijene mno¾enjem sadr¾aja Dn sa n (n moze biti
			    1,2,4 ili 8) i zbrajanjem sa x i sadr¾ajem An, na [ea]
			    znaèi x(An,Dn.y*n) se mo¾e napisati kao x+An+Dn*n.
<DD>
<P>
 LEA tab,A0
<DD>				 MOVE #10,D0
<DD>				 MOVE 5(A0,D0.w*8),tab2 ;kopira word sa adrese
				 "5+tab+10*8" na adresu "tab2"
</DL>	

<P>	Postoji  dosta  kombinacija,  koje  sam preskakao ali one su vi¹e nego
logiène.   Ovo  nisu  sve  moguænosti  MOVE komande ali je za ovaj broj sasvim
dovoljno.

<P>	Evo jo¹ nekoliko jednostavnijih instrukcija...

<P><B>NOP</B> - instrukcija koja bukvalno ne radi NI¹TA sem ¹to èeka dva ciklusa..

<P><B>JSR labela</B> - Skok na podprogram iz kog se vraca instrukcijom RTS.  JSR bi se
mogla poistovjetiti s GOSUB naredbom iz BASIC-a.

<PRE>
start		JSR rutina	;skaèe na rutinu
		MOVE.L D0,D1	;kopira D0 u D1
		RTS		;zavr¹ava program

rutina  ADD.L #$100,D0  ;uveæava D0 za $100
				RTS		;vraæa se u glavni dio programa
</PRE>

<P><B>JMP labela</B> - Skok na odreðenu adresu oznaèenu labelom.
	
<PRE>
start   CLR.L D0	;bri¹e D0
        ADD.L #1,D0	;poveæava D0 za 1
        JMP start	;skaèe na start
</PRE>

<P>Ovaj program stalno uveæava D0 i mo¾e se prekinuti samo "nasilno", ubijanjem taska ili
resetom.


<P><B>CMP [ea],[ea]</B> - instrukcija koja vr¹i poreðenje i na osnovu njega postavlja
neke flegove iz SR registra. 

<PRE>
  CMP #5,D0	;provjerava da li je D0=5
  CMP.B (A0),D1	;da li je bajt u D1 jednak bajtu na adresi iz A0
  CMP.L start,end ;da li je longword na adresi start jednak onom na adresi end
</PRE>

<P><B>BEQ labela</B> - skok na labelu ukoliko je rezultat jednak.

<PRE>
start   CMP.B #$A,D4		;provjerava da li je bajt u d4 jednak $a
        BEQ yes			;ako jeste skaèe na labelu yes
        RTS			;ako nije zavr¹ava se
yes     MOVE.l #$ffffffff,D7	;puni D7
        RTS			;kraj
</PRE>

<P><B>BNE labela</B> - skok na labelu ukoliko je rezultat razlièit.

<PRE>
run     MOVE #50,D0		;stvlja 50 u D0
        LEA buffer,A0		;adresu buffer u A0
loop    MOVE.L #$01010101,(A0)+	;puni longwordom adresu na A0 i uveæava je za 4
        SUB #1,D0		;oduzima 1 od D0
        CMP #0,D0		;uporeðuje D0 sa nulom
        BNE loop		;ako nije nula skaèe na loop
        RTS			;ako jeste nula zavr¹ava se

buffer  dcb.l 0,50		;alocira 50 longwordova i ispunjava ih nulama
</PRE>

<P>	Ovo je bio primjer petlje koja puni 50 longwordova.

<P>	Oni koji veæ imaju iskustva s asemblerom  æe primjetiti da se mnogi sorsovi
mogu napisati kraæe  i  da  mogu  biti  br¾i,  ali  jo¹  uvijek  ne znamo sve
instrukcije, a o optimiziranju koda æe se govoriti u ne¹to kasnijim tekstovima.

<P>	Za sada smo obradili CLR, ADD, SUB, RTS, MOVE, LEA, NOP, JSR, JMP, CMP,
BEQ,  BNE  i  komande asemblera za upisivanje u memoriju DC.x i DCB.x.  Od ovih
instrukcija  se  ne  moze  napraviti bog zna kakav program, ali igrajte se ¹to
vi¹e  s  ovim  instrukcijama da slijedeæeg broja Amiga STORMa.  U njemu æe biti
detaljnije opisana pomenute instrukcije i jo¹ neke.

<P>	Za kraj evo jo¹ jednog programèica koji mijenja boje na ekranu.

<PRE>
***********************************

final_test
	lea	boje,a0		;stavlja adresu tabele sa bojama u a0
	move	#8,d1		;stavlja 8 u d1
.l1	move	(a0,d1.w*2),d0	;u d0 kopira word sa adrese iz a0+d1*2
	jsr	color		;skaèe na rutinu za postavljanje boje
	sub	#1,d1		;oduzima 1 od d1
	cmp	#-1,d1		;ukoliko je -1 u d1
	beq	kraj		;skaèe na labelu kraj
	nop			;ukoliko nije -1
	nop			;3 puta ne radi ni¹ta =) tj. èeka 6. ciklusa
	nop			;(nikad nemojte praviti ovakvo èekanje jer nisu
				;svi procesori jednako brzi, ovo je samo primjer)
	jmp	.l1		;skaèe na .l1 (labela s toèkom ispred je interna
				;labela)
kraj	rts


color
	lea	$dff000,a6	;stavlja adresu $dff000 u a6
	move.l	#$fffff,d7	;$fffff na d7
.l1	move.w	d0,$180(a6)	;boju iz d0 na $dff180 (boja pozadine)
	move.w	d0,$182(a6)	;d0 na $dff182 (1. boja)
	move.w	d0,$184(a6)	;$dff184...	
	move.w	d0,$186(a6)	;....
	sub.l	#1,d7		;oduzima #1 od d7
	cmp.l	#0,d7		;da li je 0 u d7?
	bne	.l1		;Ne, onda skok na .l1 (kao ¹to vidite ista labela
				;se pojavljuje i ovdje, ali ona pripada color rutini
				;Izmeðu dvije globalne labele (final_test,kraj,color..)
				;mo¾e da se nalazi vi¹e internih na koje mo¾ete
				;skakati samo izmeðu te dvije globalne.
	rts			;Ako je 0 u d7, povratak iz rutine

boje
	dc.w	$f00		;boje su zapisane u RGB formatu, bajt za svaku
	dc.w	$0f0		;komponentu
	dc.w	$00f		
	dc.w	$000
	dc.w	$fff
	dc.w	$0ff
	dc.w	$f0f
	dc.w	$ff0		
	
*************************************
</PRE>
	
<P>	Sve komentare i pitanja i prijedloge, o èemu biste ¾eljeli da pi¹em, mo¾ete 
poslati na email: <A HREF="MAILTO:cyborg@army.net">cyborg@army.net</A>.

<HR WIDTH=90% SIZE=3>

<TABLE ALIGN=RIGHT>
<TR>
<TD>
<H5><A HREF="mailto:cyborg@army.net">cYBORG</A></H5>
</TD>
<TD>
<H7>of</H7>
</TD>
<TD>
<IMG SRC="../gfx/indus3.gif" width=161 height=67 USEMAP="#click" ALT="iNDUS3">
<MAP NAME="click">
<AREA SHAPE="rect" COORDS="0,0,161,67" HREF="http://indus3.tsx.org">
</MAP>
</TD>
</TR>
</TABLE>

</td>
</tr>
</table>

</BODY>
</HTML>

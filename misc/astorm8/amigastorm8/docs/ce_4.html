<!DOCTYPE HTML PUBLIC "-//IETF//DD HTML 3.2//EN">
<html>
<head>
   <title>Amiga STORM => broj 8 => AS Special => Mala skola C-a (4.nastavak)</title>
   <meta name="author" content="Davor Rivic (d_rivic@usa.net)">
   <meta name="description" content="Hrvatski AMIGA casopis">
   <meta name="keywords" content="Hrvatska, Amiga, casopis, STORM">
   <meta http-equiv="content-type" content="text/html; charset=ISO-8859-2">
   <meta http-equiv="pragma" content="no-cache">
   <meta http-equiv="expires" content="05-Apr-99">
   <meta name="generator" content="CygnusEd Professional V4.2, Copyright © 1987-1997 by CygnusSoft Software">
</head>
<body background="../gfx/back.gif" link="red" vlink="red">

<table border="0" cellspacing="0" cellpadding="2" align="left" width="100%" cols="3" rows="3">
<tr><td width="115" align="center" valign="top">

<p align="center">
<img src="../gfx/as_8.gif" alt="8" width="106" height="106">
<br>
<br>
<img src="../gfx/najave.gif" alt="NAJAVE" border="0" width="106" height="19"><br><br>
<center>
<a href="theprophet.html">The Prophet</a><br>
<a href="magewars.html">Mage Wars</a><br>
<a href="darkage.html">NEX - Dark Age</a><br>
<a href="scavangers.html">Scavangers</a><br>
<a href="seaside.html">Seaside</a>
</center>
<br>
<img src="../gfx/novosti.gif" alt="NOVOSTI" border="0" width="106" height="19"><br><br>
<center>
<a href="blueblacksolution.html">Blue Black Solution</a></br>
<a href="superfrog.html">Superfrog</a><br>
<a href="themegagripii.html">The Megagrip II</a><br>
<a href="epicmarketing.html">Epic Marketing</a><br>
<a href="crystalsoftware.html">Crystal Software</a><br>
<a href="dafelbloodline.html">Dafel Bloodline</a><br>
<a href="napalmupdate.html">Update: Napalm</a><br>
<a href="theworldfoundry.html">The World Foundry</a><br>
<a href="phase5.html">phase5</a><br>
<a href="settlersii.html">Settlers II</a><br>
<a href="delsydsoftware.html">Delsyd Software</a><br>
<a href="amiga.html">Update: Amiga</a><br>
<a href="joyride.html">JoyRide</a><br>
</center>
<br>
<img src="../gfx/opisi.gif" alt="OPISI" border="0" width="106" height="19"><br><br>
<center>
<a href="napalm.html">Napalm</a><br>
<a href="amigaamp.html">Amiga AMP v2.1</a><br>
<a href="starbirds.html">Starbirds</a><br>
<a href="strangers.html">The Strangers</a><br>
<a href="tinytroops.html">Tiny Troops</a><br>
<a href="ioblix.html">IOBlix</a><br>
<a href="virtualgp.html">VGP Demo</a>
</center>
<br>
<img src="../gfx/interview.gif" alt="INTERVIEW" border="0" width="106" height="19"><br><br>
<center>
<a href="lambdateam.html">Lambda Team</a><br>
<a href="delsydint.html">Delsyd Software</a>
</center>
<br>
<img src="../gfx/zznicnews.gif" alt="ZZNIC NEWS" border="0" width="106" height="19"><br><br>
<center>
<a href="303tracker.html">303tracker</a>
</center>
<br>
<img src="../gfx/demoscope.gif" alt="DEMO SCOPE" border="0" width="106" height="19"><br><br>
<center>
<a href="wildlife.html">Wildlife</a><br>
<a href="1000%.html">1000%</a>
</center>
<br>
<img src="../gfx/asspecial.gif" alt="AS SPECIAL" border="0" width="106" height="19"><br><br>
<center>
<a href="pisma.html">Pisma èitatelja</a><br>
<a href="ce_4.html">Mala ¹kola C-a</a><br>
<a href="xrage.html">www.xrage.com</a><br>
<a href="amiga99.html">Amiga99 Show</a><br>
<a href="asm1.html">Mama, I wanna be a coder!</a><br>
<a href="otvorenapisma.html">Otvorena pisma (??)</a><br>
<a href="nagradnaigra.html">Nagradna igra</a><br>
<a href="dosta.html">DOSTA !!!!</a>
</center>
<br>
<img src="../gfx/ashelp.gif" alt="AS HELP" border="0" width="106" height="19"><br><br>
<center>
<a href="dungeonmaster.html">Dungeon Master</a>
</center>
</p>
<td width="450" valign="top">
<p>
<br>
<table width="100%" border="1">
<tr>
<td bgcolor="#b43100" colspan="2">
<font size="+2" color="#ffffff"><b><em>
<center>
Mala ¹kola C-a (4. nastavak)
</center>
</em></b></font>
</td>
</tr>
</table>
<p>
<br>
<br>
</p>
<p align="center">
<h3>
                  Pointeri, strukture i jo¹ poneke sitnice
</h3>
</p>
<p>

U pro¹lom broju su se potkrale neke "sitne" gre¹ke, ali zahvaljujuæi
pa¾ljivom èitatelju Mladenu Milinkoviæu one su uoèene i sada ih ispravljam.
</p>
<p>
Dakle, radi se o operatorima AND, OR, NOT i EOR. U tablici s aritmetièkim
operatorima pogre¹no je napisano tj. da su logièki:
</p>
<p>
&&nbsp;&nbsp;&nbsp;logièko AND<br>                         
|&nbsp;&nbsp;&nbsp;logièko OR<br>
&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;.&nbsp;&nbsp;.
</p>
,a oni su aritmetièki.
</p>
<p>
Dakle, navedene operacije mogu biti LOGIÈKE i oznaèavaju se sa "&&", "||" i
"!" (AND, OR i NOT respektivno) i ARITMETIÈKE koje se oznaèavaju sa "&",
"|", "~" (tilda) i "^" (EOR).<br>
Logièke operacije kao rezultat daju TRUE ili FALSE, ¹to u C-u odgovara
vrijdnostima 1 i 0, dok aritmetièke daju stvarni raèunski rezultat. To znaèi
da je i tablica bila pogre¹na i da je trebala izgledati ovako:
</p>
<p>
<table border="0">
<tr>
<td align="center">=</td>
<td>dodijeljivanje</td>
</tr>
<tr>
<td align="center">+</td>
<td>zbrajanje</td>
</tr>
<tr>
</tr>
<tr>
<td align="center">-</td>
<td>oduzimanje</td>
</tr>
<tr>
<td align="center">*</td>
<td>mno¾enje</td>
</tr>
<tr>
<td align="center">/</td>
<td>dijeljenje</td>
</tr>
<tr>
<td align="center">%</td>
<td>ostatak pri dijeljenju</td>
</tr>
<tr>
<td align="center">++</td>
<td>inkrementacija</td>
</tr>
<tr>
<td align="center">--</td>
<td>dekrementacija</td>
</tr>
<tr>
<td align="center">&</td>
<td>aritmetièko AND</td>
</tr>
<tr>
<td align="center">|</td>
<td>aritmetièko OR</td>
</tr>
<tr>
<td align="center">~</td>
<td>aritmetièko NOT</td>
</tr>
<tr>
<td align="center">^</td>
<td>aritmetièko ekskluzivno OR (EOR)</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td>pomijeranje u lijevo</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td>pomijeranje u desno</td>
</tr>
</table>
</p>
<br>
<p>
A tablica istinitosti treba da izgleda ovako:
</p>
<p>
<table>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;0101</td>
<td>&nbsp;0101</td>
<td></td>
<td>&nbsp;&nbsp;&nbsp;0101</td>
</tr>
<tr>
<td>&1100</td>
<td>|1100</td>
<td>~1100</td>
<td>^1100</td>
</tr>
<tr>
<td>----</td>
<td>----</td>
<td>----</td>
<td>----</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;0100</td>
<td>&nbsp;1101</td>
<td>0011</td>
<td>&nbsp;&nbsp;&nbsp;1001</td>
</tr>
</table>
</p>
<br>
<br>
<p>
Toliko ¹to se ispravki tièe, a sada pozabavimo se pointerima.
<b>Pointer</b> je
varijabla koja sadr¾i adresu varijable. Èemu ta "komplikacija"?<br>
Pa, kao prvo, kada se funkciji prosljeðuju parametri, funkcija ustvari 
dobija privremene kopije originalnih varijabli sa mjesta odakle je
pozvana. Znaèi, ako bi mijenjali te "kopije" varijabli u na¹oj funkciji, 
originali bi ostajali isti. Dakle, da bi funkcija mogla da mijenja originalne 
varijable iz funkcije koja je poziva, mora se izvr¹iti proslijeðivanje 
adresa tih varijabli. Tada æe na¹a funkcija mijenjati sadr¾aje memorijskih
lokacija èije su adrese date (i na kojima se èuvaju originali).
</p>
<p>
Kao drugo, èak i kada bi pozvane funkcije mogle da mijenjaju vrijednosti 
pozivajuæih funkcija postavljalo bi se pitanje brzine dobijenih programa, jer 
zamislite da je funkciji potrebno proslijediti veæu matricu.<br>
Ovako, sa pointerima dovoljno je samo obavijestiti pozvanu funkciju gdje se u
memoriji nalazi odreðena matrica (proslijediti njenu adresu, pointer na nju)
i stvar je rje¹ena. Èak i da matrica zauzima vise stotina KB dovoljno je
proslijediti samo jedan broj! 
</p>
<p>
Kao ¹to smi vidjeli va¾znost pointera je ogromna. Ne mo¾e se napisati
nijedan iole ozbiljniji program bez njihovog kori¹tenja. Na¾alost, rad s
pointerima nije ba¹ jednostavan i dosta poèetnika kada se prvi put sretne s 
njima se razoèara i odustane od uèenja C-a.
</p>
<p>
Kao ¹to rekosmo, pointer je varijabla koja sadr¾i adresu neke druge
varijable i to toèno odreðenog tipa. Da vidimo kako bi to izgledalo u
praksi:
</p>
<p>
int a;&nbsp;&nbsp;&nbsp;// najobiènija varijabla int tipa.<br>
int *p,*b;&nbsp;&nbsp;&nbsp; // p i b su pointeri na varijable tipa int.
</p>
<p>
Kod definiranja se pointeri oznaèavaju zvjezdicom ispred imena."p" je pointer na 
varijablu int tipa. Da bi zaista sadr¾ao adresu neke varijable ("a", koja
mu odgovara po tipu) trebamo dodati:
</p>
<p>
p=&a;
</p>
<p>
Ako bi sada zeleli da i pointer "b" sadr¾i adresu varijable "a" mo¾emo
slièno napisati:
</p>
<p>
b=&a;
</p>
<p>
ali mo¾emo i
</p>
<p>
b=p;
</p>
<p>
,¹to je potpuno isto. Sadr¾aj pointera p (adresa varijable "a") se
jednostavno prekopira u pointer b.
</p>
<p>
Sada je p "napunjen" adresom (unarni operator "&" oznaèava da se radi o
adresi varijable, a ne o sadr¾aju iste). "&" ima smisla koristiti samo s
varijablama (i funkcijama), a ne s izrazima, po¹to rezultati izraza
nemaju stalno mjesto u memoriji.
</p>
<p>
Sada, po¹to pointer "p" pokazuje na varijablu "a" za sve operacije koje bi
radili sa varijablom postoji ekvivalent sa pointerom:
</p>
<p>
*p=*p+1;
</p>
<p>
je isto ¹to i 
</p>
<p>
a=a+1;
</p>
<p>
ali
</p>
<p>
a++;
</p>
<p>
nije isto ¹to i 
</p>
<p>
*p++;
</p>
<p>
zbog toga ¹to "++" ima veci prioritet od "*", pa bi se to tumaèilo kao:
</p>
<p>
*(p++);
</p>
<p>
,a ne kao:
</p>
<p>
(*p)++;
</p>
<p>
pa zato vodite raèuna i stavljajte zagrade kad god niste sigurni.
</p>
<br>
<p>
Znaèi princip vrijedi, ali treba obratiti pa¾nju na prioritete operatora.
</p>
<p>
Evo sada primjera kako napisati funkciju koja ce mijenjati sadr¾aje svojih
parametara:
</p>
<p>
Source: primjer11.c<br>
<table width="99%">
<tr>
<td bgcolor="#999999">
#include &lt;stdio.h&gt;<br>
void swap(int *a,int *b);<br>
main()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int a=10,b=5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&a,&b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Sada je: a=%d, b=%d\n",a,b);<br>
}<br>
void swap (int *a,int *b)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int t;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t=*a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*a=*b;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*b=t;<br>
}<br>
</td>
</tr>
</table>
<br>
</p>
<p>
Red:
</p>
<p>
void swap(int *a,int *b);  
</p>
<p>
prijavljuje funkciju <i>swap</i>, èiji su parametri dva pointera na int
varijable. Zatim se definiraju varijable a i b, dodijeljuju im se poèetne
vrijednosti i poziva se funkcija <i>swap</i>. Njoj se proslijeðuju adrese na kojima se
èuvaju a i b varijable, a ne vrijednosti tih varijablih. Ako se vrijednost
varijable  "a"  nalazi  u  memorijskoj lokaciji 1000, a varijable "b" na
lokaciji  1004  (ako INT tip zauzima 4 bajta) onda æe se funkciji swap
proslijediti ba¹ ti brojevi:  1000 i 1004.
</p>
<p>
U funkciji <i>swap </i>sada imamo adrese varijabli, ali koje su one - nama nije
ni bitno. Mi samo koristimo sadr¾aje sa tih adresa, pa red:
</p>
<p>
t=*a;
</p>
smije¹ta u privremenu varijablu "t" sadrzaj memorijske lokacije koji se
sadr¾i u pointeru "a" (1000), a red:
</p>
<p>
*a=*b;
</p>
<p>
stavlja sadr¾aj sa adrese varijable. a (iz glavnog programa) na adresu varijable b
(takoðer iz glavnog programa) i poslije ove operacije "b" varijabla dobija istu
vrijednost kao i varijabla "a".
</p>
<p>
Imena varijabli iz glavnog programa (main-a) i iz funkcije <i>swap</i> naravno
ne moraju biti ista.
</p>
<p>
Da vidimo sada kako stoje stvari s nizovima. Ako imamo niz i pointer:
</p>
<p>
int niz[10];<br>
int *p;<br>
</p>
<p>
mo¾emo pointer "p" usmjeriti na bilo koji element niza:
</p>
<p>
p=&niz[7];
</p>
<p>
i "p" æe sadr¾avati adresu sedmog elementa niza. No i samo ime niza je sinonim
za adresu (prvog èlana) niza, pa je tako:
</p>
<p>
p=&niz[0];
</p>
<p>
isto ¹to i:
</p>
<p>
p=niz;
</p>
<p>
S druge strane, nekom elementu niza se umjesto na "klasièan" naèin:
</p>
<p>
niz[3]
</p>
<p>
mo¾e pristupiti i ovako:
</p>
<p>
p[3];
</p>
<p>
ili:
</p>
<p>
*(p+3);
</p>
<p>
Pri izraèunavanju izraza, "p" je pokazivao prvo na nulti element niza, pa je
onda poveæan za 3 i pokazivao na treæi element i tom trecem se pristupa. A 
eto i obja¹njenja za¹to  pointer mora imati tip - da bi kompajler znao za
koliko  zaista da uveæa "p".  Po¹to je "p" pointer na int tip, koji u memoriji
zauzima 4 bajta i ako recimo "p" sadrzi 1000, p+3 ce sadrzati 1000+3*4=1012.
No,  o  ovome  mi  ne moramo brinuti i uvijek mo¾emo biti sigurni da *(p+3) se
odnosi na treci element niza, bio on Byte, Word, Long, struktura...
</p>
<p>
Da napomenem jo¹ jednu stvar u vezi stringova (i nizova uopæe). String
mo¾emo definirati ovako:
</p>
<p>
char poruka1[]="Vrijeme je novac";
</p>
<p>
ali i ovako:
</p>
<p>
char *poruka2="Vreme je novac";
</p>
<p>
Ima li razlike? 
</p>
<p>
U prvom sluèaju definiramo niz tipa "char":  kompajler broji koliko ima
znakova pod navodnicima i negdje u memoriji rezervira toliko bajtova, plus jedan
za oznaèavanje kraja niza ( "\0").
</p>
<p>
U drugom primjeru se isto alocira memorija, isto smje¹taju bajtovi poruke, ali
se stvara pointer koji pokazuje na prvo slovo poruke.  Taj pointer kasnije
se mo¾e iskoristiti da pokazuje na neku drugu poruku, ali poruka1 je uvek
isti niz.  Sadr¾aj tog niza se mo¾e mijenjati, ali on æe se uvijek nalaziti na
istom mjestu u memoriji.
</p>
<p>
Kako bi jo¹ bolje shvatili pointere evo jo¹ jednog programa:
</p>
<p>
Source: primjer12.c<br>
<table width="99%">
<tr>
<td bgcolor="#999999">
#include &lt;stdio.h&gt;<br>
void sort(int *niz); // Najava funkcije "sort" koja prima pointer na int<br>
main()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int a[10]={4,5,7,2,8,1,3,9,15,3}; // Pravi se niz i puni se s brojevima<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i; // varijabla za potrebe for petlje<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Niz je na poèetku izgledao ovako:\n");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0;i&lt;10;i++) // Ispis poèetnog stanja niza<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf ("%d ",a[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort(a); // Poziv funkcije "sort". Moglo je i: sort(&a[0]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\nA sada izgleda ovako:\n");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0;i&lt;10;i++) // Potpuno isti ispis novonastalog stanja<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf ("%d ",a[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf ("\n");<br>
}<br>
void sort(int *niz)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i,j,tmp; // "i" i "j" su indeksne varijable, a "tmp" slu¾i za privremeni<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0;i&lt;9;i++)  // smje¹taj vrijednosti prilikom zamjene sadr¾aja<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(j=i+1;j&lt;10;j++) // Usporeðuje se svaki sa svakim elementom<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(niz[i]&gt;niz[j]) // Ako je veci ispred manjeg<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp=niz[i]; // zamjenjuju mjesta<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;niz[i]=niz[j];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;niz[j]=tmp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
</td>
</tr>
</table>
<br>
</p>
<p>
Program se sastoji iz glavnog dijela koji stvara niz, puni ga
sluèajnim brojevima (onim koje navedemo), ispisuje niz, poziva "sort"
funkciju i ponovo ispisuje sve elemente niza.
</p>
<p>
Funkcija se poziva tako ¹to se proslijeðuje adresa niza. Kao ¹to je
navedeno samo ime niza bez zagrada daje adresu (prvog clana) niza.
</p>
<p>
  Sama funkcija koristi najjednostavniji "bubble" sort.  Jednostavno se
poredi svaki element sa svakim i kad god je veæi ispred manjeg (ispred su
oni s manjim indeksom) ta dva elementa jednostavno zamjene mjesta.  To se
izvodi ugnje¾ðenim petljama.
</p>
<p>
Èak i da vam nije sasvim jasno na koji naèin sort radi obratite pa¾nju na
to kako se pristupa èlanovima niza unutar funkcije.  Svugdje gdje se koristilo
"niz[i]" i "niz[j]" moglo se staviti "*(niz+i)" i "*(niz+j)" respektivno,
¹to bi dalo iste rezultate, ali ovako je preglednije.
</p>
<br>
<p> 
  A sada ne¹to o strukturama.  Èesto pi¹uæi programe nailazimo na grupe
podataka razlièitog tipa koje karakteriraju jednu stvar.  Recimo da pravimo
bazu o radnicima nekog poduzeæa.  Baza o svakom radniku sadr¾i ime,
prezime, godinu roðenja, adresu i prosjeènu plaæu.  Neki od podataka su
cjelobrojni (int), neki realni (float), a neki tekstualni (char).
</p>
<p>
  Meðutim, zgodno je imati ih dostupne sve odjednom o jednom radniku,
proslijeðivati ih funkcijama zajedno itd. Na scenu stupaju strukture!
<br>
<b>Struktura</b> je skup od jedne ili vi¹e varijabli, koje mogu biti razlièitih
tipova, grupiranih zajedno pod jednim imenom radi lakseg rukovanja. Ovo kaze
teorija, a kako to izgleda u praksi?
</p>
<p>
struct radnik<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char ime[10];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char prezime[20];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int  roðen;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char adresa[30];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float plaæa;<br>
};<br>
</p>
<p>
Deklariramo tip strukture kljuènom rijeèi "struct" koji æe se zvati "radnik". 
<b><u>Dakle, tip strukture æe se zvati radnik, a ne sama struktura!!!</u></b>  Taj tip
sadr¾i:  niz od 10 karaktera (char) pod imenom "ime", niz od 20 karaktera
pod imenom "prezime", jedan int podatak pod imenom "roðen", jo¹ jedan niz
karaktera i jedan broj tipa float (plaæa).  Novi tip strukture (radnik) koji
smo sada definirali sadr¾i sve ove podatke.  Meðutim, do sada je stvoren
samo tip, a ne postoji ni jedna struktura tog tipa, jos uvijek ni bajt
memorije nije rezerviran.  Tip strukture se na neki naèin mo¾e uporediti sa
tipovima int, float, itd, samo ¹to je ovaj kompleksniji, jer se sastoji od
vi¹e tipova.  Analogno tome, recimo, tip int postoji, ali dok se ne najavi
neka varijabla tog tipa ne rezervira se memorija.
</p>
<p>
Kada ¾elimo da stvorimo neku strukturu tipa "radnik" dodati æemo:
</p>
<p>
struct radnik prvi;
</p>
<p>
Tek poslije ovog reda stvorena je struktura s imenom "prvi", koja je tipa
radnik. Kada je tip definiran mo¾emo stvarati strukture tog tipa koliko
¾elimo, mozemo praviti nizove struktura tog tipa, èak mo¾emo praviti i
slo¾enije strukture koje kao jedan od èlanova sadr¾e i na¹u strukturu.
Sve ¹to nije zabranjeno, dozvoljeno je!
</p>
<p>
Za sada je stvoren tip (radnik), prijavljena je struktura tog tipa (prvi),
ali elementi strukture jos uvijek nisu dobili svoje prave vrijednosti.<br>
Elementima strukture se jednostavno pristupa:
</p>
<p>
prvi.roðen=1965;
</p>
<p>
Ime strukture (ne tipa!), toèka pa ime èlana, vrlo jednostavno. Plaæu bi
popunili isto tako:
</p>
<p>
prvi.plata=1046.376;
</p>
<p>
Meðutim, kako ovo nije BASIC ne bi mogli napisati ne¹to kao:
</p>
<p>
prvi.ime="Pero";
</p>
<p>
Ovi bi znaèilo da zahtijevamo da se odjednom prenese 5 karaktera (ime + '\0'),
sto je moguce u BASIC-u.  U C-u bi morali da popunimo slovo po slovo:
</p>
<p>
prvi.ime[0]='P';<br>
prvi.ime[1]='e';<br>
prvi.ime[2]='r';<br>
prvi.ime[3]='o';<br>
prvi.ime[4]='\0';<br>
</p>
<p>
ili da koristimo neku funkciju za kopiranje stringa (strcpy), veæ prema
snala¾ljivosti. Da vidimo kako bi izgledao cijeli program:
</p>
<p>
Source: primjer13.c<br>
<table width="99%">
<tr>
<td bgcolor="#999999">
#include &lt;stdio.h&gt;<br>
struct radnik<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char ime[15];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char prezime[20];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int  roðen;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char adresa[30];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float plaæa;<br>
};<br>
<br>
main()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct radnik prvi={"Pero","Periæ",1965,"Ujedinjenih naroda 99",1046.376};<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Radnik:%s %s\n", prvi.ime, prvi.prezime);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Roðen:%d godine\n", prvi.roðen);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Adresa:%s\n", prvi.adresa);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("S prosjeènom plaæom %f DM\n", prvi.plaæa);<br>
<br>
}<br>
</td>
</tr>
</table>
</p>
<p>
Deklariramo novi tip strukture - "radnik". Zatim se definira struktura
"prvi" tipa "struct radnik". U istom redu se novonastala struktura ("prvi")
inicijalizira - dodijeljuju se poèetne vrijednosti njenim èlanovima. Zatim se u
vi¹e redovaa ispisuju èlanovi strukture. Tu vidimo kako se tim èlanovima
pristupa. Deklaracija i definicija strukture se mogu spojiti:
</p>
<p>
struct radnik<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char ime[15];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char prezime[20];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int  roðen;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char adresa[30];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float plaæa;<br>
} prvi={"Pero","Periæ",1965,"Ujedinjenih naroda 99",1046.376};<br>
</p>
<p>
i tako u¹tedjeti ne¹to prostora, ali znaèenje je isto.
</p>
<p>
Ako imamo tvrtku od 100 radnika potrebno je napraviti niz struktura.
Recimo da je tip "radnik" deklariran na isti naèin niz struktura bi
napravili ovako:
</p>
<p>
struct radnik èovjek[100];
</p>
<p>
Sada æemo pojedinim èlanovima pristupati:
</p>
<p>
a=èovjek[55].roðen;
</p>
<p>
U "a" smje¹tamo godinu roðenja 55. radnika (odnosno 56. jer postoji i
nulti!!). Ako bi htjeli da prilikom definiranja i inicijaliziramo niz
struktura morali bi (satima) da pi¹emo:
</p>
<p>
struct radnik èovjek[100]=<br>
{ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"Pero","Periæ",1965,"Ujedinjenih naroda 99",1046.376},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"Milan","Goluboviæ",1974,"Zrtava fasizma 43",966.599},<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   . &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  .<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"Davor","Riviæ",1981,"Franca Pre¹erna 28a",1576.203}<br>
}<br>
</p>
<p>
Zgodno kod nizova struktura je to ¹to strukture, kao i sami podaci jedne
strukture grupiraju u memoriji jedni iza drugih po istom redoslijedu po kom su
deklarirani, pa je moguæe vidjeti adresu neke strukture u nizu (mno¾enjem
du¾ine i broja strukture) i tu jednostavno uèitati podatke iz nekog fajla.
Pored toga ¹to nije zgodno brojati koliko bajtova zauzima struktura nije
preporuèljivo zbog jo¹ jednog razloga:  tip int npr.  mo¾e zauzimati 4 bajta
ili 2 bajta, u memoriji (kod Amige) mora poèinjati na parnoj adresi, pa æe
zato kompajler ako se pogodi da je isti na neparnoj ubaciti jedan "prazan"
bajt ispred njega , koga mi nebi izbrojali i doslo bi do gre¹ke.  Zato treba
koristiti:
</p>
<p>
sizeof (struktura);
</p>
<p>
ili
</p>
<p>
sizeof (struct tip_strukture)
</p>
<p>
"sizeof"   nije  funkcija,  veæ  unarni  operator  koji  kompajler  u  vrijeme
kompajliranja zamijenjuje velièinom odgovarajuæe strukture. Evo instant
primjera koji iz niza struktura ispisuje onu sa najmanjim èlanom (starost):
</p>
<p>
Source: primjer14.c<br>
<table width="99%">
<tr>
<td bgcolor="#999999">
#include &lt;stdio.h&gt;<br>
struct data<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char ime[10];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int  starost;<br>
};<br>
<br>
int najmlaði(struct data *pod,int broj);<br>
<br>
main()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int adolescent;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static struct data  podaci[]=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"Pero",34},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"Mika",24},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"Ðoko",34},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"Franjo",33},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"Sanjin",12}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adolescent=najmlaði (podaci,sizeof(podaci)/sizeof(struct data));<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Najmlaða osoba:%s\n",podaci[adolescent].ime);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("I ima samo %d godina.\n",podaci[adolescent].starost);<br>
<br>
}<br>
<br>
int najmlaði(struct data *pod, int broj)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int min;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;broj--;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (min=broj;broj>=0;broj--)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(pod[broj].starost &lt; pod[min].starost)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min=broj;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return min;<br>
}<br>
</td>
</tr>
</table>
</p>
<p>
Na poèetku se deklarira nova struktura "data" koji ima samo dva
èlana: niz "ime" od 10 char-a i int "starost". Deklaracija se morala izvr¹iti
prijee najavljivanja funkcije "najmlaði", jer je ono (najavljivanje) koristi - 
logièno.   Zatim  se  u main-u definira niz "podaci" tipa "struct data" (niz
struktura) i inicijalizira se.
</p>
<p>
Pitanje za naprednije: za¹to je ubaèena kljuèna rijeè static?  Ako se ona ne
stavi onda se za lokalne varijable koristi stek ¹to samo po sebi i nije
lo¹e, ali se pored alokacije steka moraju inicijalizirati èlanovi strukture
- odnosno prekopirati s neke fiksne lokacije na stek.  Sa static ispred 
niz "podaci" postaje statièan, pa je za njegovu inicijalizaciju dovoljno
samo ubaciti blok memorije sa inicijaliziranim podacima.  Na ovaj naèin se
posti¾e veæa brzina i smanjenje du¾ine programa.  U ovom primjeru u¹teda i
nije velika, ali da ima vise podataka bila bi.  Ako vam ba¹ nije najjasnije
o èemu se radi jednostavno preskoèite ovaj dio i zanemarite rijeè "static", 
da vas ne bi bunila.
</p>
<p>
Zatim se poziva funkcija "najmlaði", kojoj se proslijeðuju: pointer na
poèetak niza struktura (sjetite se da je samo ime niza njegova adresa) i
broj èlanova niza. Broj èlanova niza se izraèunava tako ¹to se du¾ina strukture
podijeli s du¾inom tipa strukture:
</p>
<p>
duzina= sizeof(podaci) / sizeof(struct data);
</p>
<p>
sizeof(struct data) iznosi 14:  10 char-a i jedan int (4 bajta),a
sizeof(podaci) je (14*5=) 70, jer niz ima 5 èlanova.  Dijeljenjem se dobija
70/14=5 èlanova.  Vrlo zgodno, jer ako promijenimo du¾inu niza ne moramo mijenjati
granice petlji i sl.
</p>
<p>
Funkcija vraæa indeks najmlaðeg i onda se ispisuje njegovo ime i starost.
</p>
<p>
varijabla  "broj" u funkciji se umanjuje za jedan zato ¹to je prvi element
0. , a ne 1., pa æe zato zadnji biti 4.  , a ne 5.
</p>
<p>
Dakle, petlja ide od 4 do 0, a ne 5 do 1.
</p>
<p>
Indeks najmlaðeg se "raèuna" tako ¹to se za najmlaðeg proglasi zadnji, a
onda uporeðuje sa svima ostalim. Ako se otkrije da je netko mlaði od onog
s indeksom "min" :
</p>
<p>
pod[broj].starost &lt; pod[min].starost
</p>
<p>
varijabli "min" se dodijeljuje njegov index.
</p>
<p>
min=broj;
</p>
<p>
Kada se svi elementi niza ispitaju funkcija vraæa indeks najmlaðeg. 
</p>
<p>
Zapazimo da je za svako ime rezervirano po 10 char-a (bajta), a da su imena
kraæa, ¹to predstavlja rasipanje memorije. Da bi se to izbjeglo dovoljno je
pri deklariranju strukture "data" umjesto:
</p>
<p>
char ime[10];
</p>
<p>
staviti:
</p>
<p>
char *ime;
</p>
<p>
Dakle, ne niz od fiksnih deset èlanova, veæ pointer na niz (4 bajta) + broj
slova po imenu. Na ovaj nacin du¾ina imena nije ogranièena i memorija se
koristi racionalno, i 4 bajta je mala cijena za to. Ovaj naèin se mo¾e
koristiti samo kada se struktura popunjava konstantama (kada kompajler zna
koliko memorije da alocira) ili kada sami alociramo memoriju za to.<br>
Ako imamo pointer na strukturu èlanovima te strukture bi pristupali:
</p>
<p>
(*pointer).èlan
</p>
<p>
no mo¾e se koristiti i skraæeni naèin obilje¾avanja:
</p>
<p>
pointer-&gt;èlan
</p>
<p>
Strelica ("minus" i "je veæe" znaci) oznaèavaju da "pointer" nije struktura,
vec pointer na nju. Ovaj naèin obilje¾avanja se vrlo èesto koristi i po¾eljno
je zapamtiti ga.
</p>
<p>
  Kreiranjem nizova i matrica nije uvijek najzgodniji naèin alociranja
memorije. Ako koristimo niz koji zauzima 10-ak KB za isto toliko æe biti du¾i
i na¹ program. Osim toga, ponekad tek u toku izvr¹avanja programa saznajemo
koliko nam je memorije potrebno, pa je neophodno alcirati memoriju po
potrebi (npr. ucitavamo sliku i sl.).<br>
  Za  to  cemo  koristiti funkciju "malloc"(memory alloc), a za oslobaðanje
iste  memorije  funkciju  "free".   Sva  alocirana  memorija se po zavr¹etku
programa  mora  vratiti sistemu.  Evo programa koji æe alocirati memoriju za
niz od 50 int-a (200 bajta), ispisati sadr¾aj te memorije i vratiti memoriju
sistemu.
</p>
<p>
Source: primjer15.c<br>
<table width="99%">
<tr>
<td bgcolor="#999999">
#include &lt;stdio.h&gt;<br>
#include &lt;stdlib.h&gt;<br>
main()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int *p;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(p=malloc(50*sizeof(int)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0;i&lt;50;i++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf ("%d,",p[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(p);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
</td>
</tr>
</table>
</p>
<p>
"malloc" i "free" su deklarirane u "stdlib.h" (¹to obja¹njava drugi red
programa), a dio su standardne C biblioteke, pa æe tako programi koje pi¹ete
biti  portabilni.   Pored  ovih funkcija postoje i Amiga specifiène funkcije
(exec.lib) za istu namjenu...
</p>
<p>
Deklariramo pointer na int i pozivamo malloc. Njen parameter je du¾ina
memorije koju ¾elimo da alociramo u bajtovima. Funkcija vraæa pointer na niz
tra¾ene du¾ine, èija se adresa smje¹ta u p.<br>
Ako nema dovoljno memorije i na¹ zahtjev za alociranjem ne mo¾e biti
ispunjen "malloc" æe vratiti nulu (0, NULL).<br>
Zato se i poziv nalazi unutar if naredbe, koja obezbjeðuje da se ostatak
programa izvr¹i samo ako je alociranje uspje¹no izvr¹eno.  Nastala bi gre¹ka
ako bi sa "free" poku¹ali da oslobodimo memoriju koja nije alocirana.<br>
Ispisujemo sadrzaj te memorije (kao da se radi int o nizu) i oslobaðamo
memoriju.
</p>
<p>
Ne dopustite da vas zbuni to ¹to je poziv funkcije smje¹ten unutar if
naredbe, jer se takav naèin pisanja èesto sreæe. Posle poziva "p" dobija
neku vrijednost mo¾e biti toèna (TRUE , != 0) ili netoèna (FALSE, == 0) pa od
nje zavisi dalje grananje programa.
</p>
<br>
<p>
I na kraju objasnimo liste. Ako mislite da je ovo do sada bilo te¹ko,
uvidjeti æete da je spram listi maèji ka¹alj. Najozbiljnije, liste su vrlo
te¹ke za razumijevanje, pogotovo poèetnicima. Zato æemo ovdjee obraditi
najjednostavniju jednostruko povezanu listu bez ikakvih "komplikacija"
(sortiranja, umetanja i sl.). Èemu zapravo slu¾e liste?
</p>
<p>
Zamislite da morate napisati program koji koristi vi¹e struktura.  U toku
izvr¹enja programa morate predvidjeti moguænost dodavanja novih, brisanja
onih koje vam vi¹e ne trebaju, a uz maksimalnu u¹tedu memorije.  Dakle, ne
dolazi u obzir niz struktura s limitiranim maksimalnim, brojem elemenata
niza.  Ideja je da svaka struktura pored potrebnih podataka sadrzi i pointer
na slijedeæu i/ili predhodnu, kako je veæ potrebno.  Mi æemo èuvati samo
pointer na prvu strukturu u listi, a kada nam bude potrebna slijedeæa 
struktura iz prve (predhodne) uzeti æemo pointer na nju i tako joj pristupiti.
</p>
<p>
Pointer na slijedeæu strukturu zadnje strukture u listi sadr¾avati æe NULL, ¹to
oznaèava kraj liste. Kroz listu se znaèi moramo kretati sekvencijalno, 
odnosno po jedan element naprijed/nazad.  Postoje i kompliciranije 
organizacije listi (dvostruko povezane iste, binarna stabla ), ali kako je
ovo ipak "mala ¹kola" C-a neæu vas vi¹e pla¹iti time.
</p>
<p>
Evo prvo samo primjera:
</p>
<p>
Source: primjer16.c<br>
<table width="99%">
<tr>
<td bgcolor="#999999">
#include &lt;stdio.h&gt;<br>
#include &lt;stdlib.h&gt;<br>
#include &lt;string.h&gt;<br>
<br>
struct list {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *s;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list *next;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list * dodaj(struct list *,char *);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void pisi(struct list *);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void brisi(struct list *);<br>
<br>
main()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list *prva=NULL;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list *zadnja=NULL;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prva=zadnja=dodaj (prva,"Prva struktura liste.");<br>
<br>   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zadnja=dodaj(zadnja,"Druga struktura liste.");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zadnja=dodaj(zadnja,"Treæa struktura liste.");<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pisi(prva);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brisi(prva);<br>
<br>
}<br>
<br>
struct list * dodaj(struct list *list,char *string)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list *tmp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp=malloc(sizeof(struct list));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp-&gt;s=malloc(strlen(string)+1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(tmp-&gt;s,string);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp-&gt;next=NULL;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list-&gt;next=tmp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return tmp;<br>
<br>
}<br>
void brisi(struct list *list)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list *tmp;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp=list-&gt;next;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(list-&gt;s);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(list);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list=tmp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
<br>
void pisi(struct list *list)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list *tmp;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp=list->next;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",list-&gt;s);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list=tmp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
</td>
</tr>
</table>
</p>
<p>
A zatim isto to, ali sa obja¹njenjima, jer primjer baz obja¹njenja ne znaèi
puno, a s obja¹njenjima je ogroman i tesko je pratiti tok programa.
</p>
<p>
#include &lt;stdio.h&gt;<br>
#include &lt;stdlib.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// zbog malloc i free<br>
#include &lt;string.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// zbog strlen i strcpy<br>
<br>
struct list {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// struktura sadr¾i samo pointer na string i pointer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list *next;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// na slijedeæu strukturu<br>
};<br>
<br>
struct list * dodaj(struct list *,char *);<br><br>
/*<br>
Funkciji "dodaj" se proslijeðuje pointer na strukturu na koju se treba
nadovezati nova struktura i string (pointer na char niz) za tu novu
strukturu. Funkcija vraæa pointer na novopridodatu strukturu listi.<br>
*/<br><br>
void pisi(struct list *);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Pokazuje kako se pristupa listi ispisujuæi sve èlanove&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// liste (tekstove)<br>
void brisi(struct list *);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Memorija rezervirana za listu mora se osloboditi<br>
main()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list *prva=NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// pointer na prvu strukturu u listi<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list *zadnja=NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// pointer na posljednju dodatu strukturu<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prva=zadnja=dodaj (prva,"Prva struktura liste.");<br> 
/* Dodaje se prva struktura liste, koja je na poèetku ujedno i zadnja */<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zadnja=dodaj(zadnja,"Druga struktura liste.");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Jo¹ jedna<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zadnja=dodaj(zadnja,"Treæa struktura liste.");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Pa jo¹ jedna<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pisi(prva);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Ispis<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brisi(prva);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Oslobaðanje memorije<br>
<br>
}<br>
<br>
struct list * dodaj(struct list *list,char *string)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list *tmp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Privremeni pointer na strukturu<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp=malloc(sizeof(struct list));<br><br>
/*<br>
Alocira se memorija za novi èlan liste (novu strukturu) i pointer na nju
se smje¹ta u tmp. Zbog pojednostavljenja ne provjerava se da li ima dovoljno
memorije - da li je poziv malloc-a uspje¹an . Inaèe tu provjeru je neophodno
izvr¹iti!!!!<br>
*/<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp-&gt;s=malloc(strlen(string)+1);<br>
<br><br>
/*<br>
Rezervira se memorija za string (po¹to struktura sadr¾i samo pointer na
string, a ne i sam string) i on se smje¹ta gdje treba: tmp-&gt;s<br>
*/<br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(tmp-&gt;s,string);<br><br>
/*<br>
Kopira se proslijeðeni string u novorezerviranu memoriju.<br>
*/<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp-&gt;next=NULL;<br><br>
/*<br>
Po¹to je ovo najnoviji element liste sljedeæeg nema<br>
*/<br><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list-&gt;next=tmp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>

/*<br>
Ako upravo dodati èlan liste nije prvi u listi on se nadovezuje na
predhodni, u suprotnom - ni¹ta. Element je prvi ako je kao pointer na
poèetak liste funkciji proslijeðena nula (NULL)<br>
*/<br><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return tmp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Vraæa se pointer na novi èlan liste!<br>
<br>  
}<br>
void brisi(struct list *list)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list *tmp;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(list)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Vrti dok nije NULL - do zadnjeg èlana liste<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp=list-&gt;next;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Zapamti adresu slijedeæeg èlana liste<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(list-&gt;s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Oslobodi memoriju trenutne strukture<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(list);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// i memoriju za string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list=tmp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// slijedeæa postaje trenutna, pa 'ajde ponovo<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
<br>
void pisi(struct list *list)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list *tmp;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp=list-&gt;next;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",list-&gt;s);<br>
<br>
/*<br>
Potpuno isto kao gore, samo ¹to se ne oslobaða mem. nego se ispisuje èlan
strukture<br>
*/<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list=tmp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
</p>
<br>
<p>
Za ovaj put toliko (mo¾da i previ¹e). Izvinjavam se ¹to sam negdje previ¹e
detaljirao u obja¹njavanju i neke stvari obja¹njavao vi¹e puta, ali pointeri
i strukture su u C programiranju vrlo va¾ni i ako mislite da se time makar
malo ozbiljnije bavite sve gore napisano mora vam biti jasno.  No ne
oèekujte da se to desi iz prvog èitanja.  Neke od navedenih stvari (pogotovo
liste) su vrlo slo¾ene i potrebno je vrijeme da se shvate.  Budite uporni,
proèitajte tekst vi¹e puta, sve dok vam ne postane jasan i pi¹ite programe.
To je jedini naèin za uèenje C-a.  Ne zavaravajte se da je samo èitanje
dovoljno!
</p>
<p>
U slijedeæem nastavku biti æe rijeèi o pozivanju funkcija Amiga OS-a, pa ¾ivi 
bili pa vidjeli.
</p>
</td>
</tr>
</table>
</body>
</html>


{center}
{subhead} Emulation Idea{def}{p}
Article by Mark A. Tierno
{left}
{p} {p}

I know there's plenty of emulators out there, emulators for every
platform from the Trash-80 on up. But, they all have one feature in
common which I feel is unnessecary.
{p} {p}
They don't just run the program from whichever other OS, but first
bring up a system screen for what's being emulated, and basically run
the entire foregin OS. That's the memory for that screen, the extra CPU
cycles used just to bring up the other OS, and however much of your hard
drive is used just to store the other OS in it's own partition. This is
a lot of overhead, especially when you're talking Windows. And here all
we ever want to do is run one stinking program (usually a game).
{p} {p}
But, there is a better way, and perhaps only the unique configuration of
the Amiga makes it possible.
{p} {p}
Skip running the entitre OS, system screen, and whatever else. Just
run the bloody program. How, you ask? The answer is actually very
simple.
{p} {p}
The emulation would have three parts. The first part would be a
commodity that, when a given program gfile is clicked on and not
recognized as an Amiga program, scans it to see if it's code type
matches any of the ones in it's list- usually MAC, IBM DOS, or Windows.
but it could be extended to others with plug-in modules stored in a
directory devoted to just this purpose. When the commodity makes a
match, it passes the foreign program onto the next component.
{p} {p}
The second component would be a series of small micro-emulation
programs, each one devoted to a different OS. A MAC program would be
passed to the MAC emulator, a Windows program to the windows emulator,
IBM DOS to it's own, and so on. The function of each such program would
be the same; as each line of code is in turn read from the foreign
program file, it matches it up to the equivalent Amiga assembly or
system call, translating any procedure or subroutine calls, and then
passing these on to the third component, the emulation library. The
program would be run through this component, calling up a default window
if no window or screen is program-specified, and take care of "running"
the program.
{p} {p}
The emulation library is another one which would be a differenbt version
specific to the OS being emulated. As a library it would be very
simple; all calls passed to it are redirected to the appropriate Amiga
library, OS command, or system call. We're talking one-line routine
calls here. Any routines passed to it would first have to be reduced to
the simplest assembly-level calls for that given OS by the second
component, so all this library would then have to do is translate one
assembly-level call into an Amiga one. This component of the emulation
would be the easiest to program, since all you'd need is a complete list
of the machine language commands from the other system and then have a
single redirect call for each one.
{p} {p}
At this point, you're running the other program as an Amiga-native task.
No need for other screens, no need for a good chunk of your hard drive
devoted to an OS you don't need, just click and run the program like any
other- straight off your Workbench. Speed? Well, it's just a series of
redirects to other libraries; make the libraries resident and you
shouldn't have much of a performance hit. At the very least it'll be a
lot faster than standard emulations, and a lot more adaptable.
{p} {p}
Good idea, but why am I not programming this thing myself? Well, I don't
have the requisite programming and foreign OS knowledge to pull this
off. Hence the purpose of this article. If there's any programmers out
there that think they're up to this job, then I challenge you to try.
You'll be giving the Amiga community an invaluable resource, and be
recognized for performing a revolutionary programming feat.
{p} {p}
All you have to do is give me credit for the idea. ;-)
{p} {p}
Comments, ideas? email : {bold}letters@aio.co.uk{nobold}
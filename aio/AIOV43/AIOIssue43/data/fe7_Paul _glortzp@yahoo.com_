{center}
{subhead}DIY ATX PSU with software powerdown for A1200/A4000s{def}{p}
Article by Paul Harvey
{left}
{p} {p}
Have you ever seen an ATX equipped PC that could turn itself off at the shutdown menu in 
Win9x or the shutdown command in linux? Have you ever wondered how cool it would be if 
your Amiga could do the same? Or perhaps you want to install your A4000/A1200 in a ATX 
tower?
{p} {p}
Well now you needn't wonder any more, because this month I'll start on another DIY project that 
will allow you not only to utilise an ATX PSU for your tower, but also be able to turn it off from 
the CLI!
{p} {p}
{bold}Introduction{nobold}
{p} {p}
Apart from having to wire the right wires from the ATX Mainboard plug to your Amiga's 
mainboard (See pinouts  section), you have to do something special to get power out of the PSU. 
There is this mysterious wire on pin 14 of the ATX PSU, usually green, and referred to in pinout 
diagrams as 'PS_ON'. For the power supply to operate, usually there is some logic circuitry on 
your ATX motherboard to provide an electrical path from the "PS_ON" wire to ground. Then the 
PSU will power up completely. But what if you have an amazing Amiga that doesn't have such 
circuitry? A temporary fix would be to find a switch on your case, or install one, that would do 
the same trick. You would wire the switch to pin 14 and one of the ground wires. This would 
give you the same functionality as your boring old A4000D or AT case. But we want our 
computer to turn itself off, don't we, so here goes...
{p} {p}
{bold}How it will work{nobold}
{p} {p}
First of all, if we want the computer to turn itself off, we have to do away with the toggle switch 
and use a couple of momentary push buttons instead. On a typical Wintel motherboard, the 
'power' button is usually configured to turn the machine on if the button is pressed, and turn it 
off again if held in for a few seconds (usually 4 secs).
{p} {p}
I decided to save a lot of time and circuitry by just using a simple flip/flop circuit. You can build 
this using a handful of NAND gates. I'm using 74xx logic in the final construction, but you could 
also use 40xx logic chips as well. A Flip/Flop (bistable) is simply a circuit that has two inputs and 
two outputs. There are many variations of the basic flip/flop, and can be used to build quite 
complex stuff. Anyway, the basic idea is that you can give one of the inputs a signal, and it's 
output will turn on, at the same time turning off the opposite output if it was already on. With 
the input signal only lasting a few moments, once removed, the output will still stay on until 
power is lost or the other input is activated. So a truth table should look like this:
{p} {p}
{fixed}
Inputs  | Outputs
---+----+----+---
X1 | X2 | Z1 | Z2
---+----+----+---
0  | 0  | Last input state
1  | 0  | 1  | 0
0  | 1  | 0  | 1
1  | 1  | Undefined
{def}
{left}
{p} {p}
And the schematic:
{p} {p}
{center}
{image gfx/bistable1.iff}
{left}
{p} {p}
This logic circuit is useful because it can be easily controlled via TTL level computer signals. By 
ignoring the second output, and only using the first one, we have an output that can be turned 
on with one input (a button on the faceplate of your ATX case) and turned off with the other (by 
the computer, or a second button on the case).
{p} {p}
You might think the fact this logic stuff needs power to turn the computer on sounds a bit crazy. 
This is no problem, however, because ATX PSUs constantly supply 5v to pin 9, whether the PSU is 
on or off. That's why it is labelled 'stand-by', because it normally supplies current to the wintel 
ATX motherboard's logic circuits that control the on/ off/sleep stuff. A bit like the stand-by mode 
on a lot of TVs and VCRs.
{p} {p}
One point that should be made at this time is that I'm not sure if the logic outputs on our flip-
flop circuit could be put straight onto pin 14. The reason is that although I've seen lots of 
documentation saying "to get an ATX PSU to turn on without a mainboard, short ground to pin 
14", having pin 14 floating hooked up nowhere should have the same affect. In TTL, in my 
experience, both are usually counted as "0" (though TTL documentation states a logic 0 should be 
generated by a connection to ground), or at least, a non-connection should never be counted as 
"high" (logic 1).
{p} {p}
If we did hook the flip-flop straight up, a logic 0 should turn the PSU on safely because the 
output would conceptually be tied to ground, but a logic 1 would feed 5v back into PS_ON. By 
the looks of it, that probably never happens with normal ATX implementations, so I don't know 
what would really happen. It is for this reason I'm playing safe and using a NPN signal transistor 
to do the job of a SPDT switch.
{p} {p}
If you know anything about transistors, you know that when you use an NPN one as a switch, 
giving the base lead a small amount of current will cause the transistor to conduct through the 
emitter and collector. So if the PS_ON line is connected to the collector, the emitter to ground, 
and the base to the output on our flip-flop, we can turn our PSU on and off without losing any 
sleep.
{p} {p}
{center}
{image gfx/bistable2.iff}
{left}
{p} {p}
Now we have sufficient circuitry to turn the computer on and off with two 'soft' (momentary) 
push buttons. But how to control this with the computer?
{p} {p}
I'm going to do it with the parallel port. If you don't have a printer on your chipset's PAR: 
device, but use an I/O card instead (like me :) you could hook the 'off' input from our bistable to 
one of the 8 output lines. This way, whenever that output line was set to a logic 1, your 
computer would turn off. That's not a great idea, though, because you can't guarantee that 
rebooting or powering on won't momentarily turn ALL the inputs on. If it did, your computer 
would only blink on for a short time. Also, this renders your printer port useless for anything else.
{p} {p}
What we need is a "secret" combination of 8 binary digits that will turn off the computer. Once 
these 8 bits are set to this "off" code, a delay circuit should be triggered. The delay time can be 
set by changing the value of a capacitor or a trim pot (variable resistor) in the logic circuit we are 
building. Therefore, even if normal use of the printer port did hit our special off code, it wont' 
turn the machine off unless the code is held there for more than the amount of time we specify, 
say, 3 seconds. Hopefully, in theory, this means you will be able to print and use the parallel 
port normally, and this ATX control module will be totally transparent.
{p} {p}
{bold}In theory.{nobold}
{p} {p}
So, the 8 pins we are interested in on the printer port are pins 2-9 (D0-D7). These are outputs, as 
mentioned before, and are turned on by sending a single byte (8 bits) to a certain register or 
memory address (not sure on the Amiga, I've done it on PC..). Pins 25-17 should be connected to 
0v/ground on the rest of our ATX logic.
{p} {p}
Now we need to decide on the 'code' we want to send to the printer port. I propose 01011010. 
That's 5A in hex or 90 in decimal. The logic we now need merely has to have one output that 
will go high when the above code is present. This will start our delay circuit.
{p} {p}
{bold}8 bit activation code truth table:{nobold}
{p} {p}
{fixed}
D0| D1| D2| D3| D4| D5| D6| D7| Z0|
--+---+---+---+---+---+---+---+---+
 0|  1|  0|  1|  1|  0|  1|  0|  1|
 x|  x|  x|  x|  x|  x|  x|  x|  0|
{def}
{left}
{p} {p}
{p} {p}
I don't know how to do logical algebra, so you probably could do the same thing with less gates, but
here goes:
{p} {p}
{center}
{image gfx/codelogic.iff}
{left}
{p} {p}
As you can see, the logic is fairly simple to follow. All you have to do is remember the truth table 
of an AND gate:
{p} {p}
{bold}AND gate truth table:{nobold}
{p} {p}
{fixed}
X1| X2| Z0
--+---+---
 0|  0|  0
 0|  1|  0
 1|  0|  0
 1|  1|  1
{def}
{left}
{p} {p}
So an AND gate won't turn on unless both inputs are on. A NOT gate simply outputs the 
opposite of whatever it's input is.
{p} {p}
{bold}NOT gate truth table:{nobold}
{p} {p}
{fixed}
X1| Z0
--+---
 0|  1
 1|  0
{def}
{left}
{p} {p}
Now for the delay circuit. This is a simple setup, using a capacitor, with a resistor for discharge/charge
rate. Varying either capacitor or resistor will affect the 'delay' time. This 
circuit will activate it's output when it's input from the code logic has been on for long enough.
{p} {p}
It's probably not good practice to use logic signals to charge a cap in this way, I'll have a better solution
next issue, but for now my software simulator reports a current drain of 50uA max, which should be ok.
{p} {p}
Here is the schematic:
{p} {p}
{center}
{image gfx/delay.iff}
{left}
Now we've got the three circuits we need to control the PSU. The flip-flop for "soft" control; the 
code logic that will trap our 8 bit code whenever it pops up in the 8 output lines of the printer 
port; and the delay circuit, triggered by the code circuit, who's output will go to the input on the 
flip-flop. Phew! Now here is the final schematic of everything working together:
{p} {p}
{center}
{image gfx/ATX-softcontrol.iff}
{left}
{p} {p}
That concludes part 1 of this month's DIY Project. Hopefully next month there will be part 2, 
after I've put my own A4000 in an ATX case and written the software to control the circuitry. The 
software will be a small open source program written in C, and probably Pascal, or even  possibly E if I 
have time to learn enough of it. It will be a simple CLI program, "powerdown", and will send the 
8 bit code to the printer port, after running a CLI script if present. With the CLI script feature, you
could call other programs to delete files, empty .recycled, flush cache, and wait a few seconds before
terminating.
{p} {p}
Look out for Part 2 of this project next month!
{p} {p}
- Paul (paul@aio.co.uk)
{p} {p}
Disclaimer:
{p} {p}
To the best of my knowledge, everything presented here is accurate (why would I make stuff 
up?), and should work in theory, but that doesn't mean I'm right! This project could very well not 
work at all, let alone blast yourself and your computer into orbit, so use this information at your 
own risk! If you have any further questions, comments, or injury reports, drop me a mail!
{p} {p}
{p} {p}
{bold}Pinout of Amiga standard chipset parallel port:{nobold}
{p} {p}
{fixed}

   ,------------------------------------------,   Type: Female 25-pinD
   \  1  2  3  4  5  6  7  8  9  10 11 12 13 /    Used: Printer, Samplers,
    \  14 15 16 17 18 19 20 21 22 23 24 25  /           LED Display hack,
     '-------------------------------------'            QuickCam Interface
                                                        NOT Zip Drive!!!!!
{def}
{left}
{p} {p}
{fixed}

  1: _STROBE    Strobe                      14: +5V PULLUP  +5v DC (10mA)
  2: D0         Data Bit 0                  15: ---
  3: D1         Data Bit 1                  16: _RESET      Reset
  4: D2         Data Bit 2                  17: GND         Signal Ground
  5: D3         Data Bit 3                  18: GND         Signal Ground    
  6: D4         Data Bit 4                  19: GND         Signal Ground
  7: D5         Data Bit 5                  20: GND         Signal Ground
  8: D6         Data Bit 6                  21: GND         Signal Ground
  9: D7         Data Bit 7                  22: GND         Signal Ground
 10: _ACK       Acknowledge                 23: GND         Signal Ground
 11: BUSY       Busy                        24: GND         Signal Ground
 12: POUT       Paper Out                   25: GND         Signal Ground
 13: SEL        Select
{def}
{left}
Source: Amiga 1200 Hardware Guide by Chris Appleton (chrisf@pureamiga.co.uk)
{p} {p}
{p} {p}
{bold}Pinout of a typical ATX PSU:{nobold}
{p} {p}
{fixed}
Pin # Function Usual colour Description
---------------------------------------
1     3.3V     Orange
2     3.3V     Orange
3     GND      Black
4     5V       Red
5     GND      Black
6     5V       Red
7     GND      Black
8     PWR_OK   Grey         Active High
9     5VSB     Violet       Standby 5v
10    12V      Yellow
11    3.3V     Orange
12    -12V     Blue
13    GND      Black
14    PS_ON#   Green        Active Low
15    GND      Black
16    GND      Black
17    GND      Black
18    -5V      White/N.C.   * See note
19    5V       Red
20    5V       Red
{def}
{left}
{p} {p}
* Note 1: Pin 18, in Wintel land, is not needed for newer motherboards that don't have an ISA 
bus.  Therefore, there is a possibility that you could find an ATX PSU that lacks the wire going to pin 
18. In this case, your in strife, because your Amiga needs a -5v line to operate.
{p} {p}
  Note 2: As you can see, there are 4 5v lines coming out of that ATX PSU. Please do some 
research and select the one that has the biggest current capacity for powering your Amiga, or 
wait until Part 2 of this project.
{p} {p}
{bold}For Amiga 1200s in the keyboard case with external PSU:{nobold}
{p} {p}
{fixed}
Square PSU Plug:
----------------
Pin # Function
 1    +5v DC
 2     Shield Ground
*3    +12v DC
*4     0v/Ground
*5    -12v DC
{def}
{left}
{p} {p}
{bold}Amiga 4000 mainboard power pinout:{nobold}
{p} {p}
{fixed}
Motherboard Power Connector 
  +------+------+------+
  |Orange| Red  |Brown |   Power Good is a TTL output from the power supply,
  | +12V | -12V |PwrGd |   a logical high indicating a stable power supply.
  |------+------+------|
  |Yellow| Blue | Blue |
  | +5V  |Ground|Ground|
  +------+------+------+

...
{def}
{left}
{p} {p}
Source: Amiga 4000 Hardware guide by Warren Block (wblock@rapidnet.com).
{p} {p}

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
	<TITLE>AmigaScene 0x0C - Diskarchive</TITLE>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML;CHARSET=iso8859-1">
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#101010" LINK="#BF0000" VLINK="#101010" ALINK="#E04040">
	<TABLE WIDTH="100%" CELLPADDING=3 CELLSPACING=0 BORDER=0>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=TOP WIDTH="80%" HEIGHT=75>
				<A NAME="00" HREF="welcome.html"><IMG SRC="../images/_amiga.gif" WIDTH=125 HEIGHT=48 ALT="[Amiga]" ALIGN=RIGHT BORDER=0></A><A HREF="#99"><IMG SRC="../images/_krumm_lo.gif" WIDTH=37 HEIGHT=29 ALT="[Down]" ALIGN=LEFT BORDER=0></A>
				<BR CLEAR=ALL><BR>
				<TABLE ALIGN=CENTER WIDTH=170 BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=CENTER>
					<A HREF="../deutsch/0x00E5.html"><IMG WIDTH=16 HEIGHT=10 SRC="../images/__german.gif" ALT="[ german ]" BORDER=1></A>
				</TD></TR></TABLE>
 			</TD>
			<TD BGCOLOR="#BF0000" VALIGN=TOP ALIGN=RIGHT WIDTH=175>
				<A HREF="welcome.html"><IMG SRC="../images/_scene.gif" WIDTH=110 HEIGHT=47 ALT="[Scene]" ALIGN=LEFT BORDER=0></A>
				<A HREF="0x00E4.html"><IMG SRC="../images/_gerade_li.gif" WIDTH=22 HEIGHT=41 ALT="{" BORDER=0></A><A HREF="0x00E6.html"><IMG SRC="../images/_gerade_re.gif" WIDTH=23 HEIGHT=41 ALT="}" BORDER=0></A>
			</TD>
		</TR>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=MIDDLE ALIGN=CENTER>
				<CENTER>&nbsp;<BR>

					<IMG WIDTH=155 HEIGHT=25 SRC="../images/_workshop_.gif" ALT="[Workshop]">&nbsp;<BR><BR>

					<TABLE WIDTH="90%" BORDER=0>
						<TR><TD ALIGN=CENTER><FONT SIZE="-1">

| <A HREF="0x00E5.html">Diskarchive</A> |
<!--MENU-->

						</FONT></TD></TR>
					</TABLE>&nbsp;<BR>
				</CENTER>
			</TD>
			<TD BGCOLOR="#BF0000" VALIGN=TOP ALIGN=CENTER WIDTH=175 ROWSPAN=2>
				<CENTER>&nbsp;<BR>
					<IMG SRC="../images/__.gif" HEIGHT=1 WIDTH=175 ALT=" "><BR> 
					<A HREF="0x00DD.html"><IMG WIDTH=77  HEIGHT=25 SRC="../images/_cover.gif"     ALT="[Cover]"     BORDER=0></A><BR>
					<A HREF="0x00DE.html"><IMG WIDTH=117 HEIGHT=25 SRC="../images/_editorial.gif" ALT="[Editorial]" BORDER=0></A><BR>
					<A HREF="0x00DF.html"><IMG WIDTH=85  HEIGHT=25 SRC="../images/_inhalt.gif"    ALT="[Inhalt]"    BORDER=0></A><BR>
					<A HREF="0x00E0.html"><IMG WIDTH=70  HEIGHT=25 SRC="../images/_news.gif"      ALT="[News]"      BORDER=0></A><BR>
					<A HREF="0x00E1.html"><IMG WIDTH=131 HEIGHT=25 SRC="../images/_hardware.gif"  ALT="[Hardware]"  BORDER=0></A><BR>
					<A HREF="0x00E2.html"><IMG WIDTH=121 HEIGHT=25 SRC="../images/_software.gif"  ALT="[Software]"  BORDER=0></A><BR>
					<A HREF="0x00E5.html"><IMG WIDTH=135 HEIGHT=25 SRC="../images/_workshop.gif"  ALT="[Workshop]"  BORDER=0></A><BR>
					<A HREF="0x00E6.html"><IMG WIDTH=73  HEIGHT=25 SRC="../images/_spiele.gif"    ALT="[Spiele]"    BORDER=0></A><BR>
					<A HREF="0x00E8.html"><IMG WIDTH=91  HEIGHT=25 SRC="../images/_special.gif"   ALT="[Special]"   BORDER=0></A><BR>
					<A HREF="0x00EA.html"><IMG WIDTH=112 HEIGHT=25 SRC="../images/_feedback.gif"  ALT="[Feedback]"  BORDER=0></A><BR>
					<A HREF="0x00EB.html"><IMG WIDTH=46  HEIGHT=25 SRC="../images/_etc.gif"       ALT="[Etc]"       BORDER=0></A><BR>
				<BR></CENTER>
			</TD>
		</TR>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=TOP ALIGN=LEFT>

<BR><H1 ALIGN=LEFT><FONT FACE="Arial"><B>Diskarchive - Anmelden auf der Workbench</B></FONT></H1>&nbsp;

<BR><FONT SIZE="+1">Im letzten Teil des Workshops fassen wir das Wissen der
anderen Teile zusammen, um zu guter letzt mit einem Aufruf ein Archiv
scheinbar als Diskette anzumelden - als ob jemand eine eingelegt
h&auml;tte. Alles, was es dazu braucht, ist ein bi&szlig;chen Wissen
&uuml;ber ARexx und Eintr&auml;ge in die Mountlist.</FONT><BR>

<BR><CENTER><A NAME="01" HREF="#00"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#02"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR><H3><B>Voraussetzungen</B></H3>&nbsp;

<BR>F&uuml;r ein gutes Gelingen sollten folgende Dateien vorhanden
sein:<BR>

<BR><TABLE BORDER=0 CELLPADDING=8 CELLSPACING=0 ALIGN=CENTER WIDTH="90%">
<TR VALIGN=TOP ALIGN=LEFT><TD>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <TT>c:TransADF</TT> - von <A HREF="http://ftp.uni-paderborn.de/pub/aminet/disk/misc/TransADF.lha">aminet:disk/misc/TransADF.lha</A><BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <TT>c:dms</TT> - von <A HREF="http://ftp.uni-paderborn.de/pub/aminet/util/arc/dms111.run">aminet:util/arc/dms111.run</A><BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <TT>devs:fmsdisk.device</TT> - von <A HREF="http://ftp.uni-paderborn.de/pub/aminet/disk/misc/fmsdisk.lha">aminet:disk/misc/fmsdisk.lha</A><BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <TT>libs:rexxdossupport.library</TT> - von <A HREF="http://ftp.uni-paderborn.de/pub/aminet/util/rexx/rexxdossupport.lha">aminet:util/rexx/rexxdossupport.lha</A><BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <TT>rexx:MountDiskArchive.rexx</TT> - Teil dieses Workshops, siehe <A HREF="../images_0C/diskarcs.lha">MountDiskArchive.rexx</A><BR>
</TD></TR></TABLE>&nbsp;

<BR>Weiters braucht es ein Assign namens <TT>fms:</TT>, z.B. durch folgende
Zeile in der <TT>s:user-startup</TT>:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>assign fms: Work:fms
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Das entsprechende Verzeichnis mu&szlig; nat&uuml;rlich schon angelegt
sein, z.B. durch Eingabe im CLI von<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>makedir Work:fms
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Wer genauer wissen will, wozu das alles gut ist, der sei auf <A
HREF="0x00C7.html">Teil 1</A> und <A HREF="0x00D5.html">Teil 2</A> des
Workshops verwiesen Das im zweiten Teil bez&uuml;glich FMS beschriebene
kryptische Gepl&auml;nkel mit der Mountlist ist &uuml;brigens <I>nicht</I>
notwendig. Warum, wird unten erl&auml;utert.<BR>

<BR><CENTER><A NAME="02" HREF="#01"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#03"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR><H3><B>Bedienung</B></H3>&nbsp;

<BR>Bevor wir uns mit den Innereien besch&auml;ftigen, ist es wohl
interessanter zu erfahren, was man mit dem <A
HREF="../images_0C/diskarcs.lha">MountDiskArchive.rexx</a> Skript alles machen
kann.<BR>

<BR>Hauptzweck ist, ein Archiv in ein FMS-Ger&auml;t zu entpacken, ohne
irgendwelche zus&auml;tzlichen Parameter angeben zu m&uuml;ssen. Das Skript
ist schlau genug, anhand des Dateityps zu entscheiden, ob das Archiv an
<TT>TransADF</TT> oder an <TT>dms</TT> weitergegeben werden soll. Folgendes
ist also m&ouml;glich, sofern eine freie Diskette in <TT>df0:</TT>
eingelegt ist:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>rx MountDiskArchive sepp.dms df0:
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Und auch:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>rx MountDiskArchive sepp.adz df0:
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Das ist zwar nett, aber nichts, was nicht jeder halbwegs erfahrene
Amiganer mit drei Zeilen ARexx (oder weniger) machen k&ouml;nnte.<BR>

<BR>Praktischer ist schon folgender Aufruf:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>rx MountDiskArchive sepp.adz
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Es sollte sich etwa folgende Ausgabe zeigen:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>Mount &quot;ff0:&quot;
<BR>Extract &quot;sepp.adz&quot; to &quot;ff0:&quot;
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Und nach ein paar Sekunden hat die Workbench eine neue Disk namens
<TT>Sepp-Disk</TT> erhalten. Lustiger wird es, wenn man das Skript ein
weiteres mal aufruft, mit einem anderen Archiv als Parameter, z.B.<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>rx MountDiskArchive hugo.adz
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Es sollte sich etwa folgende Ausgabe zeigen:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>Mount &quot;ff1:&quot;
<BR>Extract &quot;hugo.adz&quot; to &quot;ff1:&quot;
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Was ist passiert? Offensichtlich erwartet das Skript zwei Parameter:
den Namen des Archivs und optional ein Ziellaufwerk, wohin es extrahiert
werden soll. Gibt man kein Ziellaufwerk an, so wird ein neues
FMS-Ger&auml;t angelegt, bevor das Archiv dorthin extrahiert wird.<BR>

<BR>Das Praktische an diesem k&uuml;nstlich angelegten FMS-Ger&auml;t ist,
da&szlig; man es nicht selbst anmelden (&quot;mounten&quot;) mu&szlig;.
Noch besser, man braucht &uuml;berhaupt nicht mit der
<TT>devs:Mountlist</TT> herumfuddeln. Das vereinfacht die FMS-Installation
betr&auml;chtlich.<BR>

<BR><CENTER><A NAME="03" HREF="#02"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#04"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR><H3><B>Verwendung in Directory Opus &amp; Co.</B></H3>&nbsp;

<BR>Der CLI zwar ganz nett zum herumexperimentieren, aber wen interessiert
schon das Eingeben eines Befehls? Viele Amiganer haben die Unbrauchbarkeit
der Workbench erkannt und bedienen sich gerne alternativer Programme wie
Directory Opus, Filer und wie sie alle hei&szlig;en m&ouml;gen.<BR>

<BR>Aus Gr&uuml;nden der Veranschaulichung beschreiben wir hier, wie man
das Skript in Directory Opus einbindet, soda&szlig; man ein DMS/ADF/ADZ
Archiv nur mehr zu doppelklicken braucht, und - schwupps - ist ein neues
Piktogramm auf der Workbench.<BR>

<BR>Zuerst mu&szlig; ein neuer Dateityp angelegt werden. Im Grunde gibt es
drei Formate f&uuml;r Diskarchive: DMS, ADF und AFZ. Die letzten beiden
lassen sich aus unserer Sicht zu einem zusammenfassen, weil beide mit dem
selben Programm, n&auml;mlich <TT>TransADF</TT>, verarbeitet werden.<BR>

<BR>Bei all seinen M&auml;ngeln hat DMS einen Vorteil: es ist einfach zu
erkennen, da die ersten vier Byte den Text &quot;<TT>DMS!</TT>&quot;
enthalten m&uuml;ssen.<BR>

<BR>Bei ADF ist es schon schwieriger, da es sich hier nur um eine
unstrukturierte Datenwurscht handelt. Man kann nicht einmal davon Ausgehen,
da&szlig; sie 880K (also 901120 Bytes) lang ist. Theoretisch k&ouml;nnte
man damit sogar ganze Festplattenpartitionen als ADF speichern (F&uuml;r
die meisten Anwedungsf&auml;lle ist man daf&uuml;r aber mit einem
Backup-Programm besser beraten).<BR>

<BR>Noch schlimmer wird es bei ADZ: hier gibt es zwar eine Art Dateikennung
am Anfang, nur ist es dieselbe wie bei den popul&auml;ren Packern ZIP und
GZip - weil eben derselbe Algorithmus zum Komprimieren verwendet wird. Es
w&auml;re nat&uuml;rlich wenig sinnvoll, jedes ZIP-Archive einmal
prophylaktisch als ADZ aufzufassen.<BR>

<BR>Alles, was hier bleibt, ist die Dateiendung: <TT>.adf</TT> oder
<TT>.adz</TT>. Das ist nat&uuml;rlich selten d&auml;mlich, aber mehr ist
Dank der &uuml;blichen Ad-hoc Programmierphilosophie der Unix-M&auml;nner
rund um Bernd &quot;UAE&quot; Schmidt leider nicht drin. Immerhin baut bei
uns nicht das ganze Betriebssystem seine Dateitypen an solchen Konzepten
auf (schlage nach bei Windows).<BR>

<BR>Der Autor von <TT>TransADF</TT> tr&auml;gt sich &uuml;brigens mit dem
Gedanken, einmal ein vern&uuml;nftiges, erweitertes ADF-Format zu
definieren. Das h&auml;tte dann am Anfang eine Kennung und Informationen
&uuml;ber die Gr&ouml;&szlig;e und die Struktur der gespeicherten Disk.
Rein technisch w&auml;re ja nicht viel dahinter. Nur hat sich ADZ
wahrscheinlich schon als &quot;Standard&quot; zu sehr etabliert. Aber
hoffen darf man ja noch.<BR>

<BR>Unabh&auml;ngig davon kann jetzt dennoch ein Dateityp f&uuml;r
Diskarchive definiert werden. Daten f&uuml;r die Eingabefelder sind hier
fett, Feldbezeichnungen sind in normalen Text:<BR>

<BR><TABLE BORDER=4 BGCOLOR="#EEEEEE" CELLPADDING=3 CELLSPACING=0 ALIGN=CENTER>
<TR>
  <TD>Name: <B>Diskarchiv</B></TD>
  <TD>ID: <B>DISKARC</B></TD>
  <TD>Pri: <B>0</B></TD>
</TR>
<TR>
  <TD COLSPAN="3"><B>Match DMS!</B><BR>
<B>Or</B><BR>
<B>Match Name #?.(adf|adz)</B></TD>
</TR>
</TABLE>&nbsp;

<BR>Danach bietet sich an, das Ereignis &quot;Doppelklick&quot; wie folgt
festzulegen:<BR>

<BR><TABLE BORDER=4 BGCOLOR="#EEEEEE" CELLPADDING=3 CELLSPACING=0 ALIGN=CENTER>
<TR>
  <TD>Type</TD>
  <TD>Befehl</TD>
</TR>
<TR>
  <TD><B>ARexx</B></TD>
  <TD><B>rexx:MountDiskArchive.rexx {f}</B></TD>
</TR>
<TR>
  <TD>Attribute</TD>
  <TD><B>Ausgabe in Fenster</B><BR>
 <B>Schlie&szlig;symbol</B></TD>
</TR>
</TABLE>&nbsp;

<BR>Die Argumentvariable {f} gibt die erste selektierte Datei an. Die
Attribute &quot;Ausgabe im Fenster&quot; und
&quot;Schlie&szlig;symbol&quot; sind deshalb gesetzt, damit im Falle eines
Fehlers dieser auch angezeigt wird - und nicht nur nichts passiert.<BR>

<BR>Das Ereignis &quot;Nehmen &amp; Ablegen&quot; k&ouml;nnte so
aussehen:<BR>

<BR><TABLE BORDER=4 BGCOLOR="#EEEEEE" CELLPADDING=3 CELLSPACING=0 ALIGN=CENTER>
<TR>
  <TD>Type</TD>
  <TD>Befehl</TD>
</TR>
<TR>
  <TD><B>ARexx</B></TD>
  <TD><B>rexx:MountDiskArchive.rexx {f} {d}</B></TD>
</TR>
<TR>
  <TD>Attribute</TD>
  <TD><B>Ausgabe in Fenster</B><BR>
 <B>Schlie&szlig;symbol</B></TD>
</TR>
</TABLE>&nbsp;

<BR>Dies erlaubt es, ein Archiv auf einem bereits existierenden
Disk-Piktogramm fallenzulassen. Nat&uuml;rlich mu&szlig; es sich um ein
Ger&auml;t mit einer Kapazit&auml;t von 880K handeln. Das kann eine Floppy,
ein FMS-Ger&auml;t oder eine richtig dimensionierte resetfeste Ram-Disk
sein. Mit &uuml;blicherweise gr&ouml;&szlig;eren Festplattenpartitionen
oder der normalen Ram-Disk haben TransADF und DMS nicht viel Freude.<BR>

<BR>Und weil wir gerade dabei sind, k&ouml;nnen sich Benutzer von Directory
Opus u.&Auml;. folgende Funktion definieren, um den Inhalt einer Disk in
<TT>df0:</TT> in einem ADZ-Archiv abzuspeichern. Dazu braucht man nicht
einmal ein ARexx-Skript:<BR>

<BR><TABLE BORDER=4 BGCOLOR="#EEEEEE" CELLPADDING=3 CELLSPACING=0 ALIGN=CENTER>
<TR>
  <TD>Type</TD>
  <TD>Befehl</TD>
</TR>
<TR>
  <TD><B>AmigaDOS</B></TD>
  <TD><B>TransADF df0: {RFADZ speichern:ram:.adz} GZip</B></TD>
</TR>
<TR>
  <TD>Attribute</TD>
  <TD><B>Ausgabe in Fenster</B><BR>
 <B>Schlie&szlig;symbol</B></TD>
</TR>
</TABLE>&nbsp;

<BR>Die Argumentvariable {RF} &ouml;ffnet ein Dateiauswahlfenster, in dem
man den Namen angeben kann, unter dem das Archiv gespeichert werden soll.
Vorzugsweise sollte er die Endung <TT>.adz</TT> erhalten, darum ist sie im
Namensfeld des Fensters gleich eingetragen. Als Vorgabe des
Zielverzeichnisses wird hier <TT>ram:</TT> verwendet, was nat&uuml;rlich
jeder f&uuml;r sich &auml;ndern kann. Am besten aufgehoben ist so eine
Funktion wahrscheinlich in einem Benutzermen&uuml;.<BR>

<BR><CENTER><A NAME="04" HREF="#03"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#05"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR><H3><B>Hinter den Kulissen</B></H3>&nbsp;

<BR>F&uuml;r Interessierte folgt hier noch eine Erl&auml;uterung, wie die
Sache intern abl&auml;uft. Die ersten paar Zeilen sollten f&uuml;r jeden
mit etwas ARexx-Erfahrung verst&auml;ndlich sein: Sie pr&uuml;fen die
Parameter, k&uuml;mmern sich um Fehler und zeigen gegebenenfalls einen
kurzen Hilfstext an. Wenn alles glatt lief, enth&auml;lt die Variable
<TT>archive_name</TT> den Dateinamen (z.B. &quot;<TT>sepp.adz</TT>&quot;),
<TT>suffix</TT> die Endung (z.B. &quot;<TT>ADZ</TT>) und
<TT>drive_name</TT> das Ger&auml;t, auf das extrahiert werden soll (z.B.
&quot;<TT>df0:</TT>&quot;).<BR>

<BR>Interessant f&uuml;r den Ablauf sind folgende Zeilen:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>if drive_name = '' then do
<BR>&nbsp;&nbsp;&nbsp;drive_name = mount_new_drive()
<BR>end
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Wurde kein Zielger&auml;t angegeben, so wird ein neues angelegt.
Daf&uuml;r zust&auml;ndig ist die Prozedur <TT>mount_new_drive()</TT>.
Diese Routine ist eines genaueren Blickes w&uuml;rdig. Zuerst wird nach
einem noch nicht existenten FMS-Ger&auml;t gesucht. Das geht leicht, indem
man zuerst schaut, ob <TT>ff0:</TT> angelegt ist. Wenn ja, probieren wir es
mit <TT>ff1:</TT>, wenn das auch schon da ist, mit <TT>ff2:</TT> und so
weiter. Folgende Schleife macht genau das:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>new_drive_unit = -1
<BR>unused_device_found = 0
<BR>
<BR>do until unused_device_found
<BR>&nbsp;&nbsp;&nbsp;new_drive_unit = new_drive_unit + 1
<BR>&nbsp;&nbsp;&nbsp;new_drive_name = 'ff' || new_drive_unit || ':'
<BR>&nbsp;&nbsp;&nbsp;unused_device_found = ~drive_exists(new_drive_name)
<BR>end
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Als Ergebnis enth&auml;lt die Variable <TT>new_drive_unit</TT> die
Zahl, die das anzulegende Ger&auml;t angibt. Ein Wert von 0 entspricht also
dem Ger&auml;tenamen <TT>ff0:</TT>, 1 w&auml;re <TT>ff1:</TT> und so
weiter. Eben dieser Name wird in <TT>new_drive_name</TT> abgelegt.<BR>

<BR>Danach wird es etwas gefinkelt. Jetzt wird n&auml;mlich ein
Mountlist-Eintrag f&uuml;r das neue FMS-Ger&auml;t erzeugt. Vorerst wird
dieser nur in einer Zeichenkette namens <TT>mount_entry</TT>
gespeichert:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>&nbsp;&nbsp;&nbsp;mount_entry = '/* $VER: ff' || new_drive_unit ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| ' 37.0 (' || version_date || ') */' || lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| new_drive_name || lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| '&nbsp;&nbsp;&nbsp;Device&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= fmsdisk.device' || lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| '&nbsp;&nbsp;&nbsp;Unit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= ' || new_drive_unit || lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| '&nbsp;&nbsp;&nbsp;Flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1'&nbsp;&nbsp;|| lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| '&nbsp;&nbsp;&nbsp;Surfaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 2'&nbsp;&nbsp;|| lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| '&nbsp;&nbsp;&nbsp;BlocksPerTrack = 11' || lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| '&nbsp;&nbsp;&nbsp;Reserved&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 2'&nbsp;&nbsp;|| lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| '&nbsp;&nbsp;&nbsp;Interleave&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0'&nbsp;&nbsp;|| lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| '&nbsp;&nbsp;&nbsp;LowCyl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0'&nbsp;&nbsp;|| lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| '&nbsp;&nbsp;&nbsp;HighCyl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 79' || lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| '&nbsp;&nbsp;&nbsp;Buffers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 2'&nbsp;&nbsp;|| lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| '&nbsp;&nbsp;&nbsp;BufMemType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0'&nbsp;&nbsp;|| lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| '#' || lf
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Um diese lange Zuweisung &uuml;bersichtlicher zu machen, ist sie auf
mehrere Zeilen verteilt. Jede Zeile endet aber mit einem Komma (,),
soda&szlig; die derzeitige und die n&auml;chste Zeile als eine einzige
zusammengeh&ouml;rende aufgefa&szlig;t werden.<BR>

<BR>Die Variable <TT>lf</TT> enth&auml;lt ein einzelnes Zeichen,
n&auml;mlich ein &quot;linefeed&quot;, also jenes Zeichen, das einem
Dr&uuml;cken der Enter-Taste entspricht. Sie wurde am Anfang des Programms
gesetzt:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>lf = d2c(10)
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>F&uuml;r <TT>ff0:</TT> w&uuml;rde <TT>mount_entry</TT> daher folgenden
Inhalt haben:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>/* $VER: ff0 37.0 (4.1.99) */
<BR>ff0:
<BR>&nbsp;&nbsp;&nbsp;Device&nbsp;&nbsp;= fmsdisk.device
<BR>&nbsp;&nbsp;&nbsp;Unit &nbsp;&nbsp;= 0
<BR>&nbsp;&nbsp;&nbsp;Flags&nbsp;&nbsp;= 1
<BR>&nbsp;&nbsp;&nbsp;Surfaces&nbsp;&nbsp;= 2
<BR>&nbsp;&nbsp;&nbsp;BlocksPerTrack = 11
<BR>&nbsp;&nbsp;&nbsp;Reserved&nbsp;&nbsp;= 2
<BR>&nbsp;&nbsp;&nbsp;Interleave&nbsp;&nbsp;= 0
<BR>&nbsp;&nbsp;&nbsp;LowCyl&nbsp;&nbsp;= 0
<BR>&nbsp;&nbsp;&nbsp;HighCyl&nbsp;&nbsp;= 79
<BR>&nbsp;&nbsp;&nbsp;Buffers&nbsp;&nbsp;= 2
<BR>&nbsp;&nbsp;&nbsp;BufMemType&nbsp;&nbsp;= 0
<BR>#
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Die genaue Bedeutung dieser Zeilen mu&szlig; nicht unbedingt jedem klar
sein. Wichtig ist nur, das <TT>Device</TT> den Wert <TT>fmsdisk.device</TT>
enth&auml;lt, und <TT>Unit</TT> den Inhalt der Variable
<TT>new_device_unit</TT>. Der Name, hier <TT>ff0:</TT>, wird am Anfang
festgelegt und der Variable <TT>new_device_name</TT> entnommen. All die
anderen Felder geben im Grunde nur an, da&szlig; es sich um ein Ger&auml;t
mit einer Kapazit&auml;t von 880K handelt. Wer mehr dar&uuml;ber wissen
will, der sei an die AmigaDOS Dokumentation verwiesen.<BR>

<BR>Folgende Zeilen schreiben den Inhalt von <TT>mount_entry</TT> in eine
tempor&auml;re Datei:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>mount_filename = 't:Mountlist.ff' || new_drive_unit
<BR>if Open('mount_file', mount_filename, 'write') then do
<BR>&nbsp;&nbsp;&nbsp;WriteCh('mount_file', mount_entry)
<BR>&nbsp;&nbsp;&nbsp;Close('mount_file')
<BR>end
<BR>else do
<BR>&nbsp;&nbsp;&nbsp;exit_error('could not write &quot;' || mount_filename || '&quot;', 20)
<BR>end
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Enth&auml;lt <TT>drive_unit</TT> den Wert 0, so wird die Datei
<TT>t:Mountlist.ff0</TT> angelegt. Dabei handelt es sich im einen kleinen
Bruder von <TT>devs:Mountlist</TT>, der nur einen einzigen Eintrag
enth&auml;lt, n&auml;mlich den f&uuml;r <TT>ff0:</TT>.<BR>

<BR>Jetzt k&ouml;nnte man im CLI mit folgendem Befehl selbiges Ger&auml;t
anmelden:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>mount ff0: from t:Mountlist.ff0
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Das erledigt in unserem Fall nat&uuml;rlich das Skript. Da die
tempor&auml;re Mountlist nicht mehr gebraucht wird, wird sie gleich danach
gel&ouml;scht. Im Grunde bedarf dies nur eines Aufrufs von <TT>Address
Command</TT> und etwas Wissen &uuml;ber den entsprechenden CLI-Befehl. Die
<TT>Delete()</TT> Funktion ist aus der <TT>rexxsupport.library</TT>.<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>address_command(0, 'c:mount ' || new_drive_name || ' from ' || mount_filename)
<BR>Delete(mount_filename)
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Um die Fehlerbehandlung zu vereinfachen, wird hier eine Prozedur namens
<TT>address_command()</TT> verwendet. Die nimmt als ersten Parameter den
erwarteten maximalen R&uuml;ckgabewert und bricht das Skript ab, falls der
CLI-Befehl einen gr&ouml;&szlig;eren Wert liefert. Zus&auml;tzlich wird die
Ausgabe des auszuf&uuml;hrenden Befehls mittels
&quot;<TT>&gt;&gt;</TT>&quot; an ein <I>Logfile</I> angeh&auml;ngt, auf
dessen Bedeutung weiter unten n&auml;her eingegangen wird. &Uuml;brigens
sorgt <TT>Address Command</TT> automatisch daf&uuml;r, da&szlig; der
R&uuml;ckgabewert des letzten ausgef&uuml;hrten Befehls in der globalen
Variable <TT>RC</TT> gespeichert wird:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>address_command:
<BR>&nbsp;&nbsp;&nbsp;Parse Arg maximum_rc, cli_command
<BR>
<BR>&nbsp;&nbsp;&nbsp;Options FailAt maximum_rc + 1
<BR>&nbsp;&nbsp;&nbsp;Address Command cli_command || ' &gt;&gt;' || log_filename
<BR>
<BR>&nbsp;&nbsp;&nbsp;Return RC
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Danach ist das neue Ger&auml;t fertig, um benutzt zu werden. Das
eigentliche Extrahieren des Archives abh&auml;ngig von der Dateiendung ist
simpel:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>select
<BR>&nbsp;&nbsp;&nbsp;when filetype = 'ADF' then do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unpack_command = 'TransADF Write ' || drive_name || ' ' || archive_name
<BR>&nbsp;&nbsp;&nbsp;end
<BR>&nbsp;&nbsp;&nbsp;when filetype = 'DMS' then do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unpack_command = 'dms &lt;nil: Write ' || archive_name || ' To ' ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| drive_name || ' NoText'
<BR>&nbsp;&nbsp;&nbsp;end
<BR>&nbsp;&nbsp;&nbsp;otherwise do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signal Bug /* Invalid filetype */
<BR>&nbsp;&nbsp;&nbsp;end
<BR>end
<BR>address_command(0, unpack_command)
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Der Aufruf von &quot;<TT>dms &lt;nil:rx ...</TT>&quot; bedient sich
eines kleines Tricks: Dies gibt n&auml;mlich an, da&szlig; <TT>dms</TT>
Tastatureingaben von <TT>nil:</TT> lesen soll. Dabei handelt es sich
bekanntlich um das sogenannte <I>Null-Device</I>, das physikalisch gar
nicht existiert. Wozu soll das gut sein? Vor dem eigentlichen Loswerkeln
wartet <TT>dms</TT> n&auml;mlich auf einen Druck der Enter Taste. Das
erm&ouml;glicht die Verwendung auf Rechnern mit nur einem Laufwerk und ohne
Festplatte. In unserem Fall mu&szlig; das FMS-Ger&auml;t nat&uuml;rlich
nicht eingelegt werden, und ein jedesmal Enter dr&uuml;cken will auch
niemand, wenn ein Archive entpackt werden soll.<BR>

<BR>Der Clou ist: Weil <TT>nil:</TT> beim Lesen immer eine &quot;Ende der
Datei&quot;-Kennung zur&uuml;ckgibt, gibt sich <TT>dms</TT> damit zufrieden
- genauso, als ob Enter das Ende einer Tastatureingabe angegeben
h&auml;tte. <TT>TransADF</TT> werkt &uuml;brigens auch ohne gutes Zureden,
hier reicht der normale Aufruf.<BR>

<BR><CENTER><A NAME="05" HREF="#04"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#06"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR><H3><B>Hallo, Laufwerk! Jemand zuhause?</B></H3>&nbsp;

<BR>Einer genaueren Erl&auml;uterung bedarf noch die schon zuvor
angesprochene Funktion <TT>drive_exists()</TT>. Eigentlich w&uuml;rde ARexx
mit <TT>exists()</TT> bereits eine Standardfunktion zur Verf&uuml;gung
stellen, die nicht nur f&uuml;r Dateien, sondern auch Ger&auml;te
funktioniert. Dabei zeigen sich aber zwei Probleme:<BR>

<BR>Erstens &ouml;ffnet <TT>exists()</TT> ein Dialogfenster, das bittet,
die entsprechende Disk einzulegen, falls ein Ger&auml;t <I>eben nicht</I>
existiert. Das ist nat&uuml;rlich hier wenig sinnvoll, weil das Skript ja
immer sucht, bis ein Ger&auml;t nicht existiert. Dem k&ouml;nnte man
entgegenwirken, indem man mit dem weniger bekannten <TT>Pragma('Window',
...)</TT> jene Dialogfenster ausschaltet.<BR>

<BR>Zus&auml;tzlich aber funktioniert die Standardfunktion
<TT>exists()</TT> nur mit &quot;normalen&quot; DOS-Laufwerken. Viele
Diskarchive enthalten jedoch Demos und Spiele mit eigenen Formaten. Diese
werden von <TT>exists()</TT> als nicht vorhanden angesehen. Bevor man auch
daf&uuml;r einen Workaround sucht (z.B. basierend auf &quot;<TT>Address
Command 'assign exists ff0:'</TT>&quot;) lohnt es sich, gleich einen
anderen Ansatz zu verwenden.<BR>

<BR>Dieser basiert auf der Funktion <TT>ShowList()</TT>, die in der
<TT>rexxsupport.library</TT> enthalten ist. Diese Bibliothek ist von Haus
aus bei jedem AmigaOS dabei, stellt also keine erweiterten Voraussetzungen
dar.<BR>

<BR><TT>ShowList()</TT> erlaubt es u.a., diverse systeminterne Listen nach
bestimmten Eintr&auml;gen zu untersuchen. Ein Aufruf erfolgt nach dem
Schema<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>found = ShowList(list, entry)
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Die Variable <TT>found</TT> enth&auml;lt dann 1, wenn <TT>entry</TT> in
der mit <TT>list</TT> spezifizierten Liste enthalten war. F&uuml;r uns
interessant sind folgende Listen:<BR>

<BR><TABLE BORDER=0 CELLPADDING=8 CELLSPACING=0 ALIGN=CENTER WIDTH="90%">
<TR VALIGN=TOP ALIGN=LEFT><TD>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <TT>Assign</TT> - derzeit definierten Assigns<BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <TT>Volume</TT> - angemeldeten Ger&auml;te mit ihrem Namen, z.B. &quot;Workbench&quot; und &quot;Ram Disk&quot;<BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <TT>Handler</TT> - angemeldete Ger&auml;te mit ihrem AmigaDOS-internen Namen, z.B. &quot;DH0&quot; und &quot;RAM&quot;.<BR>
</TD></TR></TABLE>&nbsp;

<BR>Wichtig ist vor allem die <TT>Handler</TT> Liste, weil sie auch
unformatierte Disks enth&auml;lt, die <TT>exists()</TT> nicht finden
w&uuml;rde. Streng genommen br&auml;uchten wir die anderen beiden Listen
gar nicht anzusehen. Wir tun es aber trotzdem, um Komplikationen zu
vermeiden falls ein Benutzer aus irgendwelchen Gr&uuml;nden einen Assign
oder eine Partition mit einem Namen wie <TT>ff0:</TT> belegt hat.<BR>

<BR>Etwas Vorsicht ist noch angebracht, da die Namen in diesen Listen
keinen Doppelpunkt (:) enthalten. Dieser mu&szlig; also zuvor von
<TT>drive_name</TT> entfernt werden. Au&szlig;erdem sind alle Eintr&auml;ge
in der Liste in Gro&szlig;schrift, soda&szlig; <TT>drive_name</TT> zuvor
umgewandelt werden mu&szlig;. Beides l&auml;&szlig;t sich praktischerweise
gleich bei der Auswertung der Parameter erledigen:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>drive_exists: procedure
<BR>&nbsp;&nbsp;&nbsp;Parse Upper Arg drive_name ':'
<BR>
<BR>&nbsp;&nbsp;&nbsp;drive_exists = ShowList('Handler', drive_name) | ,
<BR>&nbsp;&nbsp;ShowList('Volume', drive_name) | ,
<BR>&nbsp;&nbsp;ShowList('Assign', drive_name)
<BR>
<BR>&nbsp;&nbsp;&nbsp;Return drive_exists
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Damit sollte die Grundstruktur klar sein. Ein paar Feinheiten sind
vielleicht doch noch eine Erw&auml;hnung wert:<BR>

<BR><CENTER><A NAME="06" HREF="#05"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#07"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR><H3><B>Ein paar Kleinigkeiten</B></H3>&nbsp;

<BR>Das Skript wartet ein Logfile, in dem es mitprotokoliert, was so alles
passiert. Dies wird in eine Datei namens <TT>t:MountDiskArchive.log</TT>
geschrieben. Normalerweise wird das Logfile am Ende gel&ouml;scht,
au&szlig;er es tritt ein Fehler auf oder der Schalter <TT>Debug</TT> wurde
beim Aufruf des Skripts gesetzt. In so einem Fall kann man es sich ansehen.
F&uuml;r Leute, die gerne mit dem Skript herumspielen oder etwaige Bugs
einkreisen wollen, kann das von Interesse sein. F&uuml;r das Protokollieren
zust&auml;ndig sind &uuml;brigens die beiden Prozeduren
<TT>append_log_line()</TT> und <TT>append_log_heading()</TT>.
Zus&auml;tzlich sorgt <TT>address_command()</TT> daf&uuml;r, da&szlig;
CLI-Befehle ihre Ausgabe dort dranh&auml;ngen.<BR>

<BR>Weil die meisten Amiganer Multitasking gewohnt sind, kann leicht jemand
versucht sein, nebeneinander mehrere Archive anzumelden. F&uuml;r die
meisten Aktionen, die das Skript ausf&uuml;hrt, ist es egal, wieviele
Skripts zur selben Zeit das machen. Bei anderen Dingen darf sich der
Benutzer nicht wundern, wenn es nicht klappt, z.B. wenn er versucht, drei
verschiedene Archive gleichzeitig als <TT>df0:</TT> anzumelden. F&uuml;r
solche F&auml;lle haben <TT>TransADF</TT> und <TT>dms</TT> vorgesorgt.<BR>

<BR>Anders verh&auml;lt es sich jedoch beim automatischen Anmelden eines
neuen FMS-Ger&auml;ts. Daf&uuml;r ist nur unser Skript zust&auml;ndig.
Theoretisch k&ouml;nnte das Skript zweimal laufen und praktisch
gleichzeitig zu der Entscheidung kommen, da&szlig; z.B. <TT>ff3:</TT>
angelegt werden mu&szlig;. Versuchen jetzt aber beide Skripts, ein<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>mount ff3: from t:Mountlist.ff3
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>so pr&auml;sentiert sich dem Benutzer ein etwas lapidares<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>ERROR: Device 'ff3:' is already mounted
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Weil die meisten nicht wissen werden (und gar nicht wissen wollen), wie
das Programm funktioniert, hilft diese Meldung nicht viel weiter. Das
Problem lie&szlig;e sich eigentlich einfach l&ouml;sen, indem man das
Skript nach kurzer Zeit nochmals mit den selben Parametern aufruft.<BR>

<BR>Um dem vorzubeugen, mu&szlig; die bereits behandelte Funktion
<TT>mount_new_drive()</TT> einen eingebauten Schutz kriegen, soda&szlig;
sie nur einmal zur selben Zeit laufen kann. Im Grunde gibt es zwei
Ans&auml;tze, um das zu l&ouml;sen:<BR>

<BR>Erstens kann man brachial das Multitasking ausschalten. Dazu g&auml;be
es <TT>Forbid()</TT> und <TT>Permit()</TT>. Das ist aber selten eine
elegante L&ouml;sung, vor allem nicht in ARexx, da&szlig; bei seinen
gem&auml;chlichen Ausf&uuml;hrungszeiten schon mal ein paar Sekunden den
Rechner stehen lassen k&ouml;nnte.<BR>

<BR>Besser ist es, eine Art &quot;systemweite&quot; Variable
einzuf&uuml;hren, die ein Skript f&uuml;r sich reservieren mu&szlig;. War
zuvor schon ein Skript schneller damit, so wei&szlig; das n&auml;chste
Skript, da&szlig; es nicht alleine ist - und kann diesen Umstand mit einer
wesentlich konstruktiveren Meldung kundtun.<BR>

<BR>Eine Datenstruktur, die solche eine systemweite Variable mit
Zugriffregelung zul&auml;&szlig;t ein &ouml;ffentlicher Message-Port. Zwar
kann man damit einiges mehr anstellen, f&uuml;r unsere Zwecke reicht aber
folgendes:<BR>

<BR>Mit <TT>OpenPort(name)</TT> wird ein neuer Port mit dem Namen
<TT>name</TT> angelegt und der Wert 1 zur&uuml;ckgeliefert. Existiert so
ein Port aber bereits, so wird er nicht erneut angelegt, sondern nur 0
zur&uuml;ckgeliefert. Das erlaubt folgende Kontrolle am Anfang von
<TT>mount_new_drive()</TT>:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>semaphore_port = 'MountDiskArchive.semaphore'
<BR>If ~OpenPort(semaphore_port) then do
<BR>&nbsp;&nbsp;&nbsp;exit_error('Another instance of this script is already attempting to ' ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| 'mount a new FMS drive' || lf ,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| 'Wait until it is finished, then try again', 10)
<BR>end
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Nach getaner Arbeit kann man den Port wieder schlie&szlig;en:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>ClosePort(semaphore_port)
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Eine kleine Unsch&ouml;nheit ist wie gesagt, da&szlig; hier mit Kanonen
auf Spatzen geschossen wird. Ein Message-Port ist in Wahrheit eine komplexe
Datenstruktur, die es erlaubt, zwischen verschiedenen Tasks Nachrichten
auszutauschen. So ist z.B. jeder ARexx-Port, an den man Befehle schicken
kann, so ein Message-Port.<BR>

<BR>Wir aber mi&szlig;brauchen ihn mangels besserer Alternativen als eine
simple systemweite Variable mit eingebauter Zugriffsregelung. Normalerweise
nennt man so einen Mechanismus <I>Semaphore</I>. Die kann das AmigaOS zwar
auch, nur kann man sie hier nicht so sch&ouml;n mit einem Namen ansprechen,
sondern mu&szlig; mit den aus anderen Programmiersprachen ber&uuml;chtigten
Zeigern (pointer) herumwurschteln. Au&szlig;erdem wei&szlig; ein Task nicht
von Anfang an, wo genau eine solche Semaphore anzufinden ist. Alles Dinge,
mit denen sich ein gelegentlicher ARexx-Programmierer lieber nicht
besch&auml;ftigen will, darum findet sich auch kein &Auml;quivalent
daf&uuml;r in der <TT>rexxsupport.library</TT>.<BR>

<BR><CENTER><A NAME="07" HREF="#06"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#08"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR><H3><B>Besser als MountImage?</B></H3>&nbsp;

<BR>Im ersten Teil wurde kurz MountImage der Apfelm&auml;nner, das
gro&szlig;e Vorbild aller Diskarchivprogramme, angesprochen. Vergleicht man
unser kleines ARexx-Skript damit, so mu&szlig; man feststellen, da&szlig;
das Vorbild nicht ganz erreicht wurde.<BR>

<BR>Zwar ist die Anzahl der gleichzeitig angemeldeten Archive nur von der
Festplattengr&ouml;&szlig;e eingeschr&auml;nkt, und die Bedienung ist nach
Einbindung in DOpus und Verwandte auch kinderleicht - nix mehr CLI und
kryptische Optionen.<BR>

<BR>Vorteilhaft wirkt sich auch die Tatsache aus, da&szlig; es trivial ist,
etwaige zuk&uuml;nftige Diskarchivformate zu unterst&uuml;tzen. Denn obwohl
ADZ etliche M&auml;ngel von ADF und DMS behebt, so fehlt wie bereits
er&ouml;rtert noch einiges wie z.B. ein Header, der &uuml;ber die
Blockstruktur der gespeicherten Disk Auskunft gibt.<BR>

<BR>Ein gro&szlig;er Nachteil des Skripts ist die Tatsache, da&szlig; man
ein Archive nicht wieder &quot;abmelden&quot; kann. Das hei&szlig;t, der
Platz in <TT>fms:</TT> bleibt belegt, selbst nach einem Reset. Denn obwohl
ein etwaiges <TT>ff0:</TT> nur tempor&auml;r angelegt und angemeldet wird,
so bleibt das entsprechende <TT>fms:Unit0</TT> erhalten. Dazu gibt es drei
L&ouml;sungsans&auml;tze: erstens, die Platte ist gro&szlig; genug und es
ist einem wurscht wenn 20MB herumverfilzen, zweitens kann man in der
<TT>s:user-startup</TT> ein &quot;<TT>delete quiet fms:Unit#?</TT>&quot;
machen und unerw&uuml;nschte Nebenwirkungen zumindest beim n&auml;chsten
Neustart beseitigen oder drittens dekadent sein und sagen: &quot;<TT>assign
fms: t:</TT>&quot;. Letzteres ist wohl nur f&uuml;r Leute mit viel RAM
interessant.<BR>

<BR>Unlustig ist das Verhalten von FMS, wenn man versucht, dasselbe Archiv
auf mehrere FMS-Ger&auml;ten anzumelden oder wenn zwei Disks den selben
Namen haben. Auch wenn das nicht unbedingt sinnvoll ist, so ist es doch
eine Unsch&ouml;nheit in FMS.<BR>

<BR>Weiters ist die Fehlerbehandlung nicht ganz astrein wenn man versucht,
ein Archiv auf ein Ger&auml;t zu extrahieren, da&szlig; dies nicht
unterst&uuml;tzt:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>rx MountDiskArchive sepp.adz ram:
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Daraufhin pr&auml;sentiert sich uns folgende Ausgabe:<BR>

<BR><TABLE ALIGN=CENTER BORDER=0 BGCOLOR="#EEEEEE" WIDTH="90%"><TR VALIGN=TOP><TD ALIGN=LEFT><TT>
<BR>Extract &quot;sepp.adz&quot; to &quot;ram:&quot;
<BR>TransADF: Error - Don't know how to talk to ram:.
<BR>TransADF failed returncode 20
<BR>Command returned 20
<BR>
<BR></TT></TD></TR></TABLE>&nbsp;

<BR>Zwar enth&auml;lt die zweite Zeile - TransADF sei dank - eine
einigerma&szlig;en brauchbare Beschreibung des Problems, nur geht dies
etwas unter in den beiden (v&ouml;llig redundanten) folgenden Zeilen.
Wirklich am&uuml;sant wird es, wenn man das gleiche mit <TT>dms</TT>
versucht: da kommt dann n&auml;mlich die b&ouml;se Endlosschleife, bis nach
einiger Zeit der Speicher ausgeht... Hier mu&szlig; leider der Benutzer
f&uuml;r den Programmierer denken.<BR>

<BR><CENTER><A NAME="08" HREF="#07"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#99"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR><H3><B>Fazit</B></H3>&nbsp;

<BR>Wir verbeugen uns also vor den Apfelm&auml;nnern und r&auml;umen ein,
da&szlig; wir von ihnen noch was lernen k&ouml;nnen. Nichtdestotrotz haben
wir mit ein paar Zeilen ARexx ein halbwegs vergleichbares Ergebnis mit
zugegeben einigen unsch&ouml;nen Kratzern erreicht. Bei den
Apfelm&auml;nner braucht es dazu etliche Kilobyte gefinkelte
Systemprogrammierung in Unsprachen wie C.<BR>

<BR>Das Ergebnis spricht wieder einmal daf&uuml;r, das der Amiga ein
Rechner ist, der gerne um den Benutzer herum w&auml;chst. Dabei mu&szlig;
man aber nicht entweder warten, bis jemand einen doddlsicheren Fertigteil
produziert oder etwa in nicht endendwollende Untiefen kryptischer und
unaussprechbarer Befehlszeilen und schlechter Dokumentation eintauchen.
Flexibilit&auml;t mu&szlig; nicht nur Shell-Machos vorbehalten bleiben.<BR>

<BR>Das beliebte Trio CLI/ARexx/Workbench-Ersatz hat es einmal mehr
erlaubt, mit wenig Aufwand und ohne gro&szlig;es Dazulernen neuer Konzepte,
Durchprobieren von Konfigurationsoptionen und Anwenden von 76432
verschiedenen Skript- und Macrosprachen selbst komplizierte Abl&auml;ufe
auf einen Doppelklick zu reduzieren. Sogar, wenn man dabei &uuml;ber 10
Jahre Geschichte Revue passieren lassen kann und Dinge verbindet, die nie
dazu gedacht waren, zusammenzuarbeiten.<BR>

<!--END-->

			<BR>
			</TD>
		</TR>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=TOP ALIGN=LEFT>
				<P ALIGN=RIGHT>

					<A HREF="as-redax.html#agi">Thomas Aglassinger</A>
					&nbsp;&nbsp;&nbsp;
					<A HREF="../deutsch/0x00E5.html"><IMG WIDTH=16 HEIGHT=10 SRC="../images/__german.gif" ALT="[ german ]" VSPACE=0 HSPACE=0 BORDER=1></A>
					&nbsp;&nbsp;&nbsp;
					<BR>

				</P>
<!--E_MAIL-->
				<BR><TABLE BORDER=0 CELLPADDING=8 CELLSPACING=0 ALIGN=CENTER WIDTH="90%">
				<TR VALIGN=TOP ALIGN=LEFT><TD>

<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="../images_0C/diskarcs.lha">MountDiskArchive.rexx</A> - Das Skript zum Workshop<BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="0x00C7.html">Teil 1: ADF, ADZ</A> - Erster Teil des Workshops<BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="0x00D5.html">Teil 2: DMS, FMS</A> - Zweiter Teil des Workshops<BR>

				</TD></TR>
				</TABLE>
<!--BOTTOM-->
<!--BANNER-->
			</TD>
			<TD BGCOLOR="#BF0000" VALIGN=TOP ALIGN=CENTER> &nbsp; 
<!--REDBOT-->
			</TD>
		</TR>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=MIDDLE ALIGN=LEFT>
				<A HREF="#00"><IMG SRC="../images/_krumm_hi.gif" WIDTH=37 HEIGHT=29 BORDER=0 ALT="[Up]"></A>
				<A NAME="99"><FONT COLOR="#FFFFFF">&nbsp;</FONT></A>
			</TD>
			<TD BGCOLOR="#BF0000" VALIGN=BOTTOM ALIGN=RIGHT>
				<A HREF="0x00E4.html"><IMG SRC="../images/_gerade_li.gif" WIDTH=22 HEIGHT=41 ALT="{" BORDER=0></A><A HREF="0x00E6.html"><IMG SRC="../images/_gerade_re.gif" WIDTH=23 HEIGHT=41 ALT="}" BORDER=0></A>
			</TD>
		</TR>
	</TABLE>
</BODY>
</HTML>

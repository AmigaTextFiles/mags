<HTML>
<HEAD>
<title>Mega PowerPC Kurs</title>
</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#ff2f2f" ALINK="#FFac97" VLINK="#ff71ff" BACKGROUND="funrelif3.gif">
<CENTER>
<table WIDTH="80%" ALIGN="CENTER">
 <TR>
   <TD BGCOLOR="#000098" ALIGN="CENTER">
    <FONT COLOR="#FFFFFF">  
    <H1>PowerPC Kurs von Steffen Haeuser</H1>
    <H6>Multitasking-Programmierung mit WarpOS</H6></TD>
   <TD BGCOLOR="#0046FF">
    <FONT COLOR="#FFFFFF">   
    <H1 ALIGN="CENTER">INTERN</H1></TD>
 </TR>
</Table><FONT COLOR="#000000">  
<TABLE WIDTH="80%" ALIGN="CENTER">
<TD BGCOLOR="#D2F0FF">
<P>
<BR>
Dies ist eine Fortsetzung meines Kurses zur PPC-Programmierung. Diesmal geht
es wirklich ins Eingemachte. Direkt in den Kern(el) von WarpOS. Im Normalfall
dürften die beschriebenen Methoden nicht benötigt werden, aber in einigen
Fällen ist die Multitasking-Programmierung doch recht nützlich.
<P>
Bei <B>Rückfragen</B> stehe ich unter <A HREF="mailto:MagicSN@Birdland.es.bawue.de">MagicSN@Birdland.es.bawue.de</A> oder <B>07021/51787</B>
oder <B>Steffen Häuser, Limburgstr. 127, 73265 Dettingen/Teck</B>, gerne zur Verfügung.
Auch an Software, die ich Portieren kann, bin ich interessiert.
<P>
Viele Aufgaben bei einer Software können bekanntlich auf mehrere Tasks aufgeteilt
werden. Natürlich ist dies auch bei PPC-Software erwünscht. Dieser Artikel
beschreibt, wie man Multitasking-Programmierung auf dem PPC durchführt, unter
Verwendung des StormC oder des vbcc-WarpOS Compilers. Ich gehe dabei nicht im
Einzelnen auf die Syntax ein, sondern erläutere im Wesentlichen die Verfahren.
Syntax kann man in der Dokumentation von WarpOS nachlesen.
<P>
<B>1. Die zentrale Funktion</B>
<P>
Die zentrale Funktion für das PPC-Multitasking ist die Funktion CreateTaskPPC()
der powerpc.library. Sie entspricht gewissermaßen der Funktion CreateTask() der
exec.library, nur daß sie PPC-Tasks, und keine 68k-Tasks erzeugt. Dennoch gibt
es einige Unterschiede:<BR>
<P><UL>
<LI>Anstelle einer Task-Struktur wird eine TaskPPC-Struktur erzeugt
<LI>Jede Task-Struktur enthält über task->tp_Task eine "normale" Task-Struktur
<LI>Eigentlich entsprechen PPC-Tasks eher den Prozessen, als den Tasks
<P></UL>
Folgende Tags werden beim Erschaffen eines neuen PPC-Tasks eingesetzt:
<P><UL>
<LI><B>TASKATTR_CODE:</B>Zeigt auf die Funktion, die der Task ausführen soll, wobei<BR>
                    die Funktion mit __saveds deklariert und definiert sein sollte<BR>
<LI><B>TASKATTR_EXITCODE:</B>Falls vorhanden: Exitroutine des Tasks<BR>
<LI><B>TASKATTR_NAME:</B>      Der Name des Tasks, muss angegeben werden
<LI><B>TASKATTR_PRI:</B>       Falls vorhanden: Die Priorität des Tasks
<LI><B>TASKATTR_STACKSIZE:</B> Die Größe des Stacks
<LI><B>TASKATTR_R3..._R10:</B> Die Parameter für die Funktion
<LI><B>TASKATTR_R2:</B>        LinkerDB
<P></UL>
An dieser Stelle möchte ich die Sache mit dem LinkerDB erläutern. Man kann LinkerDB
z.B. so deklarieren:
<P>
<B>extern ULONG *LinkerDB;</B>
<P>
Falls nun ein Task auf globale Variablen zugreifen soll (__saveds allein genügt
nicht !!!), so muß man etwa so programmieren:
<P>
      ppctags[0].ti_Data=(ULONG)AudioHandlerTask;<BR>
      ppctags[2].ti_Data=(ULONG)"MeinTask";<BR>
      ppctags[3].ti_Data=(ULONG)-128;<BR>
      ppctags[4].ti_Data=(ULONG)&LinkerDB;<BR>
      MeinTask=(void *)CreateTaskPPC(ppctags2);<BR>
<P>
Nun kann der Task auch auf globale Variablen zugreifen.
<P>
(Ein DeleteTaskPPC gibt es natürlich auch).
<P>
<B>2. Ein Wort zum Multiprocessing</B>
<P>
Immer wieder kommt im Usenet - meist von Leuten, die keine PowerPC-Karte besitzen
und gerne "theoretisieren" - das Stichwort "Multiprocessoring" hervor. Um dies
klarzustellen: PowerUP ist *kein* Multiprozessorsystem, auch wenn es oft als
solches bezeichnet wird. Der 68k und der PPC teilen sich einen gemeinsamen Bus,
und wenn man versucht, beide gleichzeitig massivst auf diesem Arbeiten zu lassen
- z.B. indem man einen Frame auf dem PPC berechnet, und den letzten Frame
gleichzeitig mit dem 68k darstellt - so bricht die Busgeschwindigkeit MASSIVST
zusammen. Man kann davon ausgehen, daß der Bus auf etwa die halbe Geschwindigkeit
gebremst wird. Das Programm läuft also nur noch halb so schnell.
<P>
<B>DIES IST KEINE THEORIE, DIES SIND WERTE AUS DER PRAXIS, DIE VON MEHREREN PROGRAMMIERERN
UNABHÄNGIG VONEINANDER GEMESSEN WURDEN.</B>
<P>
Es ist übrigens keine Frage des Kernels. Theoretisch kann man Pseudo-Multiprocessoring
sowohl mit WarpOS (man würde das AllocXMsg-System einsetzen) als auch mit ppc.library
(das Message-System der ppc.library) programmieren. Man erhält jedoch in beiden Fällen
die gleichen miesen Resultate.
<P>
<B>ZU EINEM ECHTEN MULTIPROZESSOR GEHÖREN ENTWEDER ZWEI BUSSYSTEME ODER LOKALER SPEICHER.</B>
<P>
Ich denke, nun können wir das Multiprozessor-Märchen abhaken und uns der Programmierung
des Multitaskings weiter widmen.
<P>
<B>3. Hilfsfunktionen</B>
<P>
Aus der 68k exec.library sind zahllose Hilfsfunktionen für Tasks bekannt, z.B.:
<P><B>
InitSemaphore<BR>
ObtainSemaphore<BR>
ReleaseSemaphore<BR>
Wait<BR>
GetMsg<BR>
Signal<BR>
AllocSignal<BR>
CreateMsgPort<BR>
...<BR></B>
<P>
Alle diese Funktionen werden innerhalb von WarpOS PPC-Native (ohne Kontextswitches)
angeboten. Dies sind keine exec.library Funktionen mehr, dies sind Funktionen des
WarpOS-Kernels:
<P><B>
InitSemaphorePPC<BR>
ObtainSemaphorePPC<BR>
ReleaseSemaphorePPC<BR>
WaitPPC<BR>
GetMsgPPC<BR>
SignalPPC<BR>
AllocSignalPPC<BR>
CreateMsgPortPPC<BR>
...<BR></B>
<P>
Ausser dem PPC am Ende des Namens ist der einzige Unterschied zu den exec-Funktionen,
daß:
<P><UL>
<LI>statt eines Task-Parameters ein TaskPPC-Parameter zum Einsatz kommt
<LI>statt eines SignalSemaphore-Parameters ein SignalSemaphorePPC-Parameter zum Einsatz kommt
<LI>statt eines MsgPort-Parameters ein MsgPortPPC-Parameter zum Einsatz kommt
<LI>...</UL>
<P>
Die Includes für all diese neuen Datenstrukturen sind im Includepfad powerpc/ zu finden
(z.B. powerpc/tasksPPC.h für die TaskPPC-Struktur).
<P>
Gemein haben all diese Strukturen, daß sie jeweils ihr 68k-Äquivalent enthalten, so
daß man, wenn man bei bestimmten Programmkonstrukten unbedingt die 68k-Struktur oder
ein Teil von ihr benötigt, auch auf diese zugreifen kann, z.B.:
<P>
task=taskppc->tp_Task;<BR>
mp=mp_ppc->mp_Port;<BR>
sema=sema_ppc->ssppc_SS;<BR>
<P>
Man kann z.B. ohne Probleme einem PPC-Task über die 68k-Funktion GetTaskPri eine
neue Priorität zuweisen (allerdings ist es sinnvoller, GetTaskPriPPC zu verwenden).
<P>
Es sei an dieser Stelle darauf hingewiesen, daß bei WarpOS Semaphoren eine bedeutsame
Stellung einnehmen. Man kann bei WarpOS nicht einfach mit einem Forbid() das Multitasking
abschalten.
<P>
Es bleibt festzustellen, daß WarpOS dem AmigaOS eigentlich sehr ähnlich ist. Die Funktionen
sind fast die Selben, zumindest im Bereich des Multitaskings. Achtung, nicht Alle der
angegebenen Funktionen sind auch unter WarpUP V7 zugänglich. Im Zweifelsfall WarpOS-Dokumentation
konsultieren.
<P>
<B>Zusätzlich existieren noch:</B>
<P><UL>
<LI>Signal68k:  Damit kann ein PPC-Task einem 68k-Task signalisieren<BR>
<LI>WaitFor68K: Hiermit kann ein PPC-Task auf einen asynchronen 68k-Task warten,<BR>
              wobei erst nach Ende der Funktion erneut etwas asynchron abgearbeitet<BR>
              werden kann (ist dies nicht genügend => AllocXMsg System ansehen !!!)<BR>
<P></UL>
<B>4. Was sind eigentlich Semaphoren ?</B>
<P>
An dieser Stelle möchte ich noch einmal den Begriff Semaphore wiederholen, da er Neuland
für viele Amiga-Programmierer ohne informatische Vorbildung sein dürfte.
<P>
Def. Semaphor
<P>
Ein Semaphor ist eine Datenstruktur, die von allen Tasks "angetestet" werden kann, ob sie
gerade belegt oder frei ist. Ein bestimmter Code kann nur ausgeführt werden, wenn der
zuständige Semaphor noch frei ist. Ist er belegt, so wartet der Semaphor, bis er wieder
frei ist, und macht dann gleich weiter. Beim gleichzeitigen Zugriff mehrerer Tasks auf
einen Semaphor gibt es auf KEINEN FALL Probleme.
<P>
<B>Beispiel:</B>
<P>
<B>1. Task:</B>
<P>
extern int a;<BR>
struct SignalSemaphore sema;<BR>
InitSemaphorePPC(&sema);<BR>
while(1)<BR>
{<BR>
 ObtainSemaphorePPC(&sema);<BR>
 a=1;<BR>
 ReleaseSemaphorePPC(&sema);<BR>
}<BR>
<P>
<B>2. Task:</B>
<P>
extern int a;<BR>
struct SignalSemaphore sema2;<BR>
InitSemaphorePPC(&sema2);<BR>
while(1)<BR>
{<BR>
 ObtainSemaphorePPC(&sema2);<BR>
 a=2;<BR>
 ReleaseSemaphorePPC(&sema2);<BR>
}<BR>
<P>
Der Wert von a ist zu jedem Zeitpunkt exakt definiert. Die beiden Tasks greifen
niemals gleichzeitig darauf zu.
<P>
Aufpassen sollte man, wenn man mehrere Semaphoren verschachtelt. Eine Situation,
in der jeder Task auf das Freiwerden der Resource wartet, die gerade der andere
Task belegt, nennt man einen DEADLOCK.
<P>
Aber das soll hier genügen. Weitere Informationen über Semaphoren können jedem
guten Buch über Betriebssysteme entnommen werden. Semaphoren sollten verwendet
werden, wann immer eine Resource nicht gleichzeitig von zwei Tasks verwendet werden
kann.
<P>
Dabei werden Semaphoren erst initialisiert, dann "obtained", dann "released". Man
sollte jeden "obtainten" Semaphore auch wieder "releasen", damit die Resource wieder
frei wird.
<P>
Semaphore sind ein sehr geschicktes Mittel, um Multitasking in einer Weise zu programmieren,
daß Deadlock-Situationen oder auch Situationen, in denen zu oft gewartet wird, vermieden
werden.
<P>
<B>5. Das AllocXMsg-System</B>
<P>
Was nun noch fehlt, ist ein System, Nachrichten zwischen 68k und PPC hin und her zu
schicken. Man beachte jedoch die Warnung von oben, dass ein solches Programm, wenn
man nicht GENAU weiß, was man tut, zu großer Ineffizienz führen kann.
<P>
<B>a) Anlegen der Message-Ports</B>
<P>
Für den 68k wird ein MsgPort angelegt, für den PPC ein MsgPortPPC
<P>
<B>b) Anlegen der Tasks</B>
<P>
wie üblich
<P>
<B>c) Anlegen der Messages</B>
<P>
Der 68k verwendet die Funktion AllocXMsg. Hierbei muß eine Message-Größe angegeben
werden, sowie der Reply-Port des 68k-Tasks. Für den PPC existiert eine analoge
Funktion AllocXMsgPPC. FreeXMsg/FreeXMsgPPC existieren natürlich ebenfalls.
<P>
<B>d) Übertragen der Messages</B>
<P>
Hierzu werden die Funktionen PutXMsg (vom 68k zum PPC) und PutXMsgPPC (vom PPC zum
68k) eingesetzt. Als Parameter werden ein MsgPort(PPC) und die in c) gewonnene
Message benötigt (in die zuvor die Nachricht eingetragen wird).
<P>
<B>e) Empfangen und Beantworten der Messages</B>
<P>
Auf 68k-Seite werden GetMsg, WaitPort und ReplyMsg eingesetzt, auf PPC-Seite
GetMsgPPC, WaitPortPPC und ReplyMsgPPC. Reply-Messages erhalten hierbei den
Nodetype NT_REPLYMSG.
<P>
Nachdem die Message verschickt wurde, verliert der entsprechende Prozessor
SOFORT den Besitz über die Message. Erst wenn sie Replied wurde, darf wieder
auf die Message zugegriffen werden. Falls es keinen Replyport gibt, darf
die Message - nachdem sie von der anderen Seite gelesen wurde - freigegeben werden.
Nachdem die Message beantwortet wurde, kann sie weiterverwendet werden.
<P>
<B>Achtung:</B> ReplyMsg sollte nur aufgerufen werden, wenn auch ein ReplyPort existiert.
<P>
<B>Achtung:</B> Der empfangende Task darf nur Daten zugreifen, die direkt im Message-Körper
enthalten sind. Eine Ausnahme ist nur möglich, falls sich die beiden Tasks selber
um die Cache-Kohärenz kümmern. Nur am Messagekörper selbst führt das System
Flushing/Invalidation durch.
<P>
<B>Achtung:</B> Der empfangende Task hat auch Schreibzugriff auf den Message-Körper.
<P>
Beim Anwenden des AllocXMsg-Systems sind also im wesentlichen zwei Dinge zu
beachten:
<P><UL>
<LI>1) Effizienz ("Bus-Hits")
<LI>2) Cache-Kohärenz (entweder alles, was übergeben werden soll, in die Message<BR>
   packen, d.h. auch keine globalen Variablenzugriffe, oder aber sich selbst<BR>
   um die Cache-Koheränz kümmern).<BR>
<P></UL>
Im üblichen Fall zahlt sich die Verwendung von "Multiprocessoring" bei PowerUP
Boards nicht aus. Aber unter Umständen kann man das AllocXMsg-System schon
verwenden, um mal eine kleine Message zwischen den Prozessoren hin und her
zu schicken. Zumindest Support dafür ist vorhanden. Aber wie gesagt: Wer nicht
genau weiß, was er tut => Finger weg !!!
<P>
<B>6. Andere Elemente der powerpc.library</B>
<P>
<B>Des weiteren enthält die powerpc.library noch:</B>
<P><UL>
<LI>Hilfsfunktionen PPC-Native (z.B. Listen-Handling)
<LI>Kontextswitch-Funktionen (StormC macht das aber meistens vollautomatisch,
  braucht man höchstens zum aufrufen von 68k Assembler-Funktionen, die der
  automatische Kontextswitch nicht durchführt, oder um Mixed Binaries mit
  vbcc-WarpOS zu erzeugen, der diese (noch ?) nicht direkt unterstützt).
<LI>Speichermanagement, inklusive fakultatives Memory-Protection (Es sei
  darauf hingewiesen: "AllocMem considered harmful". Immer AllocVecPPC
  verwenden, oder malloc. Und immer schön auf 8 Byte alignen.
<LI>Lowlevel-Funktionen für MMU, Supervisormodus u.ä. (wichtig etwa für Leute,
  die einen Mac-Emulator programmieren wollen)
<LI>PPC Native Timerfunktionen, die direkt die Timerbase-Register des PPC
  verwenden, dabei aber den Funktionen des timer.device nachempfunden sind
  (z.B. GetSysTimePPC).
<LI>Funktionen, um Informationen über das System anzufordern
<LI>Funktionen, um das Multitasking zu beeinflussen (z.B. die Nice-Values, die
  bei einem dynamischen Scheduler wie WarpOS die Rechenzeit für die Tasks
  beeinflussen
<LI>Funktionen, die bei der Programmierung eines Debuggers helfen
<P></UL>
<B>7. Hooks</B>
<P>
Ein weiterer Abschnitt sei den "Hooks" gewidmet. Ein Hook ist eine nützliche
Konstruktion, in der eine Funktion eine andere Funktion als Parameter erhält.
Systeme wie AHI nützen diese recht extensiv. Leider geht das schief, falls z.B.
die Funktion als Parameter PPC ist, die Funktion der Library/des Devices aber
68k. Es klappt einfach nicht, keine Chance. Ein Beispiel wäre AHI_AllocAudioA(),
selbst wenn man den Hook-Parameter nicht angibt, geht das schief.
<P>
Ein weiterer beliebter Befehl, der dieses Problem hat, ist RawDoFmt(). In Form
von SPrintF/SPrintF68k bietet WarpOS Ersatzcode an.
<P>
<B>Lösung:</B>
<P>
68k und PPC Code zusammenlinken, das komplette AHI-Handling im 68k-Part erledigen.
Es wird stark empfohlen, ein MixedBinary zu verwenden, da StormC innerhalb eines
MixedBinary die Handhabung für solche Dinge stark erleichtert. vbcc-WarpOS kann
das leider noch nicht automatisch, hier muß der Kontextswitch zwischen den beiden
Teilen noch manuell programmiert werden. Prinzipiell gilt jedoch das Selbe.
<P>
<B>8. Empfehlungen</B>
<P>
Es sei im Allgemeinen empfohlen:
<P><UL>
<LI>Möglichst viel (auch möglichst viele Tasks PPC-Native machen)
<LI>Einen Task nur dann zu einem 68k-Task machen, wenn er als PPC-Task wirklich
  massivst Kontextswitches enthielte
<LI>stets synchron arbeiten, asynchrones Arbeiten, wenn immer möglich, vermeiden
  (aufgrund der Einschränkungen der PowerUP-Hardware). 68k/PPC parallel an einer
  Aufgabe arbeiten zu lassen, bremst beide Prozessoren aufgrund von "Bushits"
  massivst runter.
<LI>Es lohnt sich nicht, den Video-Refresh von einem 68k-Task erledigen zu lassen.
  Hier am Besten 100% PPC-Native vorgehen
<LI>Netzwerk-Support könnte sich als 68k-Task lohnen
<LI>Keyboard/Audio bringen evtl. minimale Gewinne, üblicherweise lohnt es sich jedoch
  nicht
<LI>Falls 68k-Tasks vorkommen, am Besten ein MixedBinary verwenden
<LI>Bei Zugriffen auf globale Variablen LinkerDB nicht vergessen
<LI>Die Verwendung von Funktionen des ahi.device muß in einem MixedBinary erfolgen
  (braucht kein Extra Task sein, kann aber... aber es muß in jedem Fall 68k erfolgen)
<P>
<BR>
</TD></TABLE>
<TABLE WIDTH="80%" ALIGN="CENTER">
<TD BGCOLOR="#000098">
  <FONT COLOR="#FFFFFF"> 
  <HR align="center" size="4" width="50%">
  <CENTER><A HREF="main.html">Zurück zum Inhalt</A></CENTER>
  <HR align="center" size="4" width="50%">
  <CENTER><B>Fun Time ©1998</B></CENTER>
</TD>
</TABLE>
</CENTER>
</BODY>
</HTML>

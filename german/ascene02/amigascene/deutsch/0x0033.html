<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
	<TITLE>AmigaScene 0x02 - Workshop</TITLE>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML;CHARSET=iso8859-1">
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#101010" LINK="#BF0000" VLINK="#101010" ALINK="#E04040">
	<TABLE WIDTH="100%" CELLPADDING=3 CELLSPACING=0 BORDER=0>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=TOP WIDTH="80%" HEIGHT=75>
				<A NAME="00" HREF="welcome.html"><IMG SRC="../images/_amiga.gif" WIDTH=125 HEIGHT=48 ALT="[Amiga]" ALIGN=RIGHT BORDER=0></A><A HREF="#99"><IMG SRC="../images/_krumm_lo.gif" WIDTH=37 HEIGHT=29 ALT="[Down]" ALIGN=LEFT BORDER=0></A>
				<BR CLEAR=ALL><BR>
				<TABLE ALIGN=CENTER WIDTH=170 BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=CENTER>
					<A HREF="../deutsch/0x0033.html"><IMG WIDTH=16 HEIGHT=10 SRC="../images/__german.gif" ALT="[ german ]" BORDER=1></A>
				</TD></TR></TABLE>
 			</TD>
			<TD BGCOLOR="#BF0000" VALIGN=TOP ALIGN=RIGHT WIDTH=175>
				<A HREF="welcome.html"><IMG SRC="../images/_scene.gif" WIDTH=110 HEIGHT=47 ALT="[Scene]" ALIGN=LEFT BORDER=0></A>
				<A HREF="0x0032.html"><IMG SRC="../images/_gerade_li.gif" WIDTH=22 HEIGHT=41 ALT="{" BORDER=0></A><A HREF="0x0034.html"><IMG SRC="../images/_gerade_re.gif" WIDTH=23 HEIGHT=41 ALT="}" BORDER=0></A>
			</TD>
		</TR>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=MIDDLE ALIGN=CENTER>
				<CENTER>&nbsp;<BR>

					<IMG WIDTH=155 HEIGHT=25 SRC="../images/_workshop_.gif" ALT="[Workshop]">&nbsp;<BR><BR>

					<TABLE WIDTH="90%" BORDER=0>
						<TR><TD ALIGN=CENTER><FONT SIZE="-1">

| <A HREF="0x0032.html">A-Files: Installieren</A> | <A HREF="0x0033.html">Algorithmen in C</A> |

						</FONT></TD></TR>
					</TABLE>&nbsp;<BR>
				</CENTER>
			</TD>
			<TD BGCOLOR="#BF0000" VALIGN=TOP ALIGN=CENTER WIDTH=175 ROWSPAN=2>
				<CENTER>&nbsp;<BR>
					<IMG SRC="../images/__.gif" HEIGHT=1 WIDTH=175 ALT=" "><BR> 
					<A HREF="0x002B.html"><IMG WIDTH=77  HEIGHT=25 SRC="../images/_cover.gif"     ALT="[Cover]"     BORDER=0></A><BR>
					<A HREF="0x002C.html"><IMG WIDTH=117 HEIGHT=25 SRC="../images/_editorial.gif" ALT="[Editorial]" BORDER=0></A><BR>
					<A HREF="0x002D.html"><IMG WIDTH=85  HEIGHT=25 SRC="../images/_inhalt.gif"    ALT="[Inhalt]"    BORDER=0></A><BR>
					<A HREF="0x002E.html"><IMG WIDTH=70  HEIGHT=25 SRC="../images/_news.gif"      ALT="[News]"      BORDER=0></A><BR>
					<A HREF="0x002F.html"><IMG WIDTH=131 HEIGHT=25 SRC="../images/_hardware.gif"  ALT="[Hardware]"  BORDER=0></A><BR>
					<A HREF="0x0030.html"><IMG WIDTH=121 HEIGHT=25 SRC="../images/_software.gif"  ALT="[Software]"  BORDER=0></A><BR>
					<A HREF="0x0032.html"><IMG WIDTH=135 HEIGHT=25 SRC="../images/_workshop.gif"  ALT="[Workshop]"  BORDER=0></A><BR>
					<A HREF="0x0034.html"><IMG WIDTH=73  HEIGHT=25 SRC="../images/_spiele.gif"    ALT="[Spiele]"    BORDER=0></A><BR>
					<A HREF="0x0036.html"><IMG WIDTH=91  HEIGHT=25 SRC="../images/_special.gif"   ALT="[Special]"   BORDER=0></A><BR>
					<A HREF="0x0037.html"><IMG WIDTH=112 HEIGHT=25 SRC="../images/_feedback.gif"  ALT="[Feedback]"  BORDER=0></A><BR>
					<A HREF="0x0039.html"><IMG WIDTH=46  HEIGHT=25 SRC="../images/_etc.gif"       ALT="[Etc]"       BORDER=0></A><BR>
				<BR></CENTER>
			</TD>
		</TR>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=TOP ALIGN=LEFT>

<BR><H1 ALIGN=LEFT><FONT FACE="Arial"><B>Effizientes Programmieren - Teil 1</B></FONT></H1>&nbsp;

<BR><FONT SIZE="+1">Beim Programmieren treten oft viele
Probleme auf, die auf &auml;hnliche Weise gel&ouml;st werden k&ouml;nnen.
Oft unterscheiden sich die L&ouml;sungsans&auml;tze aber stark in ihrer
Effizienz und ihrem Speicherverbrauch. Weshalb aber soll jeder das Rad
f&uuml;r sich alleine erfinden, wo doch eine Reihe von
leistungsf&auml;higen Algorithmen publik gemacht wurden, die dem
gestre&szlig;ten Programmierer das Leben sehr erleichtern k&ouml;nnen und
oftmals besser mit den Resourcen des Computers umgehen als allf&auml;llige
triviale L&ouml;sungen. </FONT><BR>

<P ALIGN=CENTER><A NAME="01" HREF="#00"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#02"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Viele Probleme k&ouml;nnen recht einfach gel&ouml;st werden, wenn man die
richtige Datenstruktur und den richtigen Algorithmus verwendet. Dieser Kurs
soll Ihnen vor allem helfen, die wichtigsten Datenstrukturen zu verstehen,
um in weiterer Folge dann absch&auml;tzen zu k&ouml;nnen, welche
Datenstruktur f&uuml;r die L&ouml;sung eines speziellen Problems am besten
geeignet ist. Eng verkn&uuml;pft mit dem Begriff der Datenstruktur sind
damit verbundene Algorithmen, die zur Behandlung der Datenstruktur dienen.
Die enge Verbindung zwischen diesen beiden Begriffen l&auml;&szlig;t sich
beispielsweise in modernen Programmiermethoden wie z.B. der OOP
(objektorientierte Programmierung) wiederfinden, in der die Daten und die
damit operierenden Algorithmen (Methoden) prinzipiell zusammengeh&ouml;ren
und eine Klasse bilden (Kapselungsprinzip). Die zu den Datenstrukturen
geh&ouml;rigen Algorithmen stellen die Operationen zur Verf&uuml;gung, die
mit der Datenstruktur m&ouml;glich sind. F&uuml;r diese Art der Darstellung
w&auml;re nat&uuml;rlich eine objektorientierte Programmiersprache ideal.
Da auf dem AMIGA aber C die vorherrschende Programmiersprache ist, sind
alle abgedruckten Programme in C geschrieben. An dieser Stelle soll aber
auch einmal mit dem Vorurteil aufger&auml;umt werden, da&szlig; man
Programmiersprachen in objektorientierte und nicht objektorientierte
einteilen kann. OOP ist eine Programmiermethode und kein Sprachmerkmal.
Sogenannte &quot;objektorientierte Programmiersprachen&quot;
unterst&uuml;tzen nur die Prinzipien der OOP in ihrem Sprachkonzept. Das
bedeutet aber nicht, da&szlig; man in nicht objektorientierten Sprachen
nicht objektorientiert programmieren kann. Kenner des AMIGA-Betriebssystem
werden beispielsweise auch objektorientierte Ans&auml;tze im Amiga-OS
finden. Das beste Beispiel f&uuml;r das Vererbungsprinzip sind die Nodes.
Die Node dient als Basisklasse, auf dieser baut beispielsweise die
Task-Struktur auf. Von dieser wird dann noch die Process-Klasse abgeleitet.
Der Vorteil eines solchen Aufbaus liegt ja wohl klar auf der Hand. Da
sowohl die Task- als auch die Process-Klasse (wie viele andere auch) von
der Basisklasse Node abgeleitet wurde, k&ouml;nnen alle Operationen der
Klasse Node auch auf die abgeleiteten Klassen angewandt werden. Zu diesen
Operationen geh&ouml;ren die Exec-Funktionen AddHead, AddTail, RemHead,
RemTail, Insert, Enqueue und Remove.</P>

<P ALIGN=CENTER><A NAME="02" HREF="#01"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#03"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Diese Vorgehensweise erlaubt also eine recht vielseitige Verwendung der
oben genannten Operationen auf verschiedenste Dinge. Aus diesem Grund habe
ich es als notwendig erachtet, bestimmte objektorientierte Ans&auml;tze
auch in manchen der in diesem Kurs vorkommenden Programmen zu
verwirklichen. Denn obwohl ich die OOP nicht - wie so viele - als
Allheilmittel gegen die Software-Krise betrachte, bin ich doch der Meinung,
da&szlig; auch auf dem AMIGA C fr&uuml;her oder sp&auml;ter seinem
Nachfolger C++ den Rang ablaufen wird. Deshalb wollen wir hier einmal kurz
besprechen, welche Ans&auml;tze wir bei manchen unserer Implementierungen
&uuml;bernehmen wollen. Zuerst legen wir einmal fest, da&szlig; jeder
Vertreter aller unserer zuk&uuml;nftigen Datentypen einen Constructor und
einen Destructor haben kann (aber nicht mu&szlig;). Der Constructor ist
immer die Funktion, die vor der ersten Verwendung der Datenstruktur
aufgerufen werden mu&szlig;. Er versetzt die Datenstruktur in einen
definierten Anfangszustand. Der Destructor hingegen wird dann verwendet,
wenn das Objekt seinen Zweck erf&uuml;llt hat und in Zukunft nicht mehr
verwendet wird. Er gibt im allgemeinen alle belegten Resourcen wieder frei.</P>

<P ALIGN=CENTER><A NAME="03" HREF="#02"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#04"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Weiters definieren wir zu einem Objekt immer alle darauf anwendbaren
Operationen. Damit legen wir fest, was mit einem Vertreter dieses
(abstrakten) Datentyps alles gemacht werden kann. Die Operationen werden
als einfache C-Funktionen implementiert, deren erstes Argument mit dem
Namen this immer ein Zeiger auf das Objekt ist, auf das die Operation
angewandt werden soll. Dies sollte es alle jenen, die stolze Besitzer eines
C++-Compilers sind, m&ouml;glich machen, die Funktionen schnell in das
objektorientierte Konzept dieser Programmiersprache umzugestalten.</P>

<P ALIGN=CENTER><A NAME="04" HREF="#03"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#05"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Beginnen wir nun aber mit der ersten, zugegebenerma&szlig;en noch etwas
einfachen Datenstruktur, der linearen Liste. Wie Sie sicherlich wissen, ist
eine einfache Implementation dieser Datenstruktur schon im Betriebssystem
zu finden, n&auml;mlich die oben erw&auml;hnte Node zusammen mit der List.
Es handelt sich dabei um die einfachste Grundform einer linearen Liste mit
doppelter Verkettung. Ich m&ouml;chte nicht genauer darauf eingehen, da der
AMIGA-Kenner sicherlich mit dem Umgang den Standardfunktionen des
Betriebssystems vertraut ist. Vielmehr wollen wir uns einmal mit der
allgemeinen Beschaffenheit linearer Listen und ihren vielf&auml;ltigen
Variationsm&ouml;glichkeiten befassen. Da die Datenstruktur
&quot;Liste&quot; in ihrer einfachsten Form nicht sonderlich kompliziert
ist, soll sie auch als Beispiel dienen, wie wir im folgenden unsere
sicherlich komplizierter werdenden Datenstrukturen aufzubauen gedenken.</P>

<P ALIGN=CENTER><A NAME="05" HREF="#04"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#06"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Eine Liste dient immer zur Speicherung von Daten, die in irgendeiner Form
zusammengeh&ouml;ren. Als Operationen auf die Datenstruktur Liste
definieren wir folgende Funktionen: Einf&uuml;gen eines bestimmten
Elementes, Entfernen eines Elementes und Suchen eines Elementes. Die
Definition der Datenstruktur Liste und der darauf definierten Funktionen
(Methoden) bilden hierauf eine sogenannte Klasse. Die einfachste Form einer
linearen Liste, die oft nicht als solche erkannt wird, ist die Speicherung
in Form eines Arrays. Dabei werden die Elemente einfach nacheinander
angereiht (sequentielle Speicherung linearer Listen). Soll nun in diesem
Feld ein Element an einer bestimmten Stelle eingef&uuml;gt werden,
m&uuml;ssen alle nachfolgenden Elemente um eine Position
zur&uuml;ckverschoben werden. &Auml;hnlich m&uuml;ssen beim Entfernen eines
bestimmten Elementes alle Elemente danach um eine Position nach vorne
geschoben werden. Damit offenbart sich schon der gr&ouml;&szlig;te Nachteil
der Listen in Form eines Arrays: wenn man nicht gerade mit dem letzten
Element des Arrays operiert, k&ouml;nnen die Einf&uuml;ge- und
Entferne-Operationen sehr aufwendig werden. Auch der Umstand, da&szlig; ein
Feld immer eine bestimmte Gr&ouml;&szlig;e hat und somit nur eine begrenzte
Anzahl von Elementen aufnehmen kann, schr&auml;nkt die Verwendung von
Arrays als Listen stark ein. Das Suchen in Feldern geht jedoch sehr schnell
vonstatten, besonders wenn die Listen sortiert gehalten werden. Dieser
Vorteil rechtfertigt, da&szlig; wir uns mit den Arrays als Listen doch noch
genauer besch&auml;ftigen wollen. Wird n&auml;mlich nur sehr, sehr selten
eingef&uuml;gt und entfernt, jedoch h&auml;ufig ein Element in der Liste
gesucht, hat die Verwendung von Feldern durchaus ihre Berechtigung. Wir
kommen deshalb sp&auml;ter bei den Suchvorg&auml;ngen nocheinmal auf eine
Liste dieser Form zur&uuml;ck.</P>

<P ALIGN=CENTER><A NAME="06" HREF="#05"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#07"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Nun wollen wir aber die wohl h&auml;ufigste Form der Speicherung von Listen
betrachten: die verkettete Speicherung linearer Listen. Hier wird mit den
einzelnen Elementen jeweils ein Pointer auf das nachfolgende Element
mitgespeichert. Mit dem zus&auml;tzlichen Speicheraufwand erkauft man sich
viele Vorteile. Die Einf&uuml;ge- und Entferne-Operationen reduzieren sich
auf das Umstellen von Pointern und gehen somit recht schnell vonstatten.
Zus&auml;tzlich k&ouml;nnen jederzeit neue Elemente an die Liste
angeh&auml;ngt werden, solange noch gen&uuml;gend Speicher zur
Verf&uuml;gung steht, es mu&szlig; also nicht von vornherein ein bestimmtes
Fassungsverm&ouml;gen der Liste festgelegt werden, wie das bei den Feldern
der Fall war. Um auf die Liste zugreifen zu k&ouml;nnen, wird irgendwo im
Programm die Adresse des ersten Elements gemerkt. Zus&auml;tzlich legen wir
fest, da&szlig; die Liste genau dann leer ist, wenn dieser Zeiger NULL ist.</P>

<P ALIGN=CENTER><A NAME="07" HREF="#06"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#08"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Um nun die verkettete Liste vollst&auml;ndig definiert zu haben,
m&uuml;ssen wir noch besprechen, wie die einzelnen Operationen auszusehen
haben. Die Einf&uuml;ge-Operation ist trivial. Probleme gibt es jedoch beim
Entfernen eines bestimmten Elementes, da dessen Vorg&auml;nger, der den
Zeiger auf das zu entfernende Element enth&auml;lt, nicht bekannt ist.
F&uuml;r dieses Problem bieten sich zwei offensichtliche L&ouml;sungen an.
Einerseits k&ouml;nnte man die Liste von Anfang an durchlaufen und sich den
gesuchten Vorg&auml;nger merken, andererseits k&ouml;nnte man
nat&uuml;rlich auch eine R&uuml;ckverkettung vornehmen, d.h. jedes Element
einer Liste enth&auml;lt au&szlig;er dem Zeiger auf das n&auml;chste
Element noch einen weiteren Pointer auf den Vorg&auml;nger. W&auml;hrend
die erste Methode f&uuml;r lange Listen schnell untragbar langsam wird,
geht die zweite Methode stark zu Lasten des Speichers, da f&uuml;r jedes
gespeicherte Element weitere vier Bytes ben&ouml;tigt werden. Handelt es
sich um homogene Listen, also Listen, in denen nur gleiche Elemente
gespeichert werden, und ist zus&auml;tzlich die Gr&ouml;&szlig;e der
einzelnen Knoten bekannt (und nicht allzu gro&szlig;), dann bietet sich ein
n&uuml;tzlicher Trick an (s. Abbildung 1). Dabei kopiert man den Nachfolger
des zu entfernenden Elementes k, der ja bekannt ist, an die Adresse von k.
Dieses Verfahren funktioniert aber genau dann nicht, wenn das zu
entfernende Element k das letzte Element der Liste ist und somit keinen
Nachfolger hat. Um diesen Spezialfall auch behandeln zu k&ouml;nnen,
ben&uuml;tzt man einen oft gesehenen Trick, n&auml;mlich die Verwendung von
Dummy-Elementen, die ja auch bei den EXEC-Lists vorkommen. Dabei
h&auml;ngen wir einfach an das Ende der Liste ein Element, das keinerlei
Informationen tr&auml;gt. Weiterhin legen wir fest, da&szlig; das
Dummy-Element am Ende der Liste (der sog. Tail oder Schwanz der Liste)
immer auf seinen Vorg&auml;nger zeigt, oder auf NULL, wenn die Liste leer
ist. Durch dieses Tail-Element gew&auml;hrleisten wir, da&szlig; jedes zu
entfernende Element einen Nachfolger hat, und unser Trick von vorhin
funktioniert wieder in jedem Fall. Sie sehen also, wie durch einfache
Kniffe viel an Laufzeit und Speicherplatz eingespart werden kann.</P>

<P ALIGN=CENTER><A NAME="08" HREF="#07"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#09"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P ALIGN=CENTER><A HREF="../images_02/prog.gif">Abb. 1: Entfernen durch Umkopieren.</A></P>

<P>Wie oben erw&auml;hnt, k&ouml;nnen durch die verkettete Speicherung die
Operationen Einf&uuml;gen und Entfernen recht rasch ausgef&uuml;hrt werden.
Die Suchoperation l&auml;&szlig;t sich jedoch nicht so effizient gestalten,
wie bei den Arrays. Dennoch gibt es verschiedene Strategien, um ein
gew&uuml;nschtes Element in der Liste schnell aufzufinden. Bevor wir uns
aber mit dem Suchen im Detail besch&auml;ftigen, wollen wir einmal
kl&auml;ren, was wir unter &quot;Suchen&quot; eigentlich verstehen. Dazu
teilen wir die in einem Knoten gespeicherte Information in die sogenannte
Schl&uuml;sselinformation - oder einfach nur kurz den Schl&uuml;ssel - und
in die Begleitinformation ein. Wenn wir nun ein bestimmtes Element suchen,
wird nur der Schl&uuml;ssel zum Vergleich herangezogen, die
Begleitinformation ist hierf&uuml;r irrelevant. Im Falle der EXEC-Lists ist
der Schl&uuml;ssel beispielsweise das ln_Name Feld, nach dem die Liste
mittels FindName abgesucht werden kann. Allf&auml;llige hinten
angeh&auml;ngte Daten, wie z.B. die Task-Informationen werden f&uuml;r die
Suche nicht in Betracht gezogen, es handelt sich dabei also um
Begleitinformationen.</P>

<P ALIGN=CENTER><A NAME="09" HREF="#08"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#10"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Betrachten wir vorerst einmal die Suchoperationen f&uuml;r Listen, die als
Arrays gespeichert sind. Die wohl einfachste, aber auch ineffiziente
Methode ist, jedes Element des Feldes der Reihe nach mit dem gesuchten
Schl&uuml;ssel zu vergleichen bis entweder eine &Uuml;bereinstimmung
festgestellt werden konnte (erfolgreiche Suche) oder das Ende der Liste
erreicht wurde (erfolglose Suche). Es erscheint plausibel, da&szlig; diese
Methode nicht besonders schnell ist, da im schlechtesten Fall alle Elemente
des Feldes zum Vergleich herangezogen werden m&uuml;ssen. Wir wollen
deshalb einen Algorithmus kennenlernen, der f&uuml;r die gleiche Aufgabe
viel weniger Zeit in Anspruch nimmt: das bin&auml;re Suchen.</P>

<P ALIGN=CENTER><A NAME="10" HREF="#09"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#11"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Grundvoraussetzung f&uuml;r diese Suchstrategie ist, da&szlig; die Liste
nach ihren Schl&uuml;sseln aufsteigend sortiert sein mu&szlig;, das
bedeutet, der kleinste Schl&uuml;ssel steht ganz am Anfang des Feldes und
der gr&ouml;&szlig;te an dessen Ende. Zus&auml;tzlich sollte die Anzahl der
in der Liste enthaltenen Schl&uuml;sseln bekannt sein. Das bin&auml;re
Suchen l&auml;&szlig;t sich am besten rekursiv beschreiben. Es beginnt mit
dem Vergleich bei dem Element, das in der Mitte der Liste steht, nennen wir
es k. Ist nun der Schl&uuml;ssel von k gleich dem Schl&uuml;ssel des
gesuchten Elementes s, dann sind wir fertig. Falls k aber gr&ouml;&szlig;er
als s ist, wird aus den verbleibenden Elementen, die kleiner als k sind,
wieder das mittlere herausgesucht. Ist k jedoch kleiner als s, dann setzt
der Algorithmus mit dem Vergleich der Elemente rechts von k fort, indem er
von diesen das mittlere heraussucht. Wie Sie sehen, f&auml;llt bei jedem
Vergleich die H&auml;lfte der Elemente unter den Tisch, n&auml;mlich
entweder alle Knoten links oder rechts von k. Aus diesem Grund ist die
bin&auml;re Suche auch viel schneller als die sequentielle Suche. Listing 1
zeigt ein Beispiel einer Implementation des bin&auml;ren Suchens einer
Integerzahl in einem sortierten Feld.</P>

<P ALIGN=CENTER><A NAME="11" HREF="#10"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#12"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Wie Sie vielleicht wissen, ist auch in Ihrer C-Standardbibliothek eine
Version des bin&auml;ren Suchens vorhanden, die auf jeden beliebigen
Datentyp angewandt werden kann. Die Routine ben&uuml;tzt dazu einen Trick,
der auch bei der Sortierfunktion qsort angewandt wurde. Der
bsearch-Funktion werden folgende Parameter &uuml;bergeben: ein Zeiger auf
das gesuchte Objekt, die Basis des Feldes mit den einzelnen Elementen, die
Anzahl der darin gespeicherten Elemente und die Gr&ouml;&szlig;e eines
einzelnen in Bytes. Als letzter Parameter wird ein Zeiger auf eine Funktion
erwartet, mit deren Hilfe zwei Elemente verglichen werden k&ouml;nnen.
Diese Funktion erh&auml;lt als &Uuml;bergabeparameter zwei Zeiger auf
Objekte des zu vergleichenden Typs. Wenn die beiden Objekte - nennen wir
sie p und q - gleich sind, soll diese Funktion 0 zur&uuml;ckgeben, ist p
kleiner als q (bzw. der Schl&uuml;ssel von p kleiner als der von q), dann
mu&szlig; ein Wert kleiner 0 zur&uuml;ckgegeben werden, ansonsten ein Wert
gr&ouml;&szlig;er 0. Diese Vorgehensweise erlaubt, da&szlig; bsearch selber
keine Ahnung hat, um welchen Datentyp es sich bei dem Feld handelt. Es ruft
einfach nur die Vergleichsfunktion auf, die einzig und allein um den
Datentyp Bescheid wei&szlig;. Auch wir werden in sp&auml;teren Folgen auf
solche Weise vorgehen.</P>

<P ALIGN=CENTER><A NAME="12" HREF="#11"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#13"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Eine Erweiterung der Idee des bin&auml;ren Suchens ist die
Interpolationssuche, bei der man versucht, die Position des Elementes schon
im voraus abzusch&auml;tzen. Hier macht man sich eine Idee zunutze, die man
auch im t&auml;glichen Leben beobachten kann: das Interpolieren. Nehmen wir
einmal an, Sie suchen den Namen &quot;Berger&quot; in einem Telefonbuch.
Dann w&uuml;rde Sie sicher nie auf die Idee kommen, das Telefonbuch in der
Mitte aufzuschlagen und dort die Suche zu beginnen, sondern Sie schlagen
das Telefonbuch automatisch relativ weiter vorne auf, da Sie wissen,
da&szlig; der Buchstabe &quot;B&quot; eher am Anfang des Alphabets zu
finden ist. Obwohl Sie sich wahrscheinlich dessen nicht bewu&szlig;t sind,
machen Sie damit eine Interpolation. Dasselbe wollen wir uns nun auch beim
Interpolationssuchen zunutze machen. Anstatt das Feld durch m=l+(r-l)/2
streng in der Mitte zu teilen, sch&auml;tzen wir die zu erwartende Position
durch Miteinbeziehung der Schl&uuml;sselinformation ab:
m=l+(s-k[l])/(k[r]-k[l])*(r-l). Durch diese Absch&auml;tzung kann bei
relativ gleichverteilten Listen gegen&uuml;ber dem bin&auml;ren Suchen noch
an Geschwindigkeit gewonnen werden. Beachten Sie aber bitte, da&szlig;
durch die aufwendigere Berechnung und durch den Umstand, da&szlig; im
schlechtesten Fall alle Elemente mit dem gesuchten Schl&uuml;ssel
verglichen werden m&uuml;ssen, die Interpolationssuche auch sehr langsam
werden kann.</P>

<P ALIGN=CENTER><A NAME="13" HREF="#12"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#14"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<BR><CENTER><IMG WIDTH=400 HEIGHT=80 SRC="../images/werbung.gif" ALT="Werbung"></CENTER><BR>

<P>Wie leicht einzusehen ist, eignen sich diese Suchmethoden nicht f&uuml;r
die verkettete Speicherung von linearen Listen, da beispielsweise nicht
ohne weiteres auf das mittlere Element zugegriffen werden kann. Wenn man
hier ein Element in der Liste sucht, mu&szlig; man jedes einzelne Element
nacheinander mit dem gesuchten Schl&uuml;ssel vergleichen. Es ist nicht
schwer zu erkennen, da&szlig; die Effizienz dieser Suchstrategie stark
davon abh&auml;ngt, wie weit vorne das gesuchte Element in der Liste steht.
Deshalb versucht man, Elemente, nach denen h&auml;ufiger gesucht wird,
weiter an den Anfang der Liste zu stellen als jene, die weniger h&auml;ufig
ben&ouml;tigt werden. Solche Listen nennt man auch selbstanordnende Listen
und es gibt verschiedene Regeln, nach denen sie gebildet werden. Ich
m&ouml;chte an dieser Stelle die drei gebr&auml;uchlichsten Typen
vorstellen.</P>

<P ALIGN=CENTER><A NAME="14" HREF="#13"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#15"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Die Move-to-front-Regel sieht vor, da&szlig; ein Element, auf das (durch
eine Suche) zugegriffen wurde, an den Anfang der Liste zu stellen ist.
Dadurch befinden sich statistisch jene Elemente, die h&auml;ufig
ben&ouml;tigt werden, nach einer gewissen Einarbeitungszeit eher am Anfang
der Liste. Andererseits kann es nat&uuml;rlich passieren, da&szlig; auf ein
Element zugegriffen wird, da&szlig; eigentlich sehr selten ben&ouml;tigt
wird, und dieses dann ziemlich lange relativ weit am Anfang der Liste
steht.</P>

<P ALIGN=CENTER><A NAME="15" HREF="#14"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#16"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Dies ist bei der zweiten Methode, der Transpose-Regel, nicht so krass. Hier
wird ein Element, auf das zugegriffen wurde, mit seinem Vorg&auml;nger
vertauscht. Auch dadurch kommen die h&auml;ufiger ben&uuml;tzten Elemente
langsam an den Beginn der Liste. Dieses Verfahren ben&ouml;tigt hingegen
eine gr&ouml;&szlig;ere Einarbeitungszeit, macht daf&uuml;r aber weniger
Fehler als die Move-to-front-Regel, da die Elemente nur relativ langsam
wandern.</P>

<P ALIGN=CENTER><A NAME="16" HREF="#15"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#17"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<P>Die dritte Methode nennt sich Frequency Count und basiert auf einer eher
primitiven Idee. Es wird einfach zu jedem Knoten ein Z&auml;hler
mitgespeichert, der angibt, wie oft auf dieses Element zugegriffen worden
ist. Die Liste wird dann immer nach diesem Z&auml;hler absteigend sortiert
gehalten, soda&szlig; das am h&auml;ufigsten benutzte Element immer am
Anfang steht. Diese Methode ben&ouml;tigt aber enorm viel zus&auml;tzlichen
Speicherplatz und ist nicht viel besser als die Move-to-front-Regel,
soda&szlig; sie nur zur Anwendung kommen sollte, wenn die Anzahl der
Zugriffe sowieso im Knoten mitgespeichert werden. Die beiden anderen Regeln
sind ungef&auml;hr gleich gut geeignet. Welcher von beiden der Vorzug
gegeben werden soll, ist schwer zu beantworten. In der Literatur wird
oftmals die Move-to-front-Regel favorisiert, obwohl auch die
Transpose-Regel bei langer Laufzeit durch ihre Stabilit&auml;t besticht.
Grunds&auml;tzlich kann gesagt werden, da&szlig;, egal f&uuml;r welche
Regel man sich dann schlu&szlig;endlich entscheidet, sich die Verwendung
von selbstanordnenden Listen anstatt normaler verketteter Listen sicherlich
auszahlt, da der Mehraufwand f&uuml;r das oftmalige Umordnen durch den
Geschwindigkeitsgewinn beim Suchen mehr als wettgemacht wird. Trotzdem sind
die linearen Listen f&uuml;r den Suchvorgang nicht die beste Wahl, weshalb
wir im Verlauf dieses Kurses noch eine Datenstruktur kennenlernen werden,
die sich daf&uuml;r besser eignet und die eine Art von bin&auml;rer Suche
auch bei verketteter Speicherung zul&auml;&szlig;t.</P>

<P ALIGN=CENTER><A NAME="17" HREF="#16"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#99"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></P>

<PRE>
Kurs&uuml;bersicht:

<B>Teil 1 -- Einf&uuml;hrung und lineare Listen.</B>
Teil 2 -- Der Stapel und seine Anwendung.
Teil 3 -- Der Baum.
Teil 4 -- Anwendung von B&auml;umen.
Teil 5 -- Hashverfahren
Teil 6 -- Sortieren
</PRE>

			<BR>
			</TD>
		</TR>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=TOP ALIGN=LEFT>
				<P ALIGN=RIGHT>

					<A HREF="as-redax.html#markus">Markus &Ouml;llinger</A>
					&nbsp;&nbsp;&nbsp;
					<A HREF="../deutsch/0x0033.html"><IMG WIDTH=16 HEIGHT=10 SRC="../images/__german.gif" ALT="[ german ]" VSPACE=0 HSPACE=0 BORDER=1></A>
					&nbsp;&nbsp;&nbsp;
					<BR>

				</P>
				<BR><TABLE BORDER=0 CELLPADDING=8 CELLSPACING=0 ALIGN=CENTER WIDTH="90%">
				<TR VALIGN=TOP ALIGN=LEFT><TD>

<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="../images_02/prog.gif">Abb. 1: Entfernen durch Umkopieren.</A><BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="../images_02/prog_list.c">Programmierlisting</A> (shift-click!)<BR>

				</TD></TR>
				</TABLE>
			</TD>
			<TD BGCOLOR="#BF0000" VALIGN=TOP ALIGN=CENTER> &nbsp; 
			</TD>
		</TR>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=MIDDLE ALIGN=LEFT>
				<A HREF="#00"><IMG SRC="../images/_krumm_hi.gif" WIDTH=37 HEIGHT=29 BORDER=0 ALT="[Up]"></A>
				<A NAME="99"><FONT COLOR="#FFFFFF">&nbsp;</FONT></A>
			</TD>
			<TD BGCOLOR="#BF0000" VALIGN=BOTTOM ALIGN=RIGHT>
				<A HREF="0x0032.html"><IMG SRC="../images/_gerade_li.gif" WIDTH=22 HEIGHT=41 ALT="{" BORDER=0></A><A HREF="0x0034.html"><IMG SRC="../images/_gerade_re.gif" WIDTH=23 HEIGHT=41 ALT="}" BORDER=0></A>
			</TD>
		</TR>
	</TABLE>
</BODY>
</HTML>

@DATABASE "CD³²Outside"
@AUTHOR "CD³²-Allianz"
@NODE "Main" "CD³²Outside - Inhalt"
@TOC "MAIN"

                                    @{fg highlight}@{b}Februar/März/April 2001@{fg text}@{ub}
  CCCCCCCCC DDDDDD     33333 22222
  CC     CC DD   DD       33     22                     
  CC        DD    DD     33    222                    
  CC        DD    DD      33  22              
  CC        DD     DD  33333 22222     
  CC        DD     DD                 OOOO      t      o   d
  CC        DD     DD                 O  O     ttt         d 
  CC        DD    DD                  O  O u u  t   ss i   d eee
  CC        DD    DD                  O  O u u  t   s  i ddd eee
  CC     CC DD   DD                   O  O u u  t   s  i d d e 
  CCCCCCCCC DDDDDD                    OOOO uuu  tt ss  i ddd eee
                                                                 
                                    
@{"The CD³² is born again! powered by CD³²-Allianz" LINK "poweredby-2.jpg/MAIN"} 
-----------------------------------------------




CD³² Outside  -  Ausgabe No.3/2001  (Stand: 30.01.2001)


             
I N H A L T

   @{"Vorwort" LINK "Vorwort"}


   @{bg shine}News@{bg back}
   ----                     
    25.01.01: @{"Neue Details zum CD32 Games Install Kit v4.0 NG" LINK "News17"}
    14.01.01: @{"CDTVTools v1.0 veröffentlicht" LINK "News16"}
    10.01.01: @{"CD32/CDTV User Liste / CD32 Forever" LINK "News15"}
    10.01.01: @{"CD32 Games Install Kit v4.1 NG veröffentlicht" LINK "News14"}
    31.12.00: @{"Neuigkeiten auf unserer Developer-Site" LINK "News13"}
    31.12.00: @{"CD32 Forever Compilation CD angekündigt" LINK "News12"}
    31.12.00: @{"CD32 Outside wird erscheinen! :-)" LINK "News11"}
    26.12.00: @{"The Best of Airsoft Softwair Gold Edition site" LINK "News10"}
    26.12.00: @{"Keine weiteren Ausgaben der CD32 Outside :-(" LINK "News9"}
    12.12.00: @{"Ankündigung der CD32 Outside No.3" LINK "News8"}
    10.12.00: @{"Messerückblick" LINK "News7"}
    08.12.00: @{"Neue CD32-Webpage: CD32 Legal Dumping Projekt" LINK "News6"}
    08.12.00: @{"CD32-Allianz auf der WOA`2000 in Köln" LINK "News5"}
    08.12.00: @{"Nostalgie pur auf No Risc No Fun" LINK "News4"}  
    05.12.00: @{"Neue CD32-Corner Mailing-Liste eröffnet" LINK "News3"}  
    01.12.00: @{"CDTV go back" LINK "News2"}  
    01.10.00: @{"Interview bei No Risc No Fun" LINK "News1"}  

 

   @{bg shine}Reviews@{bg back}
   -------
    @{"Pinball Illusions" LINK "Review1"} 
    @{"Fighting Spirit" LINK "Review2"}
    @{"Erben der Erde" LINK "Review3"}
    @{"Lotus Trilogy" LINK "Review4"}

  
           

   @{b}@{u}@{bg shine}*** THEMA: CD³² Programmierung ***@{ub}@{uu}@{bg back}
   
   @{"Editorial" LINK "Editorial"}
   
   
    @{"   " link "Workshop1"} @{b}WriteChunkyPixels@{ub}@{par}
    @{"   " link "Workshop2"} @{b}LowLevel@{ub}@{par}
    @{"   " link "Workshop3"} @{b}NonVolatile@{ub}@{par}
    @{"   " link "Workshop4"} @{b}CD@{ub}@{par}


   @{b}@{u}@{bg shine}*** THEMA: CD³² Programmierung ***@{ub}@{uu}@{bg back}




   @{bg shine}Forum@{bg back}
   -----
    @{"Suche Flink" LINK "Forum1"}
    @{"Communicator II" LINK "Forum2"}
    @{"Ich glaub' ich sehe nicht richtig!" LINK "Forum3"}
    @{"Searching for a communicator" LINK "Forum4"}
    @{"Suche CDTV Developer-Kit ..." LINK "Forum5"}
    @{"CD-Rom mit CD32 nutzen?" LINK "Forum6"} 
    @{"CD32 im Tower" LINK "Forum7"}
    @{"CD32Games Downloaden" LINK "Forum8"}
    @{"Festplatte für SX32" LINK "Forum9"}
    @{"Gibt es XenonII für`s CD³²?" LINK "Forum10"}
    @{"Lotus fürs CD32" LINK "Forum11"}
    @{"Microcosm Musik" LINK "Forum12"}
    @{"PC mit CD32 vernetzen" LINK "Forum13"}
    @{"PC Tastatur am SX32Pro" LINK "Forum14"}
    @{"suche SX32" LINK "Forum15"}
    @{"Suche SX32pro" LINK "Forum16"}
    @{"Workbench-CD-ROM" LINK "Forum17"}
    @{"CD32 & OS3.9" LINK "Forum18"}
    @{"cdtv mit festplatte?" LINK "Forum19"}
    @{"Ein paar Fragen..." LINK "Forum20"}
    @{"Suche PIRATES! für CD32" LINK "Forum21"}
    @{"Wendatta für CD32" LINK "Forum22"}
    @{"Wing Commander CD32" LINK "Forum23"}
    @{"Worms" LINK "Forum24"}
    @{"Suche CDTV Logo" LINK "Forum25"}


   @{"CD32/CDTV User-Liste" LINK "cd32user"}

   @{"Werbung inserieren - Jetzt erst recht!" LINK "Werbung"}

   @{"Impressum" LINK "Impressum"}

   @{"Vorschau" LINK "Vorschau"}



© 2001 CD³²-Allianz (E-Mail: CD32-Allianz@gmx.de)

@ENDNODE



@NODE "Vorwort" "Vorwort"
@TOC "MAIN"

@{b}Vorwort@{ub} 
-------------------------------------------------

Sehr geehrte CD³²/CDTV User,

ich wünsche Euch ein gutes und erfolgreiches
Jahr 2001. Dieses Jahr soll auch aus Sicht
von Amiga Inc. und allen Amiga Usern ein
erfolgreiches werden, denn im Sommer kommt
das schon lang erwartete AmigaDE auf den
Markt. Man darf gespannt sein mit welchen
Features und Funktionen es aufwartet und
ob es den grossen Betriebssystemen wie
WindowsME, 2000, NT...usw., MacOS, Linux 
Paroli bieten kann, zu wünschen wäre es.
In diesem Jahr genauer gesagt Ende dieses
Jahres sollen dann eigene Rechner kommen.

Ich persönlich wäre schon froh wenn das
AmigeDE kommt. Denn dann könnte ich die
CD32 Outside wieder auf einem richtigen
AmigaOS erstellen und nicht wie es 
jetzt der Fall ist unter der AmigaOS
Emulation WinUAE. Ja Ihr lest richtig,
die Outside wird auf keinem AMIGA mehr
erstellt. Die momentane AMIGA-Situation
ist nicht sehr berauschend, daher sah
ich mich zu diesem Schritt gezwungen.
Für Euch wird sich aber nichts ändern,
denn die CD32 Outside wird weiterhin in
der gewohnt hohen Qualität erscheinen.

Was erwartet und nun dieses Jahr aus Sicht
eines CD32/CDTV User`s?

In diesem Jahr sollen nun endlich wieder
Spiele für das CD32 erscheinen und nicht
wenige. Desweiteren plane ich eine
Compilation an CD32,CDTV & CDXL Software.
Eine vierte Ausgabe der CD32 Outside 
sowie eine Veröffentlichung von 
CDXLv2 - The Next Generation dem Nachfolger
von CDXL wie auch dem AnimFX-Format sind
fest eingeplant. Wie immer brauche ich für
die Verwirklichung meiner Projekte Euch!

Für andere grössere Projekte muss ich aber
unbedingt wissen, wie viele CD32 und CDTV
User es aber noch insgesamt gibt, daher
möchte ich Euch bitten die CD32 User-Liste
ausgefüllt an mich zu schicken oder aber
online im CD32-Corner auszufüllen damit
ich einen genauen Überblick habe ob ich
mit diesem Projekten anfangen soll oder
nicht. Denn wie ich schon anderweitig mal
erwähnt habe ist es ein Unterschied etwas
für 5-6 oder aber für 50-60 User zu machen. 



Auf eine glorreiche Zukunft des CD³²,

Eure CD³²-Allianz


@ENDNODE



@NODE "News17" "Neue Details zum CD32 Games Install Kit v4.0 NG"
@TOC "MAIN"

@{b}@{u}Neue Details zum CD32 Games Install Kit v4.0 NG@{ub}@{uu}


Wegen großer Nachfrage, hier eine genauere Liste, was sich
im Install Kit v4.0 genau verbessert hat:

- Install2001 unterstützt RTG Grafikmodus für Grafikkarten-Benutzer

- es gibt jetzt sowohl ein Gadtools als auch ein MUI Interface für das
  Install Kit

- viele neue Spiele können installiert / emuliert werden

- Install2001 benutzt fast die Hälfte weniger Speicher, was die
  Kompatibilität besonders steigert

- beide Oberflächen wurden komplett überarbeitet und sind jetzt viel
  benutzerfreundlicher

- es können mehr Einstellungen vorgenommen werden

- die CD-ROM Unterstützung wurde erheblich verbessert

- der eingebaute Emulator unterstüzt nun mehr CD32-spezifische Dinge


Außerdem gab es natürlich noch viele andere Verbesserungen
sowie Fehlerbehebungen. Das CD32 Games Install Kit v4.0 ist
ausschließlich auf der The Best Of Airsoft Softwair Gold Edition CD-ROM
vorhanden, die bei mir für 29.95 DM inkl. Porto bestellt werden kann.

@ENDNODE

@NODE "News16" "CDTVTools v1.0 veröffentlicht"
@TOC "MAIN"

@{b}@{u}CDTVTools v1.0 veröffentlicht@{ub}@{uu}


Auf der Airsoft Softwair Homepage wurden soeben die
CDTVTools v1.0 veröffentlicht. Dieser Pack ist eine Sammlung
von Programmen, die die CDTV-Basislibrary benutzen, um auch
normalen Amiganwendern CDTV Feeling zu bescheren. Alle
enthaltenen Programme sind Commodities, die über Exchange
gesteuert werden können. So kann jetzt jeder z.B. den Original
CDTV Bildschirmschoner, CD-Spieler oder Voreinsteller starten.
Die Tools basieren alle auf der CDTV Basislibrary "playerprefs"
von Commodore, die im CDTV ROM enthalten ist. Da ich auf
der Developer CD v1.2 Dokumentationen zu dieser Library gefunden
habe, konnte ich diese Tools innerhalb von zwei Tagen entwickeln.
Sie sind selbstverständlich Freeware.

@ENDNODE

@NODE "News15" "CD32/CDTV User Liste / CD32 Forever"
@TOC "MAIN"

@{b}@{u}CD32/CDTV User Liste / CD32 Forever@{ub}@{uu}


Im CD32-Corner wird man zwei neue Seiten vorfinden zum einen die
CD32/CDTV User Liste worin sich solche User eintragen können
diese eines oder beide Geräte besitzen bzw. diese Interesse
daran gefunden haben. Diese Liste dient auch dazu um zu
erfahren ob es und wenn ja wie viele solcher User noch
existieren. Ich hoffe das die Beteiligung daran nicht zu
knapp ausfällt, denn es macht wirklich keinen Spass etwas für
2-3 User zu machen. :-(
An dieser Stelle möchte ich Henning Schlautmann danken der
dieses Script für uns fertigstellte und die Liste
betreuen wird.
Wir haben die Liste mit den gängigsten Amiga & PC Browsern
getestet, dabei kam heraus das die Amiga Browser keine
Probleme beim versenden hatten die PC Browser schon,
denn der Netscape Navigator 4.5 verweigerte völlig die
Übersendung der Daten wobei der Internet Explorer 5.5 dieses
zwar auch Tat die Daten trotzdem versendet wurden.

Bei der anderen Seite handelt es sich um die CD32 Forever
Support Seite in derer aufgelistet wird welche Daten sich
auf der CD befinden werden. Momentan sind rund 400MB
belegt, also noch eine Menge Platz vorhanden wobei man
dazu sagen muss das noch nicht alle Programme auf dieser
CD sind. Wenn Du noch einen Beitrag zur CD liefern möchtest,
dann schreib mich an und teile mir mit worum es sich
handelt. Das Du Namentlich erwähnt wirst und diese CD
um Längen billiger bekommst brauche ich hoffendlich
nicht zu erwähnen.

Als letztes möchte ich noch erwähnen das dringend nach
Redakteuren für die CD32 Outside gesucht wird,
bei Interesse bitte sofort melden!

@ENDNODE


@NODE "News14" "CD32 Games Install Kit v4.1 NG veröffentlicht"
@TOC "MAIN"

@{b}@{u}CD32 Games Install Kit v4.1 NG veröffentlicht@{ub}@{uu}


Auf der Airsoft Softwair Homepage (www.airsoftsoftwair.de) wurde
soeben das CD32 Games Install Kit v4.1 NG veröffentlicht. Allerdings kann
dieses Update nur von Besitzern der The Best Of Airsoft Softwair Gold
Edition CD-ROM benutzt und heruntergeladen werden. In Version 4.1 wurde der
integrierte Emulator stark in seiner Kompatibilität verbessert und es wurden
einige Fehler behoben. Besitzer der The Best of Airsoft Softwair Gold Edition
CD-ROM können das Update mit dem auf der CD-ROM enthaltenen Programm Updater
ab sofort herunterladen.

@ENDNODE


@NODE "News13" "Neuigkeiten auf unserer Developer-Site"
@TOC "MAIN"

@{b}@{u}Neuigkeiten auf unserer Developer-Site@{ub}@{uu}


Durch die Hilfe von Gernod Schomberg diesem ich an dieser Stelle recht
herzlich dafür danken möchte, stehen nun endlich wichtige Informationen
in deutscher Sprache auf der Developer-Site den Entwicklern bzw.
Programmierern von CD32 Software zur Verfügung. Dabei handelt es u.a.
um Dokumentationen zur Programmierung mittels des Akiko-Grafikchips.

Das alte Jahr ist vorbei und ich möchte Euch allen einen guten Rutsch
ins neue Jahr 2001 wünschen.

@ENDNODE


@NODE "News12" "CD32 Forever Compilation CD angekündigt"
@TOC "MAIN"

@{b}@{u}CD32 Forever Compilation CD angekündigt@{ub}@{uu}


Im neuen Jahr möchte ich das erste kommerzielle Produkt der CD32-Allianz 
anbieten können, dabei wird es sich um die "CD32 Forever" handeln, 
einer Compilation ausgewählter CD32/CDTV & CDXL Software.

Da dieses Produkt noch in einem frühen Stadium ist, möchte ich noch nicht
alles bekannt geben. Wer mit mir diese CD gestalten möchte, kann sich gerne
mit mir in Verbindung setzen. 
Natürlich werden auch die bisherigen Produktionen der CD32 Allianz sprich; 
CD32 Outside No.1-3, CD32 Cheats Guide v20 und der CD32-Corner auf der 
"CD32 Forever" CD zu finden sein.


@ENDNODE


@NODE "News11" "CD32 Outside wird erscheinen! :-)"
@TOC "MAIN"

@{b}@{u}CD32 Outside wird erscheinen! :-)@{ub}@{uu}


Vor ein paar Tagen noch sah es so aus als ob die 3. Ausgabe
der CD32 Outside nicht mehr erscheinen könne, der Grund
dafür bestand in dem Systemwechsel auf den PC, da dieser
kein AmigaGuide verarbeiten kann.
Dank der AmigaForever4 CD in dieser der WinUAE Amiga-Emulator
beiliegt, steht einem erscheinen der nächsten CD32 Outside
nichts mehr im Wege.

Vorraussichlich wird die CD32 Outside No.3 gegen Mitte bis
Ende Januar 2001 erscheinen.

@ENDNODE


@NODE "News10" "The Best of Airsoft Softwair Gold Edition site"
@TOC "MAIN"

@{b}@{u}The Best of Airsoft Softwair Gold Edition site@{ub}@{uu}


Auf der Airsoft Softwair Homepage "www.airsoftsoftwair.de" sind
jetzt die Support Seiten für die The Best of Airsoft Softwair Gold
Edition CD-ROM online gegangen. Dort können allerhand Informationen und 
bald auch Screenshots über die CD-ROM eingesehen werden. Außerdem
kann die CD-ROM auch dort bestellt werden.

Die The Best of Airsoft Softwair Gold Edition ist ab sofort zum Preis
von 29.95 DM direkt beim Autor erhältlich.

Außerdem wünscht Airsoft Softwair allen Amiga-Usern frohe
Weihnachten und ein erfolgreiches gesundes Jahr 2001!

@ENDNODE


@NODE "News9" "Keine weiteren Ausgaben der CD32 Outside :-("
@TOC "MAIN"

@{b}@{u}Keine weiteren Ausgaben der CD32 Outside :-(@{ub}@{uu}


Durch einen Systemwechsel ist es mir nicht mehr möglich
weitere Ausgaben der CD32 Outside zu publizieren, dies
trifft sicherlich auch mich schwer da es fest eingeplant
war weitere Ausgaben zu veröffentlichen. 
Dennoch wird der CD32-Corner weiterhin aktualisiert
werden.

@ENDNODE


@NODE "News8" "Ankündigung der CD32 Outside No.3"
@TOC "MAIN"

@{b}@{u}Ankündigung der CD32 Outside No.3@{ub}@{uu}


Für viele dürfte diese Meldung Überraschend kommen doch möchte
ich schnellst möglich die 3.Ausgabe der CD32 Outside veröffentlichen.

Auch diesmal gibt es wieder brandaktuelle News auch zu zukünftigen
Projekten der CD32-Allianz, daneben soll es wieder viele Reviews zu
schon erhältlichen CD32 Games geben sowie die dazugehörigen Tipps
& Tricks und auch ein Forum ist mit an Bord. 
Das Thema dieser Ausgabe lautet; CD32 Programmierung.
Neben ein paar anderen Dingen wird es eine Dokumentation
geben in dieser erläutert wird, wie man optimal mittels des
Akiko-Grafikchip programmiert bzw. diesen Chunky->Planar
Chip unterstützen kann.

Wer mich mit Reviews unterstützen möchte, der wende sich an die
CD32-Allianz (CD32-Allianz@gmx.de).

Sofern sich genügend User bereit erklären sollten sich mit
Reviews an mich zu wenden, wird eine Veröffentlichung im
Januar 2001 nicht ausgeschlossen. Änderungen vorbehalten.

@ENDNODE


@NODE "News7" "Messerückblick"
@TOC "MAIN"

@{b}@{u}Messerückblick@{ub}@{uu}


@{b}Leider war auch diesesmal das CD32 und das CDTV nicht so stark
präsent wie man es sich wünschen würde, denn es wurde lediglich
ein CD32 wie auch ein CDTV gezeigt, doch was darauf gezeigt wurde
reichte aus um die Leute zu begeistern.@{ub}

Am Stand von Eternity Software wurde z.B. der MAS-Player
in einem CDTV vorgeführt. Der MAS-Player ist eine MP3-
Erweiterung für alle Amiga`s; vorrangig älterer Amigas,
dieser es erlaubt MP3-Musik in CD-Qualität abzuspielen.
Damit könnte man sein CD32 oder aber CDTV zur ultimativen
MP3-Musik Station umbauen, zusätzlich unterstützt dieser
durch die mitgelieferte Software die Fernbedienung des CDTV.
Der MAS-Player kostet 159,-DM diesen man bei Eternity
beziehen kann.

Bei DreiEinHalb konnte man für das CDTV ein Mikrofon mit zusätzlichem
Mikrofon-Adapter, das CD32 Competition-Pro Joypad, viele Hefte einer
Sonderausgabe der CD32 Gamer (englisches CD32-Printmagazin; 1994 eingestellt)
mit dem Spiel Qwik, einiger Bücher zur generellen AMIGA Spieleprogrammierung
und einiger Peripherie erwerben.

Besonderes Highlight aus Sicht eines CD32-Users gab es aber am
Stand des Amiga-Club im BTX & Internet, denn dort wurde das CD32
samt dem leider nicht mehr erhältlichen MPEG-Modul gezeigt.
Neben den besten Spielen diese jemals für das CD32 erschienen sind,
wurden auch einige VideoCD`s u.a. StarWars - Episode 1 & Forest Gump
vorgespielt. Die Qualität war atemberaubend für MPEG1-Filme (Vorgänger
von DVD-Video; MPEG2), die Filme wurden fließend in Fullscreen (24Bit)
und die Soundausgabe in bester CD-Qualität (16Bit - 44.1kz) abgespielt.

@ENDNODE



@NODE "News6" "Neue CD32-Webpage: CD32 Legal Dumping Projekt"
@TOC "MAIN"

@{b}@{u}@{"Neue CD32-Webpage: CD32 Legal Dumping Projekt" LINK "cd32ldp.jpg/MAIN"}@{ub}@{uu}


Vorwiegend beschäftigt sich diese englische Homepage um das Herstellen 
von CD32 Spielen, durch einen Emulator dieser fähig sein soll jedes 
Amiga-Spiel das jemals erschienen ist auf dem CD32 lauffähig zu machen. 
Wer sich aber mal unsere Developer-Seiten angeschaut hat wird schnell 
bemerkt haben das dafür kein Emulator von nöten ist.


Die CD32 Legal Dumping Projekt Homepage ist unterteilt in;


@{b}* News:@{ub}
Hier wird man auf dem aktuellen Stand der Dinge gehalten welches weitere 
Amiga Spiel auf dem CD32 lauffähig gemacht wurde.

@{b}* Latest Release:@{ub}
Welche ISO-Datei von einem Amiga Spiel zuletzt hinzugekommen ist, diese 
Datei braucht man für das PC-Brennprogramm CDRWin/Fireburner um das 
gewünschte Spiel zu brennen bzw. CD32 lauffähig zu machen.

@{b}* Releases:@{ub}
Bisherige ISO-Dateien

@{b}* Missing/Own:@{ub}
Hier könnt Ihr Eure Wünsche für eine weitere CD32 Portierung eines
Amiga-Spieles kundtun das nie auf dem CD32 erschienen ist.

@{b}* Interviews:@{ub}
Momentan sind dort keine Interviews zu finden.

@{b}* Message Board:@{ub}
In diesem Forum könnt Ihr Eure Fragen bzw. Probleme kundtun.

@{b}* FAQ:@{ub}
So könnt auch Ihr Eure eigenen Amiga-Spiele CD32 tauglich machen,
das ganze sogar ganz legal.

@{b}* Emulators:@{ub}
Links zu Amiga-Emulatoren für andere Betriebssysteme.

@{b}* Links:@{ub}
Einige weitere CD32 Homepages, leider ist der CD32-Corner nicht
aufgeführt.

@ENDNODE



@NODE "News5" "CD32-Allianz auf der WOA`2000 in Köln"
@TOC "MAIN"

@{b}@{u}@{"CD32-Allianz auf der WOA`2000 in Köln" LINK "woa2000.gif/MAIN"}@{ub}@{uu}


Nachdem ich auch schon auf der Amiga-Messe in Krefeld-Neuss anwesend war,
werde ich auch diese Messe nicht auslassen. Wer mit mir in Kontakt treten
möchte hat hier die Chance dazu.

Leider wird es auch diesmal nichts mit einem eigenen Stand, da die
CD32-Allianz selbst nichts zu publizieren hat und Software von
Dritten noch Mangelware ist. Vielleicht wird sich dieses bis zur
nächsten Amiga-Messe nächstes Jahr schon geändert haben.

@ENDNODE


@NODE "News4" "Nostalgie pur auf No Risc No Fun"
@TOC "MAIN"

@{b}@{u}Nostalgie pur auf No Risc No Fun@{ub}@{uu}


Auf den Online-Seiten von No Risc No Fun findet man eine interessante
Nostalgie-Seite in derer auch das CD32 eine Rolle spielt. 

@{i}Bei soviel Nostalgie vermisse ich manchmal wirklich die wirklich
guten Zeiten des Amiga, wo man sich keine Sorgen um die Konkurrenz
machen musste, wo es jeden Monat neue Soft- wie auch Hardware gab.
Wo würde Commodore heute stehen wenn man mehrere CD32 hätte produzieren
können?@{ui}

@ENDNODE


@NODE "News3" "Neue CD32-Corner Mailing-Liste eröffnet"
@TOC "MAIN"

@{b}@{u}Neue CD32-Corner Mailing-Liste eröffnet@{ub}@{uu}


Die Mailing-Liste des CD32-Corner ist für jeden offen. Die einzige 
Bedingung ist, daß sich alle Beiträge auf das CD32 beziehen müssen. 
Wer sich nicht daran hält, wird aus der Mailing-Liste gelöscht.

Um etwas in der Mailing-Liste zu veröffentlichen senden Sie den Beitrag 
einfach an; cd32-corner@egroups.de.

@ENDNODE


@NODE "News2" "CDTV go back"
@TOC "MAIN"

@{b}@{u}CDTV go back@{ub}@{uu}


Lange Zeit wurden die News nicht mehr aktualisiert, dieses lag weniger daran
das sich die CD32-Allianz aufgelöst hatte sondern mehr das es keine News
betreffend des CD32 mehr gab bzw. gibt. Trotz das wir das CD32 Developer-Kit
zum freien Download anbieten findet sich niemand der Gebrauch davon macht,
dieses ist in sofern schade da es durch die Anleitung von Andreas Etzrodt
eigendlich ein Kinderspiel sein sollte. Aber nun gut, auch ich habe dieses
erkannt und muss handeln in dem ich zum CD32 auch das CDTV supporten werde,
weitere Details stehen im neuen Editorial.
Nun kann ich selber nur hoffen das wenigstens die Mischung beider Computer-
Systeme für mehr Schwung auch in Bezug auf News diese ich dann hier 
veröffentlichen kann bringen wird. Selber besass ich nie ein CDTV deshalb 
kenne ich mich nicht genau mit diesem AMIGA aus, doch gibt es da draussen 
hoffendlich noch CDTV-User diese besser darüber informiert sind und mir ihr 
Wissen vermitteln können.

An dieser Stelle nun möchte ich solche Händler, Firmen & Programmierer
aufrufen mich mit Informationen oder aber auch Testprodukten zu unterstützen,
diese auch so wie ich das CD32 oder aber auch das CDTV supporten bzw.
unterstützen. Als Gegenleistung bekommt man auf allen Seiten dieser Homepage
einen Werbebanner-Platz reserviert um sein Produkt, sei es Soft- oder
Hardware den wirklich interessierten Usern zu präsentieren. Man sollte nicht
übersehen das Sie hier im CD32/CDTV-Corner ihre wirklichen Kunden ansprechen.

Um nun den CDTV-Bereich auszuweiten benötige ich allerhand an Informationen,
Bildern, Fotos, Tests, Reviews- bzw. Previews, Anleitungen, Animationen,
Logos...etc.
Ich würde mich freuen wenn ein Anfang mit dem CDTV Developer-Kit gemacht werden
könnte um vielleicht noch ein paar User für das CDTV zu gewinnen. Meine eMail-
Adresse bleibt trotz der Auflösung der CD32-Allianz die gleiche 
( CD32-Allianz@gmx.de ).

In den nächsten Tagen wird es durch die Umstrukturierung eine neue Mailing-Liste
geben, der genaue Termin wird zu einem späteren Zeitpunkt bekannt gegeben.
Daher werden bis dahin keine weiteren Einträge zur alten Mailing-Liste mehr
angenommen, sobald die neue Mailing-Liste aktiv ist bitte ich diejenigen diese
bisher schon eingetragen waren (alte ML-Liste), sich in die neue einzutragen.

@ENDNODE


@NODE "News1" "Interview bei NoRiscNoFun"
@TOC "MAIN"

@{b}@{u}Interview bei No Risc No Fun@{ub}@{uu}


Auf den Seiten von No Risc No Fun befindet sich ein aktuelles Interview
mit Thorsten Schölzel von der ehemaligen CD32-Allianz und Macher
der AmigaNG-Programmübersicht.
Bei dem dortigen Interview erfährt man, ab wann Thorsten Schölzel
zum Amiga kam, wieso die CD32-Allianz gegründet worden ist,
was Thorsten in seiner Freizeit macht bzw. was seine Hobbys sind,
ob er als Programmierer tätig ist und wie er den AmigaNG/SDK-Markt
sieht bzw. wie die Erfolgsaussichten für den AmigaNG sind.

@{b}Für Interessierte allemal zu empfehlen!@{ub}

@ENDNODE





@NODE "Review1" "Pinball Illusions"
@TOC "MAIN"

Reviewed        : @{b}Pinball Illusions@{ub}
Reviewer        : Stefan Müller
Hersteller      : Digital Illusions
Vertrieb        : 21st Century Entertainment
Genre           : ?
Erscheinungsjahr: 1995




Nachdem 21st Century Entertainment mit Pinball Dreams und 
Pinball Fantasies bereits zwei Tophits für den A500
vorgelegt hatte, und sich somit einen Namen verschafft hatte,
folgte 1995 Pinball Illusions. Pinball Illusions erschien
erstmals nur für AGA-Maschinen. Fast zeitgleich erschien auch
die CD32-Version.

Also CD ins Laufwerk und auf gehts. Nach einer kurzen Einführungs-
sequenz gelangt man ins Hauptmenü. Von hieraus kann man sich
Informationen über die einzelnen Flippertische ansehen oder
einen dieser anwählen.

Es stehen 3 Flippertische zur Auswahl. Law n Justice, Babewatch und
Extreme Sports. Alle drei sind optisch gut gelungen und unterscheiden
sich in grafischer als auch spielerischer Hinsicht voneinander.
Alle Tische sind vollgepackt mit Bumpern und Rampen, wirken aber
nicht überladen, sodas die Übersicht zu jederzeit gewährleistet ist.
Erstmals wurde bei Pinball Illusions der Multiballmodus in einem
Pinballgame umgesetzt. Wird dieser aktiviert, so wird automatisch
in den HiRes-Interlaced Modus geschaltet (640*512). Dann heisst es
volle Konzentration, den bis zu drei Kugeln gleichzeitig auf dem
Tisch bringen selbst den erfahrensten Zocker ins schwitzen.
 

Der Sound des Tisches kommt vom Amiga, die Musik direkt von der CD.
Während bei Law n Justice sich die Musik wie ein Soundtrack aus
einem Film anhört, hört sich das ganze bei Extreme Sports sehr
rocklastig an. Bei Babewatch hört man Easylistening-Sound, der ebenfalls
gut zum Thema des Tisches passt.


Pinball Illusions weiss in technischer als auch in spielerischer
Hinsicht voll zu überzeugen. Die gute Grafik, der packende Soundtrack,
die Multiballoption, die animierte Scoreleiste und immer neue
Bonusspiele förden die Langzeitmotivation. So entdeckt man auch
nach längeren Zocksessions immer wieder etwas neues.


21st Century hat mit Pinball Illusions einen echten Hit für das CD32
hingelegt. Jeder der sich für Pinball interessiert, wird sofort
begeistert sein. Alle anderen werden vielleicht durch dieses Game
die Faszination Pinball erfahren.
Einziger Wermutstropfen: Statt wie bei den zwei Vorgängern vier,
stehen diesmal nur drei Flippertische zur Verfügung. Naja, die
Unterschiedlichkeit der einzelnen Tische lässt einem dieses Manko 
jedoch schnell vergessen.

Pinball Illusions CD32 ist ein Game das eigentlich in keiner
Sammlung fehlen sollte.


Wertung:

Grafik             80 %
Sound              85 %
Fun                90 %
------------------------
Gesamtbewertung    85%




@{bg shine}@{u}Screenshots:@{bg back}@{uu}                                  

@{"Front-Cover   " LINK "pinballill1.jpg/MAIN"}                               

@ENDNODE

@NODE "Review2" "Fighting Spirit"
@TOC "MAIN"

Reviewed        : @{b}Fighting Spirit@{ub}
Reviewer        : Stefan Müller
Hersteller      : Lightschock Software
Vertrieb        : NEO
Genre           : Beat´em Up
Erscheinungsjahr: 1996




1996 erschien Fighting Spirit für das CD32, welches von
Lightshock Software entwickelt wurde und von der Firma neo
gepublished wurde. Fighting Spirit ist ein 2D Beat´em Up,
das man am ehesten mit Street Fighter 2 vergleichen kann.

Nach dem Einlegen der CD gelangt man, nach einer kurzen
Einführungssequenz, in das Hauptmenü. Dieses bietet zahlreiche
Optionen. Bei den Spielmodi kann man zwischen Storymode, VS Battle,
Tournament und Team Match wählen.

Im Story Mode nimmt man am "Supreme Warriors Tournament" teil, dessen
Ziel es letztendlich ist Jenshi Yamamoto, den Boss der Hikawa
Geheimorganisation zu besiegen. Bei VS Battle kann man sich
einen beliebigen Gegner aussuchen, mit der Tournamentoption
an einem Tunier teilnehmen oder im Team Match mit bis zu drei
Mitstreitern antreten.

Überhaupt weisst das Game eine vorbildlich Optionsvielfalt auf.
Vom Schwierigkeitgrad, der Anzahl der Rounds oder Countinues...
es gibt kaum etwas das sich nicht am Geschmack des Gamers anpassen
ließe. Selbst die Belegung des CD32-Joypads ist variabel.

Die Grafik ist liebevoll gezeichnet und kommt in 256 Farben daher.
Teilweise sind sogar die Hintergründe animiert. Optisch besonders
ansprechend sind natürlich die Special Moves. Jeder Fighter
verfügt über vier verschiedene. Wem jedoch die Anleitung
nicht zur Hand liegt, dem wird es äußerst schwer fallen einen
diese Moves zu erzeugen. Hier heißt es Anleitung zu Hand und
sich die Kombinationen gut einprägen.

Die SoundFX werden Amiga erzeugt und die Music kommt direkt von
der CD. Beide sind zwar nicht das nonplusultra, tragen jedoch
gut zur Stimmung des Games bei.

Mit Fighting Spirit CD32 ist den Jungs von Lightshock/neo ein tolles
Game gelungen, das durchaus heute noch zu überzeugen weiß.


Grafik               85%
Sound                80%
Fun                  85%
-----------------------------
Gesamtwertung        83%




@{bg shine}@{u}Screenshots:@{bg back}@{uu}                                  

@{"Front-Cover   " LINK "fighspirit1.jpg/MAIN"}                               
@{"Back-Cover   " LINK "fighspirit2.jpg/MAIN"} 

@ENDNODE

@NODE "Review3" "Erben der Erde"
@TOC "MAIN"

Reviewed        : @{b}Erben der Erde@{ub}
Reviewer        : Robert C.
Hersteller      : New World Computing
Vertrieb        : Softgold
Genre           : Denk- & Rollenspiel
Erscheinungsjahr: 1996




Die Menschheit ist bereits Geschichte und die Erde gehört wieder
ganz den Tieren. Plötzlich verschwindet die Sturmkugel.
Rif, dem schlauen Fuchs und Helden der Geschichte, wird dieser
Diebstahl vorgeworfen. Nun ist es die Aufgabe des Spielers,
Rifs Unschuld zu beweisen. Und es bleiben ihm nur wenige Tage Zeit,
eben dies zu beweisen. Nun gilt es das wilde Land zu erforschen.....

Erben der Erde kommt in einer schönen und aufwendig gestalteten
Pappverpackung daher. Innen liegt dann nochmals ein schön
gestaltetes Jewelcase drin, welches die Game-CD beinhaltet.
Ausserdem liegt der Verpackung noch eine gute und leicht
verständliche Anleitung und ein vierseitiges technisches Manual bei.

Also CD32 an und los geht es. Was bereits in der Einleitung
auffällt, ist die professionelle komplett deutsche Sprachausgabe.
Diese stellt ein Novum auf den CD32 dar. Jeder Charakter hat
seine individuelle Ausdrucksform die perfekt zum jeweiligen
Typen passt. 
Die Grafik ist sauber und detailiert in 256 Farben gezeichnet.
Die einzelnen Locations werden in der adventuretypischen Seiten-
ansicht dargestellt während man sich innerhalb der Umgebung in
einer isometrischen 3D-Darstellung bewegt.

Das besondere an der CD ist, das neben der CD32-Version,
ebenso eine AGA und eine ECS-Version vorliegt. Die ECS-Version
läuft natürlich auch auf OCS-Amigas, sodaß wirklich jeder Amiga-
user in den Genuss des Games kommen kann. Dies schließt das
CDTV selbstverständlich mit ein (1.5MB Ram wird allerdings 
mind. benötigt).
Positiv auch das schnellere Prozessoren und Fastram unterstützt
wird. Also können auch User die eine Erweiterung wie z.B. das 
SX-32 haben davon partizipieren.  

Erben der Erde gehört mit Sicherheit zu den besten Adventures
auf dem CD32. Die tolle Grafik und vor allem die Sprachausgabe
in Hörspielqualität wissen zu überzeugen. Auch das Gameplay 
garantiert langen Spielspass. Ein Game das eigentlich in jede
Sammlung gehört.

----------------------------
Grafik                 9/10
Sound                 10/10
Gameplay               9/10
----------------------------
Bewertung              9/10
----------------------------


@ENDNODE

@NODE "Review4" "Lotus Trilogy"
@TOC "MAIN"

Reviewed        : @{b}Lotus Trilogy@{ub}
Reviewer        : Robert C.
Hersteller      : Magnetic Field
Vertrieb        : Gremlin Interactive
Genre           : Rennspiel
Erscheinungsjahr: 1994




Die Lotus Rennserie sollte eigentlich jedem Amiga-User ein
Begriff sein und stellte damals sicherlich Plattformübergreifend
das Novum in Sachen Racing-Games dar. Nachdem mit Lotus 1
der Grundstein gelegt wurde, folgten mit Lotus 2 und schließlich
Lotus 3 die logischen Nachfolger.

Die CD, welche in einem Jewelcase daherkommt, beinhaltet eben
diese komplette Triologie. Bei den Games handelt es sich im
Grunde um 1:1 Umsetzungen der Orginale. Der Musik kommt komplett
von CD. Und um eines gleich vorweg zu nehmen... ja auch heute
noch macht Lotus einen Riesenspass. Gefahren wie Regen, Blitze,
Nebel, Schnee, Sandstürme, Pendlerverkehr..etc. lassen keine
Langeweile aufkommen. Auch in Sachen Speed geht es richtig ab.
Besonders der 2 Spieler Modus via Splitscreen bringt mächtig
fun. Dabei sind weder Sichtminderungen noch Geschwindigkeits-
einbußem zu verzeichnen. Und Fahrzeuge wie der Lotus Esprit,
der Elan und das Konzeptfahrzeug M200 lassen das Herz eines
jeden Autonarren höherschlagen.

Die Lotus-Triologie zählt mit Sicherheit zu den besseren 
Vertretern in Sachen Racing auf dem CD32. Hier erhät man drei
Toptitel zum Preis von einem. Wer Autorennen mag, der mag
auch die Lotus Triologie.


-----------------------------
Grafik                8/10
Sound                 8/10
Gameplay              9/10
-----------------------------
Bewertung             8/10
-----------------------------




@{bg shine}@{u}Screenshots:@{bg back}@{uu}                                  

@{"Front-Cover   " LINK "lotustrilogy1.jpg/MAIN"}                               
@{"InGame-Grafik   " LINK "lotustrilogy2.jpg/MAIN"} 

@ENDNODE


@NODE "Editorial" "Editorial"
@TOC "MAIN"

@{b}@{u}Editorial@{ub}@{uu}


Das CD32 war der letzte AMIGA dieser von Commodore gebaut und
auf den Markt gebracht wurde. Viele sagten damals wie heute
das dieses CD32 nur ein AMIGA1200 mit CD-Rom Laufwerk ist,
doch ist das CD32 weitaus mehr. Den ersten Unterschied erkennt
man wenn man sich die Hauptplatine anschaut, dieses 
mit Leichtigkeit in ein Laptop passen würde. Als nächstes
erkennt man den Hauptunterschied zwischen dem CD32 und 
normalen AMIGA`s gemeint ist das standartmässige SCSI
2xfach CD-Rom Laufwerk von Sony. Als nächstes kommen wir
zu einem neuen Grafikchip dem Akiko-Grafikchip dieser für
schnelle Umrechnungen von Chunky -> Planar benutzt,
leider machten wenige CD32 Spiele wie z.B. Microcosm 
Gebrauch von diesem Grafikchip. Dann wäre da noch das 1KB
NV-Ram worin man seine Spielstände abspeichern konnte.
Als letztes wurden Spiele auf normalen Amiga`s mit einem
Joystick gespielt, Commodore führte mit dem CD32 auch
gleichzeitig das Joypad ein, obwohl das original Joypad
noch recht primitv aussah und umständlich zu bedienen war,
kam bald das Competition PRO CD32 Joypad auf den Markt,
dieses mehr Funktionen hatte und leicht zu bedienen war.
Auch heute noch spielen viele Amiga-User mit diesem CD32
Competition PRO Joypad.


Lasst mich jetzt mal kurz aufführen welche Neuerungen
das CD32 gegenüber den anderen AMIGA`s hatte;

* Hauptplatine
* SCSI 2xfach CD-Rom Laufwerk
* Akiko-Grafikchip
* NV-Ram
* Joypad


Dieses nun mal von der Hardware Seite gesehen aber auch die
Software entzückt und macht Lust auf mehr, denn man musste
sein Spiel dem CD32 anpassen da es z.B. kein Disketten-
Laufwerk gab oder aber eine Tastatur und Maus vorhanden
war, man war also gezwungen alles über das Joypad zu steuern,
also musste man auch seine Software darauf einstellen,
wie genau das gemacht wird, steht in dem Artikel "LowLevel".
Toll man spielt nun das CD32 Game und irgendwann hat man
keine Lust mehr und will abspeichern, doch es ist kein
Disketten-Laufwerk vorhanden nur das 1KB NV-Ram, auch
hierbei muss sich das Game anpassen, wie man nun sein
Spielstand in das NV-Ram bekommt steht unter "Nonvolatile".
3D Dungeons z.B. benötigen eine Chunky -> Planar Umwandlung,
dieses sehr rechenintensiv ist und vom 68020MHz Prozessor 
des CD32 kaum alleine bewältigt werden könnte, doch war
man bei Commodore nicht blöd und schickte das CD32 mit dem
Akiko-Grafikchip ins Rennen dieses genau für solche Umwandlungen
eingesetzt werden konnte. Wie das genau geht steht in 
"WriteChunkyPixels". Und zu guter letzt muss das Spiel
auf dem CD32 erst einmal gestaret werden, auch hierfür
hat sich Commodore was einfallen lassen und entwickelte
die FreeAnim.library durch diese das Spiel gestartet wird.
Aber auch hier musste man sein Programm anpassen, lest
wie es geht unter "CD". 

@ENDNODE

@NODE "Workshop1" "WriteChunkyPixels"
@TOC "MAIN"
@font helvetica.font 13


@{b}@{u}Write Chunky Pixels@{ub}@{uu}


Zu Ihrer Unterstützung ist unten das Autodoc für die neue V40-Funktion
WriteChunkyPixels beigefügt. Alle CD32-Entwickler sollten das volle
OS V40 auf ihren Entwicklungsmaschinen haben, sowie V40 Autodocs,
Includes, Libs and fds. Archive der V40-Workbench-Disk, V40-Kickfiles
und V40-Entwicklungsdateien können von unserer nichtöffentlichen
Entwickler-Konferenz bei BIX (US), ADPS (Europa) und CIX (UK) herunter
geladen werden.


graphics.library/WriteChunkyPixels         graphics.library/WriteChunkyPixels

   NAME
    WriteChunkyPixels -- schreibt den Farben-Kennwert (pen number
        value) einer rechteckigen Gruppe von Pixeln, beginnend am mit
        x,y gekennzeichneten Ort und weiterlaufend bis zu einer anderen
        x,y-Position innerhalb eines bestimmten Rastports. (V40)

   SYNOPSIS
    WriteChunkyPixels(rp,xstart,ystart,xstop,ystop,array,bytesperrow)
                      A0 D0     D1     D2    D3    A2     D4

    VOID WriteChunkyPixels(struct  RastPort *, LONG, LONG,
         LONG, LONG, UBYTE *, LONG);

   FUNKTION
        Für jedes Pixel in einem rechteckigen Bereich decodieren der Farb-
        Kennwert-Nummer (pen number) aus einer linearen Anordnung (linear
        array) von Kennwert-Nummern in die Bit-Ebenen, die zur Beschreibung
        eines bestimmten Rastports verwendet werden.

   EINGABEN
    rp     -  Zeiger auf eine RastPort-Strukture
    (xstart,ystart) -  Anfangspunkt im RastPort
    (xstop,ystop)   -  Endpunkt im RastPort
    array  - Zeiger auf ein Array von UBYTEs, von dem die Pixel-Daten
                 zu holen sind.
    bytesperrow - Die Zahl der Bytes pro Reihe im Quell-Array. Sie sollte
                 mindestens so groß sein wie die Zahl der Pixel, die je Linie
                 geschrieben werden.

   RÜCKGABE

   ANMERKUNG
    xstop muss >= xstart sein
    ystop muss >= ystart sein
    Das Quell-Array kann im FAST RAM liegen.

   ===chunky-to-planar Umwandlungs-HW:

   GfxBase->ChunkyToPlanarPtr ist entweder NULL oder ein Zeiger auf
   ein HW-Register, das zur Unterstützung im Prozess der Umwandlung
   aus 8-Bit-Chunky-Pixeldaten in das Bit-Plane-Format der Custom-
   Chips des Amiga zur Bilddarstellung verwendet wird. Wenn NULL
   zurück gegeben wird, ist solche Hardware nicht vorhanden.

   Wenn ein Erweiterungsgerät Hardware zur Verfügung stellt, welche
   kompatibel arbeitet, dann kann es während des Bootens die HW-Adresse
   in diesen Zeiger installieren und das System verwendet sie.

   Dieser Zeiger kann zum direkten Zugang zur Umwandlung Chunky-to-Planar
   verwendet werden, wenn mehr gewünscht wird als die einfache Chunky-
   Pixel-Kopie, die mit WriteChunkyPixels() ausgeführt wird.

   Wenn die Hardware direkt verwendet wird, sollte nur auf sie zugegriffen
   werden, wenn dieser Auftrag (task) den Blitter kontrolliert (über
   OwnBlitter()), denn dies ist der notwendige Ausschluss (locking), um
   die Anwendung dieses Gerätes zu vermitteln.

   Die Hardware kann als Gerät angesehen werden, welches 32 8-Bit-Pixel
   akzeptiert und 8 Langworte an Bitplane-Daten ausgibt.

   Um korrekt zu arbeiten, müssen genau 8 Langworte (die 32 Pixel
   enthalten) Chunky-Daten nach *(GfxBase->ChunkyToPlanarPtr) geschrieben
   werden. Nachdem die Daten geschrieben wurden, können die Bitplane-
   Daten (beginnend mit Ebene (plane) 0) als jeweils ein Langwort zurück
   gelesen werden. Es nicht erforderlich alle 8 Langworte zurück zu
   lesen, wenn die Bitplanes höherer Ordnung nicht benötigt werden.

   Da (zur Zeit) WriteChunkyPixels nicht besonders schnell auf Systemen
   ohne die chunky-to-planar-Hardware ist, können zeitkritische
   Anwendungen (Spiele usw.) ihre eigenen angepassten Umwandlungs-
   Routinen anwenden, wenn GfxBase->ChunkyToPlanarPtr NULL ist und
   andernfalls WriteChunkyPixels() aufrufen.

   Dieser Zeiger ist nur vorhanden in GfxBase in der Version >= 40 der
   graphics.library, deshalb sollte das geprüft werden, ehe der Zeiger
   gelesen wird.

   BUGS
        Nicht besonders schnell auf Systemen ohne Hardware zur
        Chunky-to-Planar-Umwandlung.

   SIEHE AUCH
    WritePixel()  graphics/rastport.h

@{par}

@ENDNODE



@NODE "Workshop2" "LowLevel"
@TOC "MAIN"
@font helvetica.font 13


@{b}@{u}Low Level@{ub}@{uu}


INHALTSVERZEICHNIS

lowlevel.library/AddKBInt
lowlevel.library/AddTimerInt
lowlevel.library/AddVBlankInt
lowlevel.library/ElapsedTime
lowlevel.library/GetKey
lowlevel.library/GetLanguageSelection
lowlevel.library/QueryKeys
lowlevel.library/ReadJoyPort
lowlevel.library/RemKBInt
lowlevel.library/RemTimerInt
lowlevel.library/RemVBlankInt
lowlevel.library/SetJoyPortAttrsA
lowlevel.library/StartTimerInt
lowlevel.library/StopTimerInt
lowlevel.library/SystemControlA


lowlevel.library/AddKBInt                           lowlevel.library/AddKBInt

   NAME
    AddKBInt -- Fügt eine Routine zum Keyboard-Interrupt hinzu. (V40)

   SYNOPSIS
    intHandle = AddKBInt(intRoutine, intData);
    D0                   A0          A1

    APTR AddKBInt(APTR, APTR);

   FUNKTION
        Diese Routine erweitert die Funktionalität des Keyboard-Interrupts
        um den Zusatz intRoutine. Da dies eine Erweiterung des normalen
        Keyboard-Interrupts ist, wird das gesamte Keyboard-Protokoll
        bearbeitet. Die Fehlermeldungen des Keyboards werden ausgefiltert
        und nicht an intRoutine gesandt.

        Die Routine wird jedesmal aufgerufen, wenn der Anwender eine Taste
        auf dem Keyboard drückt.

        Die Routine wird aus einem Interrupt heraus aufgerufen, deshalb
        gelten normale Einschränkungen. Die Routine muss die Inhalte
        folgender Register erhalten: A2, A3, A4, A7, D2-D7. Andere
        Register sind ohne Vorgabe (scratch) außer D0, welches beim
        Verlassen AUF 0 GESETZT WERDEN MUSS. Beim Eintritt in die Routine
        enthält A1 'intData', A5 enthält 'intRoutine' und D0 enthält den
        Tastencode (rawkey code), der von der Tastatur gelesen wurde.

        Die Routine wird nicht aufgerufen, wenn ein Keyboard-Reset
        empfangen wurde.

        Dies ist eine Low-Level-Funktion, die nicht in das normale Amiga-
        Multitasking-Modell passt. Der installierte Interrupt hat keine
        Kenntnis, welches Fenster/welcher Schirm aktuell Eingaben empfängt.

        Wenn das Programm ohne Neustart des Systems endet, MUSS vor Ende
        RemKBInt() aufgerufen werden.

        Nur eine Interrupt-Routine darf zum System hinzu gefügt werden.
        Es ist IMMER der Rückgabewert zu prüfen, ob ein anderer Prozess
        diese Funktion bereits verwendet.

   EINGABEN
    intRoutine - Die Routine, die bei jeder vertikalen Austastlücke
                     (vblank) aufgerufen werden soll. Diese Routine sollte
                     so kurz wie möglich sein, um den Einfluss auf das
                     allgemeine Betriebsverhalten so gering wie möglich zu
                     halten.
    intData - Daten, die der Routine im Register A1 übergeben werden.
                  Wenn mehr als ein Langwort benötigt wird, sollte dies
                  ein Zeiger auf eine Struktur sein, welche die
                  erforderlichen Daten enthält.

   RÜCKGABE
    intHandle - Eine Kennung (handle), um den Interrupt handhaben zu
                    können, oder NULL, wenn die Routine nicht angehängt
                    werden konnte.

   SIEHE AUCH
    RemKBInt()


lowlevel.library/AddTimerInt                     lowlevel.library/AddTimerInt

   NAME
    AddTimerInt -- Fügt einen Interrupt hinzu, der in regelmäßigen
                       Abständen ausgeführt wird. (V40)

   SYNOPSIS
    intHandle = AddTimerInt(intRoutine, intData);
    D0                      A0          A1

    APTR AddTimerInt(APTR, APTR);

   FUNKTION
        Der Aufruf dieser Routine veranlasst das System einen CIA-Timer
        zu belegen und eine 'intRoutine' einzurichten, die jeden Interrupt
        bedient, der von diesem Timer verursacht wird. Obwohl der Timer
        belegt wurde, läuft er nicht noch ist er aktiviert. Zunächst muss
        StartIntTimer() aufgerufen werden, um die Zeitabstände einzurichten
        und den Timer zu starten.

        Die Routine wird aus einem Interrupt heraus aufgerufen, deshalb
        gelten normale Einschränkungen. Die Routine muss die Inhalte
        folgender Register erhalten: A2, A3, A4, A7, D2-D7. Andere
        Register sind ohne Vorgabe (scratch) außer D0, welches beim
        Verlassen AUF 0 GESETZT WERDEN MUSS. Beim Eintritt in die Routine
        enthält A1 'intData', A5 enthält 'intRoutine'.

        Nur ein einziger CIA-Timer wird durch diese Routine belegt. Deshalb
        darf diese Routine nur einmal aufgerufen werden, wenn nicht
        dazwischen ein Aufruf von RemTimerInt() erfolgt.

        Der von dieser Routine verwendete CIA-Timer muss nicht bei jedem
        Aufruf der Selbe sein. Die Routine greift auf die CIA-Resource zu
        und verwendet einen nicht belegten Timer.

        Wenn das Programm ohne Neustart des Systems endet, MÜSSEN vor Ende
        alle Aufrufe dieser Funktion durch die gleiche Zahl von Aufrufen
        von RemKBInt() ausgeglichen werden.

        Selbst wenn die Funktion nur einmal im Programm verwendet wird,
        macht die Prüfung der Rückgabe das Programm toleranter für das
        Multitasking auf der Amiga-Computer-Platform.

   EINGABEN
    intRoutine - Die Routine, die bei Timer-Interrupt aufgerufen werden
                     soll. Diese Routine sollte so kurz wie möglich sein,
                     um den Einfluss auf das allgemeine Betriebsverhalten so
                     gering wie möglich zu halten.
    intData - Daten, die der Routine im Register A1 übergeben werden.
                  Wenn mehr als ein Langwort benötigt wird, sollte dies
                  ein Zeiger auf eine Struktur sein, welche die
                  erforderlichen Daten enthält.
 
   RÜCKGABE
    intHandle - Eine Kennung (handle), um den Interrupt handhaben zu
                    können, oder NULL, wenn die Routine nicht angehängt
                    werden konnte.
 
   SIEHE AUCH
    RemTimerInt(), StopTimerInt(), StartTimerInt()


lowlevel.library/AddVBlankInt                   lowlevel.library/AddVBlankInt

   NAME
    AddVBlankInt -- Fügt eine Routine hinzu, die bei jedem vertikalen
                        Austastimpuls (vertical blank) ausgeführt wird. (V40)

   SYNOPSIS
    intHandle = AddVBlankInt(intRoutine, intData);
    D0                 a0      a1

    APTR AddVBlankInt(APTR, APTR);

   FUNKTION
        Damit kann dem System eine Routine hinzugefügt werden, welche bei
        jedem vertikalen Austastimpuls aufgerufen wird

        Die Routine wird aus einem Interrupt heraus aufgerufen, deshalb
        gelten normale Einschränkungen. Die Routine muss die Inhalte
        folgender Register erhalten: A2, A3, A4, A7, D2-D7. Andere
        Register sind ohne Vorgabe (scratch) außer D0, welches beim
        Verlassen AUF 0 GESETZT WERDEN MUSS. Beim Eintritt in die Routine
        enthält A1 'intData', A5 enthält 'intRoutine'.

        Wenn das Programm ohne Neustart des Systems endet, MUSS vor Ende
        RemVBlankInt() aufgerufen werden.

        Nur eine Interrupt-Routine darf zum System hinzu gefügt werden.
        Es ist IMMER der Rückgabewert zu prüfen, ob ein anderer Vorgang
        diese Funktion bereits verwendet.

   EINGABEN
    intRoutine - Die Routine, die bei jeder vertikalen Austastung (vblank)
                     aufgerufen werden soll. Diese Routine sollte so kurz
                     wie möglich sein, um den Einfluss auf das allgemeine
                     Betriebsverhalten so gering wie möglich zu halten.
    intData - Daten, die der Routine im Register A1 übergeben werden.
                  Wenn mehr als ein Langwort benötigt wird, sollte dies
                  ein Zeiger auf eine Struktur sein, welche die
                  erforderlichen Daten enthält.

   RÜCKGABE
    intHandle - Eine Kennung (handle), um den Interrupt handhaben zu
                    können, oder NULL, wenn die Routine nicht angehängt
                    werden konnte.

   SIEHE AUCH
    RemVBlankInt()


lowlevel.library/ElapsedTime                     lowlevel.library/ElapsedTime

   NAME
    ElapsedTime -- Gibt die Zeit zurück, die seit dem letzten Aufruf
                       vergangen ist. (V40)

   SYNOPSIS
    fractionalSeconds = ElapsedTime(context);
    D0                              A0

    ULONG ElapsedTime(struct EClockVal *);

   FUNKTION
        Diese Funktion benützt die Funktion timer.device/ReadEClock(),
        um den genauen Wert der vergangenen Zeit zu erhalten. Da mit dem
        ersten Aufruf dieser Routine zunächst die Voraussetzungen geschaffen
        werden müssen, wird dabei ein sinnloser Wert ausgegeben.

        Der Rückgabewert für diese Funktion bietet nur einen Wert von
        sechzehn Bit für die Ganzzahl der Sekunden und sechzehn Bit für
        den gebrochenen Wert.

        Mit einem Wert von 16 Bit für die ganze Zahl der Sekunden kann
        diese Funktion als Timer bis zu ungefähr 16 Stunden verwendet
        werden. Wenn die tatsächlich verflossenene Zeit größer ist, wird
        dieser Maximalwert zurück gegeben.

        Die sechzehn Bit für den gebrochenen Teil der Sekunden ergeben
        eine Auflösung von ungefähr 20 Mikrosekunden. Jedoch wird nicht
        empfohlen, diese Funktion bei Zeitintervallen von weniger als 200
        Mikrosekunden als genau anzusehen.

   EINGABEN
    context - Zeiger auf eine Struktur EClockVal. Beim ersten Aufruf
                  dieser Funktion sollte die Struktur auf 0 Sekunden
                  initialisiert werden. Danach sollte die gleiche Struktur
                  bei folgenden Aufrufen der Funktion wieder verwendet
                  werden, denn so wird die vergangene Zeit berechnet.

   RÜCKGABE
    fractionalSeconds - Die vergangene Zeit als Festpunkt-32-Bit-Zahl
                            mit dem Dezimalpunkt fest in der Mitte. Das
                            bedeutet, das die oberen sechzehn Bit die Zahl
                            der verflossenen Sekunden darstellen. Die
                            unteren sechzehn Bit geben den Bruchteil der
                            vergangenen Sekunden an. Dieser Wert ist auf
                            ungefähr 16 Stunden begrenzt. Obwohl die
                            Zeitangabe auf etwa 20 Mikrosekunden genau
                            angegeben ist, liegt die tatsächliche Genauigkeit
                            nur bei etwa 200 Mikrosekunden.

   WARNUNG
        Der erste Aufruf dieser Funktion gibt einen sinnlosen Wert zurück.
        Erst ab dem zweiten Aufruf erhält man verlässliche Werte.

   SIEHE AUCH
    timer.device/ReadEClock()


lowlevel.library/GetKey                               lowlevel.library/GetKey

   NAME
    GetKey -- Gibt die gerade gedrückte Taste im "rawkey code" und die
                  gedrückten Sondertasten (qualifiers) zurück. (V.40)

   SYNOPSIS
    key = GetKey();
    D0

    ULONG GetKey(VOID);

   FUNKTION
        Diese Funktion gibt die aktuell gedrückte normale Taste und alle
        gedrückten Sondertasten zurück.

        Diese Funktion ist sicher innerhalb eines Interrupts.

        Dies ist eine Low-Level-Funktion, die nicht in das normale Amiga-
        Multitasking-Modell passt. Der installierte Interrupt hat keine
        Kenntnis, welches Fenster/welcher Schirm aktuell Eingaben empfängt.

   RÜCKGABE
    key - Tastaturcode der zuletzt gedrückten normalen Taste im
              Wort niederer Ordnung. Wenn keine Taste gedrückt ist, ist
              der Wert dieses Wortes FF. Das Wort hoher Ordnung enthält
              die Sondertasten, die im Langwort wie folgt zu finden sind:
              
                    Markierung                Taste

                    LLKB_LSHIFT             Links Shift
                    LLKB_RSHIFT             Rechts Shift
                    LLKB_CAPSLOCK           Shift Feststeller
                    LLKB_CONTROL            Control
                    LLKB_LALT               Links Alt
                    LLKB_RALT               Rechts Alt
                    LLKB_LAMIGA             Links Amiga
                    LLKB_RAMIGA             Rechts Amiga

   SIEHE AUCH
    <libraries/lowlevel.h>


lowlevel.library/GetLanguageSelection   lowlevel.library/GetLanguageSelection

   NAME
    GetLanguageSelection -- Gibt die aktuelle Sprachauswahl zurück. (V40)

   SYNOPSIS
    language = GetLanguageSelection();
    D0

    ULONG GetLanguageSelection (VOID);

   FUNKTION
        Ermitteln, welche Sprache der Anwender eingestellt hat.

   RÜCKGABE
    language - Vom Anwender eingestellte Sprache oder Null, wenn bisher
                   keine ausgewählt wurde. Siehe <libraries/lowlevel.h>
                   über zur Zeit unterstützte Sprachen.

   SIEHE AUCH
    <libraries/lowlevel.h>, locale.doc


lowlevel.library/QueryKeys                         lowlevel.library/QueryKeys

   NAME
    QueryKeys -- Gibt den Zustand einer Gruppe von Tasten zurück. (V40)

   SYNOPSIS
    QueryKeys(queryArray, arraySize);
              A0          D1

    VOID QueryKeys(struct KeyQuery *, UBYTE);

   FUNKTION
        Durchsucht die Tastatur um zu ermitteln, welche der Tasten, 
        deren Codes (rawkey codes) im QueryArray aufgelistet sind, z.Zt.
        gedrückt sind. Der Zustand jeder Taste wird im Array zurück gegeben.

        Diese Funktion kann innerhalb eines Interrupts aufgerufen werden,
        aber die Größe von QueryArray sollte so klein wie möglich gehalten
        werden.

        Dies ist eine Low-Level-Funktion, die nicht in das normale Amiga-
        Multitasking-Modell passt. Die zurück gegebenen Werte haben keine
        Kenntnis, welches Fenster/welcher Schirm aktuell Eingaben empfängt.

   EINGABEN
    queryArray - Ein Array von KeyQuery-Strukturen. Die kq_KeyCode-
                     Felder dieser Struktur sollten mit den Rawkey-Codes
                     gefüllt werden, die zu überprüfen sind. Nach der
                     Rückgabe aus dieser Funktion wird das Feld kq_Pressed
                     dieser Struktur auf TRUE gesetzt, wenn die zugehörige
                     Taste gedrückt ist und auf FALSE, wenn nicht.
    arraySize - Zahl der Tastaturcode-Einträge in queryArray

   SIEHE AUCH
    <libraries/lowlevel.h>


lowlevel.library/ReadJoyPort                     lowlevel.library/ReadJoyPort

   NAME
    ReadJoyPort -- Gibt den Zustand des ausgewählten Joy-/Maus-Ports
                       zurück. (V40)

   SYNOPSIS
    portState = ReadJoyPort(portNumber);
    D0                      D0

    ULONG ReadJoyPort(ULONG);

   FUNKTION
        Diese Funktion wird verwendet um festzustellen, welches Gerät an
        den Joyport angeschlossen ist und wie der aktuelle Zustand der
        Einstellungen und Knöpfe ist. Der Anwender kann eine Maus, einen
        Spiel-Controller oder einen Joystick an den Port anschließen und
        die Funktion ermittelt dynamisch, welches Gerät verbunden ist und
        gibt den passend formatierten portState zurück.

        Um die Art des angeschlossenen Controllers zu ermitteln, taktet
        diese Funktion den Spiel-Controller und/oder übersetzt die
        Änderungen der Joyport-Daten. Gültige getaktete Daten vom Spiel-
        Controller werden sofort entschlüsselt. Um jedoch genau bestimmen
        zu können, ob eine Maus oder ein Joystick angeschlossen ist, sind
        mehrere Aufrufe dieser Funktion nötig, wobei gleichzeitig das Gerät
        am Joyport durch den Anwender zu bewegen ist.

        Diese Funktion läuft immer sofort ab.

        Dies ist eine eingleisige Funktion, die nicht in das normale
        Multitasking-Modell des Amiga passt. Nur ein Auftrag (task) kann
        jeweils diese Routine ausführen. Alle anderen werden sofort mit
        JP_TYPE_NOTAVAIL zurückgegeben.

        Die Beschaffenheit dieser Routine soll nicht zu Multitasking-
        unfreundlichen Programmierungs-Praktiken wie Abfrageschleifen
        ermutigen. Wenn der Auftrag auf die Rückgabe eines Übergangs
        wartet, sollte WaitTOF() zwischen den Aufrufen verwendet werden,
        um den Einfluss auf das System möglichst klein zu halten.

        Wenn diese Funktion für einen Port zum ersten Mal aufgerufen wird,
        versucht sie bestimmte System-Resourcen zu übernehmen. Um diese
        Resourcen zu bekommen, MUSS die Funktion aus einer Task oder aus
        einem DOS-Prozess heraus aufgerufen sein. Wenn die Funktion die
        notwendigen Resourcen nicht erhält, endet sie mit der Rückgabe
        JP_TYPE_NOTAVAIL. Sobald die Resourcen übernommen sind (Rückgabewert
        anders als JP_TYPE_NOTAVAIL), kann diese Funktion in Interrupts
        verwendet werden.

   EINGABEN
    portNumber - port to read, in the range 0 to 3.

   RÜCKGABE
    portState - Bitmap, die das Gerät und seinen aktuellen Zustand
                    kennzeichnet. Das Format der Bitmap hängt von dem
                    Typ des angeschlossenen Geräts ab.

                    Die folgenden Konstanten aus <libraries/lowlevel.h>
                    werden verwendet, um das angeschlossenen Gerät und
                    dessen Zustand zu bestimmen.

                    Der Typ des Geräts kann dadurch ermittelt werden,
                    dass die Maske JP_TYPE_MASK auf den Rückgabewert
                    angewendet wird und das Ergebnis mit dem Folgenden
                    verglichen wird:

                    JP_TYPE_NOTAVAIL        Portdaten nicht vorhanden
                    JP_TYPE_GAMECTLR        Spiel-Controller
                    JP_TYPE_MOUSE           Maus
                    JP_TYPE_JOYSTK          Joystick
                    JP_TYPE_UNKNOWN         unbekanntes Gerät

                Wenn Typ = JP_TYPE_GAMECTLR, ist die Bitmap von portState:
                    JPF_BUTTON_BLUE         Blau - Stop (Blue - Stop)
                    JPF_BUTTON_RED          Rot - Auswahl (Red - Select)
                    JPF_BUTTON_YELLOW       Gelb - Wiederholung 
                                                (Yellow - Repeat)
                    JPF_BUTTON_GREEN        Grün - Mischen 
                                                (Green - Shuffle)
                    JPF_BUTTON_FORWARD      Tiefschwarz - Vorwärts
                                                (Charcoal - Forward)
                    JPF_BUTTON_REVERSE      Tiefschwarz - Rückwärts
                                                (Charcoal - Reverse)
                    JPF_BUTTON_PLAY         Grau - Spiel/Pause
                                                (Grey - Play/Pause)
                    JPF_JOY_UP              Auf (Up)
                    JPF_JOY_DOWN            Ab (Down)
                    JPF_JOY_LEFT            Links (Left)
                    JPF_JOY_RIGHT           Rechts (Right)

                Wenn Typ = JP_TYPE_JOYSTK, ist die Bitmap von portState:
                    JPF_BUTTON_BLUE         Rechts (Right)
                    JPF_BUTTON_RED          Feuer (Fire)
                    JPF_JOY_UP              Auf (Up)
                    JPF_JOY_DOWN            Ab (Down)
                    JPF_JOY_LEFT            Links (Left)
                    JPF_JOY_RIGHT           Rechts (Right)

                Wenn Typ = JP_TYPE_MOUSE, ist die Bitmap von portState:
                    JPF_BUTTON_BLUE         Rechte Maustaste (Right mouse)
                    JPF_BUTTON_RED          Linke Maustaste (Left mouse)
                    JPF_BUTTON_PLAY         Mittlere Maustaste
                                                (Middle mouse)
                    JP_MVERT_MASK           Maske für vertikalen Zähler
                    JP_MHORZ_MASK           Maske für horizontalen Zähler

   SIEHE AUCH
    SetJoyPortAttrs()


lowlevel.library/RemKBInt                           lowlevel.library/RemKBInt

  NAME
    RemKBInt -- Entfernen eines vorher eingerichteten
                    Keyboard-Interrupts. (V40)

  SYNOPSIS
    RemKBInt(intHandle);
             A1

    VOID RemKBInt(APTR);

  FUNKTION
        Entfernen einer Keyboard-Interrupt-Routine, die vorher mit
        AddKBInt() eingerichtet worden war.

  EINGABEN
    intHandle - Kennung (handle), die mit AddKBInt() übergeben worden
                    war. Sie kann NULL sein, in diesem Falle tut die
                    Funktion garnichts.

  SIEHE AUCH
    AddKBInt()


lowlevel.library/RemTimerInt                     lowlevel.library/RemTimerInt

   NAME
    RemTimerInt -- Entfernen eines vorher eingerichteten
                       Timer-Interrupts. (V40)

   SYNOPSIS
    RemTimerInt(intHandle);
                A1

    VOID RemTimerInt(APTR);

   FUNKTION
        Entfernen einer Timer-Interrupt-Routine, die vorher mit AddTimerInt
        eingerichtet worden war.

   EINGABEN
    intHandle - Kennung (handle), die mit AddTimerInt() übergeben
                    worden war. Sie kann NULL sein, in diesem Falle tut die
                    Funktion garnichts.

   SIEHE AUCH
    AddTimerInt(), StopTimerInt(), StartTimerInt()


lowlevel.library/RemVBlankInt                   lowlevel.library/RemVBlankInt

   NAME
    RemVBlankInt -- Entfernen einer vorher eingerichteten Routine
                        für die vertikale Austastlücke (vertical blank).
            (V40)

   SYNOPSIS
    RemVBlankInt(intHandle);
             A1

    VOID RemVBlankInt(APTR);

   FUNKTION
        Entfernen einer Routine für die vertikale Austastlücke (vertical
        blank), die vorher mit AddVBlankInt() zugefügt worden war.

   EINGABEN
    intHandle - Kennung (handle), die mit AddVBlankInt() übergeben
                    worden war. Sie kann NULL sein, in diesem Falle tut die
                    Funktion garnichts.

   SIEHE AUCH
    AddVBlankInt()


lowlevel.library/SetJoyPortAttrsA           lowlevel.library/SetJoyPortAttrsA

   NAME
    SetJoyPortAttrsA -- Änderung der Attribute eines Ports.  (V40.27)
    SetJoyPortAttrs -- Anhang für Variablen-Argumente (varargs stub)
                           für SetJoyPortAttrsA().  (V40.27)

   SYNOPSIS
    success = SetJoyPortAttrsA(portNumber, tagList);
    D0                         D0          A1

    BOOL SetJoyPortAttrsA(ULONG, struct TagItem *);

    Success = SetJoyPortAttrs(portNumber, firstTag, ...);

    BOOL SetJoyPortAttrs(Tag, ...);


   FUNKTION
        Diese Funktion ermöglicht die Veränderung einiger Attribute, die
        in ReadJoyPort() sowohl über die Operation wie auch über den
        Typ des Controllers des Geräts, das zur Zeit im Port eingesteckt
        ist.

        ReadJoyPort() verhält sich grundsätzlich so, dass es automatisch
        den Typ des Controllers festzustellen versucht, der in einem der
        vorhandenen Ports eingesteckt ist, wenn es diesen Port auslesen
        soll. Dieses Verhalten ist vorteilhaft und erlaubt eine einfache
        Bestimmung des Controllertyps, der an dem Port angeschlossen ist.
        Leider sind seltene Fälle möglich, bei denen extrem feine Bewegungen
        mit der Maus als Joystick-Bewegungen gedeutet werden. Außerdem
        dauern durch diese Fähigkeit zur automatischen Ermittlung des
        Controllertyps die meisten Ablesungen länger, als wenn keine
        automatische Prüfung vorhanden wäre.

        SetJoyPortAttrs() soll für diese beiden Fälle Vorsorge treffen.
        Es gestattet dem Programmierer ReadJoyPort() zu veranlassen,
        die Prüfung auf den verwendeten Controllertyp abzubrechen --
        und, wahlweise, ReadJoyPort() zu zwingen, einen bestimmten
        Controllertyp zu verwenden.

   EINGABEN
    portNumber - Der fragliche Joyport (0-3).
    tagList - Ein Zeiger auf ein Array von Kennunzeichen (tags), die
                  Parameter für SetJoyPortAttrs() enthalten; wenn NULL,
                  gibt die Funktion TRUE zurück, aber tut nichts weiter.

   TAGS
    SJA_Type (ULONG) - Setzt den aktuellen Controllertyp auf Maus,
                        Joystick oder Game-Controller. Eines der
                        folgenden ist anzugeben: SJA_TYPE_GAMECTLR,
                        SJA_TYPE_MOUSE, SJA_TYPE_JOYSTK oder
                        SJA_TYPE_AUTOSENSE. Wenn SJA_TYPE_AUTOSENSE
                        verwendet wird, versucht ReadJoyPort() den Typ
                        des am Port angeschlossenen Controller automatisch
                        zu ermitteln. Wenn einer der anderen Typen benutzt
                        wird, versucht ReadJoyPort() nicht, den angegebenen
                        Controller als etwas anderes zu lesen. Der
                        vorgegebene Typ der Einstellungen ist SJA_AUTOSENSE.

                        Anmerkung: Wenn der Typ auf etwas anderes als
                        automatische Prüfung gesetzt ist, liegt es in der
                        Verantwortung des Programmierers, ihn vor dem
                        Beenden auf automatische Prüfung zurück zu stellen. 

    SJA_Reinitialize (VOID) - Stellt einen bestimmten Port auf seinen
                        Initialisierungszustand zurück und erzwingt die
                        Freigabe aller übernommenen Resourcen; der Typ wird
                        auf SJA_TYPE_AUTOSENSE zurückgesetzt.

   RÜCKGABE
    success - TRUE, wenn alles nach Plan verlief, oder FALSE bei Fehler.

   SIEHE AUCH
    ReadJoyPort(), <libraries/lowlevel.h>


lowlevel.library/StartTimerInt                 lowlevel.library/StartTimerInt

   NAME
    StartTimerInt -- Startet den Timer, der mit dem Timer-Interrupt
                         verbunden ist. (V40)

   SYNOPSIS
    StartTimerInt(intHandle, timeInterval, continuous);
                  A1         D0            D1

    VOID StartTimerInt(APTR, ULONG, BOOL);

   FUNKTION
    Diese Routine startet einen angehaltenen Timer, der zu einem
        Timer-Interrupt gehört, der mit AddTimerInt() erzeugt wurde.

   EINGABEN
    intHandle - Kennung (handle), die von AddTimerInt() übergeben wurde.
    timeInterval - Zahl der Mikrosekunden zwischen den Interrupts. Der
                       zugelassene Höchstwert beträgt 90 000. Werden höhere
                       Werte übergeben, kann es zu unerwarteten Ergebnissen
                       kommen.
    continuous - FALSE bei einem Einmal-Interrupt. TRUE bei Mehrfach-
                 Interrupts.

   SIEHE AUCH
    AddTimerInt(), RemTimerInt(), StopTimerInt()


lowlevel.library/StopTimerInt                   lowlevel.library/StopTimerInt

   NAME
    StopTimerInt -- Hält den Timer an, der zum Timer-Interrupt gehört.
            (V40)

   SYNOPSIS
    StopTimerInt(intHandle);
                 A1

    VOID StopTimerInt(APTR);

   FUNKTION
        Hält den Timer an, dessen Timer-Interrupt-Kennung (handle) übergeben
        wurde. Damit wird ein Dauer-Timer angehalten, der mit StartTimerInt()
        gestartet wurde.

   EINGABEN
    intHandle - Kennung (handle), die von AddTimerInt() übergeben wurde.

   SIEHE AUCH
    AddTimerInt(), RemTimerInt(), StartTimerInt()


lowlevel.library/SystemControlA               lowlevel.library/SystemControlA

   NAME
    SystemControlA - Methode, um selektiv OS-Eigenschaften
                         abzuschalten. (V40)
    SystemControl - Variablen-Argumente (varargs stub) für
                        SystemControlA().

   SYNOPSIS
    failTag = SystemControlA(tagList);
    D0                       A1

    ULONG SystemControlA(struct TagItem *);

    failTag = SystemControl(firstTag, ...);

    ULONG SystemControl(Tag, ...);

   FUNKTION
        Diese Funktion wird verwendet, um die Möglichkeiten des Systems
        zu verändern. Einige dieser Änderungen umfassen Kontrollen von dem,
        was üblicherweise als System-Resourcen angesehen wird. Um
        Verwechslungen zu vermeiden, darf nur ein Prozess irgend einen
        Teil der System-Resourcen beeinflussen. Dadurch wird verhindert,
        dass möglicherweise zwei Prozesse sich streiten, wobei jeder einen
        Teil des Systems haben will. Wenn ein Kennzeichen (tag) als
        ausschließlich (exclusive) markiert ist, bedeutet das, dass nur
        ein Prozess dieses Kennzeichen (tag) übernehmen (auf TRUE setzen)
        kann. Wenn ein anderer Prozess versucht das gleiche Kennzeichen auf
        TRUE zu setzen, misslingt der Aufruf von SystemControl().

        Es ist wichtig daran zu denken, dass SystemControl() fehlschlagen
        kann.

        Dieses ist eine Low-Level-Funktion und bestimmte Kennzeichen
        passen nicht in das übliche Amiga-Multitasking-Modell.

   EINGABEN
    tagList - Zeiger auf ein Array von Kennzeichen (tags), die die
                  ein/auszuschaltenden Eigenschaften des Systems auflisten.

   TAGS
    SCON_TakeOverSys (BOOL)
        TRUE -    Übernimmt die CPU, um sicher zu stellen, dass ein
                        Programm jede Kleinigeit an CPU-Zeit (mit Ausnahme
                        von kritischen Interrupts) bekommt. In diesem
                        Modus gehört die CPU vollständig dem Programm.
                        Prozessumschaltung ist nicht möglich und das Programm
                        erhält die gesamte CPU-Bandbreite. Damit werden alle
                        Aufrufe an das OS, die irgendwie mit Multitasking
                        zu tun haben, nicht richtig ausgeführt werden.
                        Andere Prozesse laufen nicht, bis dieses Kennzeichen
                        mit FALSE aufgerufen wird. Allerdings wird während
                        eines Wait() auf ein Signal Multitasking automatisch
                        wieder eingeschaltet, bis das Signal empfangen wird.
                        Danach wird Multitasking wieder ausgeschaltet und
                        die CPU gehört wieder auschließlich dem eigenen
                        Programm.

                FALSE - Gibt die CPU frei und gestattet wieder Multitasking.
                        Dieses Kennzeichen ist Prozess-exklusiv. Das
                        Kennzeichen arbeitet verschachtelt. Ein Prozess
                        kann die CPU mehrfach übernehmen, ehe sie sie
                        wieder frei gibt.

    SCON_KillReq (BOOL)
            TRUE - Schaltet Systemrequester ab. Das sind die Gründe, die
                       Systemrequester NICHT abzuschalten:

                            1- Keine Aufrufe im Programm verursachen einen
                               Systemrequester.
                            2- Das Einzige, was einen Requester aufrufen
                               könnte, ist eine fehlende CD im Laufwerk,
                               wenn SCON_CDReboot auf CDReboot_On gesetzt
                               ist, deshalb kann ein Requester nicht
                               erscheinen.
                            3- Die einzige Disk-I/O ist über eine CD, wenn
                               SCON_CDReboot auf CDReboot_On gestellt ist
                               und/oder nonvolatile.library.

                       Wann Requester nicht ausgeschaltet werden sollten:

                       SPIELPROGRAMME:
                       Nach dem Laden werden keine DOS-Aufrufe ausgeführt;
                       oder SCON_CDReboot ist CDReboot_On; und zum Laden und
                       Speichern von Anwenderdaten wird die nonvolatile.library
                       verwendet.

                       Das passt zu den oben genannten Fällen: Nach dem Laden
                       werden DOS-Aufrufe nicht benützt aus Grund 1 oder das
                       Spiel greift auf die CD zu und SCON_CDReboot ist auf
                       CDReboot_On gesetzt passend zu Grund 2. Das Spiel
                       übernimmt Hiscores, Spieleinstellungen usw. über die
                       nonvolatile.library entsprechend Grund 3.

               FALSE - Erlaubt Requester für das Programm.

               Dieses Kennzeichen arbeitet verschachtelt. Prozesse können
               Requester mehrfach ausschalten, bevor sie wieder
               eingeschaltet werden. Dazu gehört jedoch eine passende
               Zahl von Aufrufen.

    SCON_CDReboot (ULONG)
                CDReboot_On - Auswerfen der Cd verursacht einen Reboot des
                        Systems. Dies ist nur zu verwenden, wenn das Programm
                        nicht mit Fehlerzuständen umgehen kann.
                CDReboot_Off - Auswerfen der CD verursacht keinen Reboot
                        des Systems. Dies ist anzuwenden, wenn während des
                        Programmlaufs CDs eingelegt werden müssen.
                CDReboot_Default - Setzt auf die Standardeinstellung des
                        Systems zurück. Das sollte am Ende verwendet werden,
                        wenn dieses Kennzeichen (tag) verwendet wurde, um das
                        Reboot-Verhalten zu verändern. Für CD32 ist dieser
                        Wert gleichwertig mit CDReboot_On. Für Amiga-Computer
                        ist der Wert gleichwertig mit CDReboot_Off.

            Es ist zu berücksichtigen, dass das Standardverhalten beim
            Reboot von der Plattform abhängt. Wenn ein Programm ein
            bestimmtes Verhalten erfordert, muss es diese Funktion
            verwenden, um das Verhalten einzustellen. Ein Audiomixer
            würde z.B. dieses Kennzeichen mit den Daten CDReboot_Off
            verwenden. Das erlaubt den Wechsel von Audio-CDs sowohl auf
            Spiel-Maschinen wie auch auf Amiga-Computern.

            Wenn jedoch überhaupt kein Code zur Fehlererkennung vorhanden
            ist, sollte dieses Kennzeichen mit den Daten CDReboot_On
            verwendet werden.

            Hoffentlich wird kein Programm jemals CDReboot_On benötigen.
            Wenn alle Programme die Fehlerbedingungen prüfen und so einen
            Aufruf benutzerfreundlich erledigen, sollte dieser Befehl nie
            notwendig sein. Mit seinem Standardverhalten wird der CD32 bei
            CD-Auswurf immer einen Reset ausführen und Programme, die auf
            Amiga-Computern laufen, machen keinen Reset. Durch Beibehalten
            des Standardverhaltens vergrößert sich der Markt für ein
            Programm auf beide Plattformtypen.
            
            Dieses Kennzeichen kann nicht verschachtelt werden.

    SCON_StopInput (BOOL) - Wenn TRUE, wird input.device davon
            abgehalten, CPU-Zeit zu verwenden. Ebenso kann das input.device
            weder Eingaben von der Tastatur noch vom Port 0 weiterleiten.
            
            Dieses Kennzeichen ist exklusiv für den Prozess. Es kann nicht
            zurück gesetzt werden. Der Versuch des Rücksetzens führt zu
            unklaren/verzerrten Eingaben.

        SCON_AddCreateKeys (ULONG) - Beginnt mit der Erzeugung von Rawkey-
            Codes für Joystick/Game-Controller an der angegebenen Einheit
            (unit). Der Wert der Einheit wird auf Gültigkeit geprüft und
            muss entweder 0 oder 1 sein. Jede einzelne verwendete Einheit
            ergibt einen gewissen Code, der zur Interrupt-Kette des
            vertikalen Austastimpulses (VBlank interrupt chain) hinzu
            gefügt wird. Dieses Kennzeichen (tag) kann verschachtelt werden.
            Das Kennzeichen SCON_RemCreateKeys wird verwendet, um dieses
            Kennzeichen zurück zu setzen. Prozesse können mehrfach Rawkey-
            Codes erzeugen, ehe abgebrochen wird.

            Bei der Arbeit in einem Intuition-Fenster ist zu beachten, dass
            der blaue Knopf des Game-Controllers gleichwertig mit dem
            Menüknopf der Maus ist. Deshalb fängt Intuition die meisten
            Eingaben des blauen Knopfes ab. Wenn die Weitergabe dieses
            Ereignisses wichtig ist, ist die Nachprüfung in der
            Dokumentation für WFLG_RMBTRAP im Autodoc intuition.library/
            OpenWindow() empfohlen.

        SCON_RemCreateKeys (ULONG) - Beendet die Rawkey-Codes für Joystick/
            Game-Controller von der angegebenen Einheit (unit). Der Wert
            für die Einheit wird auf Gültigkeit geprüft und darf nur 0
            oder 1 sein

   RÜCKGABE
    failTag - Null, wenn alle  Kennzeichen (tags) erfolgreich waren.
                  Ein Rückgabe anders als Null zeigt ein Kennzeichen an,
                  dass misslungen ist. Es ist dann möglich, dass auch
                  andere Kennzeichen misslungen sind.

                  Wenn irgend ein Kennzeichen versagt, ändert sich das
                  System nicht durch andere Kennzeichen.

   SIEHE AUCH
    <libraries/lowlevel.h>


@ENDNODE


@NODE "Workshop3" "NonVolatile"
@TOC "MAIN"
@font helvetica.font 13


@{b}@{u}NonVolatile@{ub}@{uu}


Inhaltsverzeichnis

nonvolatile.library/--Hintergrund--
nonvolatile.library/DeleteNV
nonvolatile.library/FreeNVData
nonvolatile.library/GetCopyNV
nonvolatile.library/GetNVInfo
nonvolatile.library/GetNVList
nonvolatile.library/SetNVProtection
nonvolatile.library/StoreNV


nonvolatile.library/--Hintergrund--         nonvolatile.library/--Hintergrund--

   ZWECK
        Die nonvolatile.library bietet dem Entwickler von Anwendungen
        einfache Mittel, um nichtflüchtige (nonvolatile) Speicherung zu
        handhaben.

   ÜBERBLICK
        Die nonvolatile.library kann transparent über alle Konfigurationen
        hinweg benutzt werden. Derzeit kann nichtflüchtige Speicherung
        in NVRAM und/oder auf Disk-Geräten erfolgen. Die nonvolatile.library
        greift automatisch auf die beste Speichermöglichkeit zu, die das
        System bietet. Zunächst wird auf Disk-Medien basierende Speicherung
        ausgewählt und wenn diese nicht zur Verfügung steht, wird auf NVRAM-
        Speicherung zurückgegriffen. 

    * NVRAM

        Auf Amiga-Einstiegsgeräten ohne Diskettensystem kann NVRAM zur
        Verfügung stehen. Dieses RAM behält seinen Dateninhalt bei, auch
        wenn das System abgeschaltet wird. Das geschieht unabhängig davon,
        ob Batterien oder Batterie-gestützte Uhren vorhanden sind. Die im
        NVRAM gespeicherten Daten sind nur über die im ROM untergebrachten
        Funktionsaufrufe der nonvolatile.library zugänglich. Die Größe des
        NVRAM-Speichers hängt von der System-Plattform ab und kann durch die
        Funktion GetNVInfo() ermittelt werden.

    * Disk

        Um die allgemeinen Möglichkeiten zur Konfiguration des Amiga
        beibehalten zu können, kann die aktuell Disk-Position, die von der
        nonvolatile.library zum Speichern benützt wird, durch den Anwender
        verändert werden.

        Auf dem Amiga wird das Verzeichnis "prefs" zur Speicherung vieler
        vom Benutzer einstellbarer Möglichkeiten verwendet. Der Platz auf dem
        Plattenspeicher für die nichtflüchtige Speicherung ist in der Datei
        "prefs/env-archive/sys/nv_location" angegeben. Diese Datei sollte
        eine Zeichenkette enthalten, die einen festlegbaren (lockable) Ort
        (Dateipfad) angibt. Wenn die Zeichenkette keinen ansprechbaren Ort
        angibt, wird die Datei ignoriert.

        Wenn die nonvolatile.library geöffnet wird, sucht sie alle Laufwerke
        des Systems ab, bis sie diese Datei findet und und erfolgreich eine
        Verbindung mit dem Ort, der darin angegeben ist, herstellt. Um eine
        erneute Suche in allen Laufwerken zu erzwingen, kann die Library
        geschlossen und wieder geöffnet werden oder es muss die Funktion
        GetNVInfo() ausgeführt werden.

        Eine einfache Methode zur Erstellung einer Diskette zur Speicherung
        nichtflüchtiger Daten ist folgende:
        
        Formatieren einer Diskette mit dem Namen "NV".
        Erzeugen eines Pfades "prefs/env-archive/sys/nv_location", wobei die
        Datei "nv_location" folgendes enthält: "NV:nonvolatile".
        Erzeugen eines Verzeichnisses mit dem Namen "nonvolatile".

        Das folgende Script kann zur Herstellung einer Diskette zur Verwendung
        mit der nonvolatile.library benutzt werden:

    .KEY DRIVE/A,DISK
    .BRA {
    .KET }
    format Drive {DRIVE} Name {DISK$NV} noicons ffs
    makedir {DRIVE}prefs
    makedir {DRIVE}nonvolatile
    makedir {DRIVE}prefs/env-archive
    makedir {DRIVE}prefs/env-archive/sys
    echo {DISK$NV}:nonvolatile >{DRIVE}prefs/env-archive/sys/nv_location

    !!!Anmerkung!!!

        Da NVRAM einen Disk-Zugriff ausführt, muss seine Funktionalität
        von einem DOS-Prozess aus geöffnet und angewendet werden, nicht
        von einem EXEC-Auftrag (task). Normalerweise wird eine CDGS-Anwendung
        als DOS-Prozess aufgerufen, deshalb sollte diese Forderung kein
        Problem darstellen. Man muss nur diese Forderung beachten, wenn ein
        EXEC-Vorgang erzeugt wird und daraus die nonvolatile.library
        aufgerufen werden soll.


nonvolatile.library/DeleteNV                     nonvolatile.library/DeleteNV

   NAME
    DeleteNV -- Entfernen eines Eintrags aus dem nichtflüchtigen
                    (nonvoltatile) Speicher. (V40)

   SYNOPSIS
    success = DeleteNV(appName, itemName, killRequesters);
    D0           A0        A1          D1

    BOOL DeleteNV(STRPTR, STRPTR, BOOL);

   FUNKTION
        Sucht im nichtflüchtigen Speicher nach dem angegebenen Eintrag und
        entfernt ihn.

        Die Zeichenketten appName und itemName dürfen die Zeichen '/' oder ':'
        nicht enthalten. Es wird empfohlen diese Zeichen abzublocken, wenn
        vom Anwender Eingaben in die Zeichenketten AppName and ItemName
        angefordert werden.

   EINGABEN
        appName - Mit NULL terminierte Zeichenkette, die die Anwendung
                  identifiziert, welche die Daten erzeugt hat. Maximale
                  Länge ist 31.
        ItemName - Mit NULL terminierter Zeichensatz, der eindeutig die
                   Daten in der Anwendung kennzeichnet. Maximale Länge
                   ist 31.
        killRequesters - Flag zum Unterdrücken der System-Requester.
                         TRUE bedeutet, dass alle System-Requester
                         während dieser Funktion zu unterdrücken sind,
                         FALSE bedeutet, dass System-Requester zugelassen
                         sind.

   RÜCKGABE
    success - TRUE wird zurückgegeben, wenn der Eintrag gefunden und
                  gelöscht wurde. Wurde der Eintrag nicht gefunden, wird
                  FALSE zurückgegeben.


nonvolatile.library/FreeNVData                 nonvolatile.library/FreeNVData

   NAME
    FreeNVData -- Gibt den Speicher frei, der von einer Funktion dieser
                      Library belegt wurde. (V40)

   SYNOPSIS
    FreeNVData(data);
           A0

    VOID FreeNVData(APTR);

   FUNKTION
        Gibt einen Speicherblock frei, der durch einer der folgenden
        Funktionen belegt wurde:
    GetCopyNV(), GetNVInfo(), GetNVList().

   EINGABEN
    data - Zeiger auf den Speicherblock, der frei gegeben werden soll.
               Wenn NULL übergeben wird, passiert garnichts.

   SIEHE AUCH
    GetCopyNV(), GetNVInfo(), GetNVList()


nonvolatile.library/GetCopyNV                   nonvolatile.library/GetCopyNV

   NAME
    GetCopyNV -- Gibt eine Kopie eines Elementes zurück, das im
                     nichtflüchtigen Speicher abgelegt ist. (V40)

   SYNOPSIS
    data = GetCopyNV(appName, itemName, killRequesters);
    D0         A0      A1        D1

    APTR GetCopyNV(STRPTR, STRPTR, BOOL);

   FUNKTION
        Durchsucht den nichtflüchtigen Speicher nach dem angegebenen
        appName und itemName. Ein Zeiger auf eine Kopie dieser Daten
        wird zurück gegeben.

        Die Zeichenketten appName und itemName dürfen die Zeichen '/' oder
        ':' nicht enthalten. Es wird empfohlen diese Zeichen abzublocken,
        wenn vom Anwender Eingaben in die Zeichenketten appName and itemName
        angefordert werden.

   EINGABEN
        appName - Mit NULL terminierte Zeichenkette, die den Namen der
                  Anwendung enthält, die gesucht wird. Maximale Länge ist 31.
        itemName - Mit NULL terminierter Zeichensatz, der eindeutig den
                   Eintrag in der gesuchten Anwendung kennzeichnet.
                   Maximale Länge ist 31.
        killRequesters - Flag zum Unterdrücken der System-Requester. TRUE
                         bedeutet, dass alle System-Requester während dieser
                         Funktion zu unterdrücken sind, FALSE bedeutet, dass
                         System-Requester zugelassen sind.
 
   RÜCKGABE
    data - Zeiger auf eine Kopie der Daten, die im nichtflüchtigen
               Speicher in Verbindung mit appName and itemName gefunden
               wurden. NULL wird zurück gegeben, wenn zu wenig Speicher
               vorhanden ist oder appName/itemName nicht existieren.

   SIEHE AUCH
    FreeNVData(), <libraries/nonvolatile.h>


nonvolatile.library/GetNVInfo                   nonvolatile.library/GetNVInfo

   NAME
    GetNVInfo -- Informationen über den aktuellen nichtflüchtigen
                     Speicher. (V40)

   SYNOPSIS
    information = GetNVInfo(killRequesters);
    D0            D1

    struct NVInfo *GetNVInfo(BOOL);

   FUNKTION
        Findet das vom Anwender bevorzugte nichtflüchtige Gerät (nonvolatile
        device) und gibt Informationen darüber aus.

   EINGABEN
    killRequesters - Flag zum Unterdrücken der System-Requester. TRUE
                         bedeutet, dass alle System-Requester während dieser
                         Funktion zu unterdrücken sind, FALSE bedeutet, dass
                         System-Requester zugelassen sind.

   RÜCKGABE
    information - Zeiger auf eine NVInfo-Struktur. Diese Struktur enthält
                      Informationen über das NV-Speicher-Medium mit dem
                      größten Speicher. Die Struktur enhält zwei Langwort-
                      Felder: nvi_MaxStorage und nvi_FreeStorage. Beide Werte
                      sind auf die nächst niedrige Zehnerzahl abgerundet. Das
                      Feld nvi_MaxStorage ist definiert als die Gesamtmenge
                      an nichtflüchtigem Speicher auf diesem Gerät.
                      nvi_FreeStorage ist definiert als der zur Verfügung
                      stehende Bereich für NVDISK oder die Menge an nicht
                      gebundenem (non-locked) Speicher für NVRAM. Für NVDISK
                      berücksichtigt nvi_FreeStorage die Menge an zusätzlichem
                      Platz, der zum Speichern von neuen App/Items benötigt
                      wird. Diese Menge beträgt 3 Blöcke, um Platz zu bieten
                      zum Speichern einer neuen Datei mit Einträgen (items)
                      und möglicherweise eines neuen App-Verzeichnisses. Für
                      NVRAM ist die Zusatzmenge 5 Bytes. Jedoch hängt der
                      benötigte Platz zur Speicherung eines neuen NVRAM-
                      Eintrags von der Länge der App- und Eintrags-Namen ab.
                      Wegen Einzelheiten der Speicherung ist die Funktion
                      StoreNV() zu beachten.

                      Diese Funktion gibt im Fehlerfall NULL zurück.
 
   SIEHE AUCH
    FreeNVData(), StoreNV(), <libraries/nonvolatile.h>


nonvolatile.library/GetNVList                   nonvolatile.library/GetNVList

   NAME
    GetNVList -- Gibt eine Liste der im nichtflüchtigen Speicher
                     abgelegten Einträge zurück. (V40)

   SYNOPSIS
    list = GetNVList(appName, killRequesters);
    D0         A0      D1

    struct MinList *GetNVList(STRPTR, BOOL);

   FUNKTION
        Gibt einen Zeiger auf eine EXEC-Liste mit nichtflüchtigen
        Einträgen zurück, die mit dem angegebenen appName zusammenhängen.

        Die Zeichenkette appName darf die Zeichen '/' oder ':' nicht
        enthalten. Es wird empfohlen diese Zeichen abzublocken, wenn
        vom Anwender Eingaben in die Zeichenkette appName angefordert
        werden.

   EINGABEN
    appName - NULL-terminierte Zeichenkette, die den Namen der Anwendung
                  enthält, der gesucht wird. Maximale Länge ist 31.
    killRequesters - Flag zum Unterdrücken der System-Requester. TRUE
                         bedeutet, dass alle System-Requester während dieser
                         Funktion zu unterdrücken sind, FALSE bedeutet, dass
                         System-Requester zugelassen sind.

   RÜCKGABE
    list - Ein Zeiger auf eine Exec-MinList mit NV-Einträgen. Eine
               NULL wird zurückgegeben, wenn zu wenig Speicher vorhanden
               ist. Wenn für den appName keine Einträge im nichtflüchtigen
               Speicher vorhanden sind, wird eine leere Liste zurück gegeben.

   ANMERKUNG
        Das Feld für Markierungsbits (protection field) enthält mehr Bits,
        als für die Speicherung des Löschschutz-Status erforderlich sind.
        Diese Bits sind reserviert für ander Systemanwendungen und sind
        möglicher Weise nicht Null. Wenn auf den Lösch-Status geprüft
        werden soll, ist entweder die Feld-Maske NVIF_DELETE oder die
        Bit-Definition NVIB_DELETE zu verwenden.

   SIEHE AUCH
    FreeNVData(), SetNVProtection()


nonvolatile.library/SetNVProtection       nonvolatile.library/SetNVProtection

   NAME
    SetNVProtection -- Setzen der Schutz-(protection)-Flags. (V40)

   SYNOPSIS
    success = SetNVProtection(appName, itemName, mask, killRequesters);
    D0              A0       A1         D2    D1

    BOOL SetNVProtection(STRPTR, STRPTR, LONG, BOOL);

   FUNKTION
        Setzt die Schutz-(protection)-Attribute für einen Eintrag im
        nichtflüchtigen Speicher.

        Obwohl 'mask' LONG ist, kann nur das Löschschutz-Bit
        NVEF_DELETE/NVEB_DELETE gesetzt werden. Wenn irgend ein anderes
        Bit gesetzt wird, gibt die Funktion FALSE zurück.

        Die Zeichenketten appName und itemName dürfen die Zeichen '/' oder
        ':' nicht enthalten. Es wird empfohlen diese Zeichen abzublocken,
        wenn vom Anwender Eingaben in die Zeichenketten appName und
        itemName angefordert werden.

   EINGABEN
        appName - Mit NULL terminierte Zeichenkette, die den Namen der
                  Anwendung enthält, die gesucht wird. Maximale Länge
                  ist 31.
        itemName - Mit NULL terminierter Zeichensatz, der eindeutig den
                   Eintrag in der gesuchten Anwendung kennzeichnet.
                   Maximale Länge ist 31.
        mask - Die neue Schutzbit-Maske. Nur das Lösch-Bit darf gesetzt
               werden, sonst ERZEUGT diese Funktion einen CRASH.
        killRequesters - Flag zum Unterdrücken der System-Requester.
                         TRUE bedeutet, dass alle System-Requester während
                         dieser Funktion zu unterdrücken sind, FALSE
                         bedeutet, dass System-Requester zugelassen sind.

   RÜCKGABE
    success - FALSE, wenn das Schutzbit nicht verändert werden konnte
                  (d.h. die Daten existieren nicht).

   SIEHE AUCH
    GetNVList(), <libraries/nonvolatile.h>


nonvolatile.library/StoreNV                       nonvolatile.library/StoreNV

   NAME
    StoreNV --  Daten im nichtflüchtigen Speicher ablegen. (V40)

   SYNOPSIS
    error = StoreNV(appName, itemName, data, length, killRequesters);
    D0        A0     A1       A2    D0     D1

    UWORD StoreNV(STRPTR, STRPTR, APTR, ULONG, BOOL);

   FUNKTION
        Damit werden Daten im nichtflüchtigen Speicher gesichert. Die
        Daten sind durch appName und itemName markiert und können später
        zurück geholt werden. Ein einzelner Eintrag sollte in keinem
        Falle größer sein als ein Viertel des maximal zur Verfügung
        stehenden Platzes, der durch GetNVInfo() angezeigt wird.
        
        Mit dieser Funktion ist keine Daten-Kompression verbunden.
        
        Die Zeichenketten appName und itemName sollten kurz, aber klar
        bezeichnend sein. Die Kürze ist notwendig, weil die Zeichenkette
        mit den Daten gespeichert wird und der Bereich für nichtflüchtige
        Speicherung bei reinen Spielsystemen beschränkt ist. Das Spielsystem
        erlaubt dem Anwender, selektiv Einträge zu entfernen, deshalb muss
        die Zeichenkette deutlich beschreibend sein.

        Die Zeichenketten appName und itemName dürfen die Zeichen '/' oder
        ':' nicht enthalten. Es wird empfohlen diese Zeichen abzublocken,
        wenn vom Anwender Eingaben in die Zeichenketten appName und
        itemName angefordert werden.

   EINGABEN
        appName - Mit NULL terminierte Zeichenkette, die den Namen der
                  Anwendung enthält, die gesucht wird. Maximale Länge
                  ist 31.
        itemName - Mit NULL terminierter Zeichensatz, der eindeutig den
                   Eintrag in der gesuchten Anwendung kennzeichnet.
                   Maximale Länge ist 31.
        data - Zeiger auf den Speicherblock, der gesichert werden soll.
        length - Zahl der zu sichernden Bytes in Einheiten von je zehn Bytes.
                 Wenn z.B. 23 Bytes zu speichern sind, ist length = 3; bei
                 147 Bytes ist length = 15.
        killRequesters - Flag zum Unterdrücken der System-Requester. TRUE
                         bedeutet, dass alle System-Requester während dieser
                         Funktion zu unterdrücken sind, FALSE bedeutet, dass
                         System-Requester zugelassen sind.

   RÜCKGABE
    error - 0                Bedeutet kein Fehler,
            NVERR_BADNAME    Fehler in appName oder in itemName.
            NVERR_WRITEPROT  Nicht-flüchtiger Speicher "read only".
            NVERR_FAIL       Fehler beim Schreiben der Daten
                                 (nichtflüchtiger Speicher voll oder
                                 schreibgeschützt.
            NVERR_FATAL      Fataler Fehler beim Zugriff auf nicht-
                                 flüchtigen Speicher, Verlust vorher
                                 gespeicherter nichtflüchtiger Daten ist
                                 möglich.

   SIEHE AUCH
    GetCopyNV(), GetNVInfo()



@ENDNODE


@NODE "Workshop4" "cd"
@TOC "MAIN"
@font helvetica.font 13


@{b}@{u}CD@{ub}@{uu}



INHALTSVERZEICHNIS


cd.device/CD_ADDCHANGEINT
cd.device/CD_ADDFRAMEINT
cd.device/CD_ATTENUATE
cd.device/CD_CHANGENUM
cd.device/CD_CHANGESTATE
cd.device/CD_CONFIG
cd.device/CD_EJECT
cd.device/CD_GETGEOMETRY
cd.device/CD_INFO
cd.device/CD_MOTOR
cd.device/CD_PAUSE
cd.device/CD_PLAYLSN
cd.device/CD_PLAYMSF
cd.device/CD_PLAYTRACK
cd.device/CD_PROTSTATUS
cd.device/CD_QCODELSN
cd.device/CD_QCODEMSF
cd.device/CD_READ
cd.device/CD_READXL
cd.device/CD_REMCHANGEINT
cd.device/CD_REMFRAMEINT
cd.device/CD_SEARCH
cd.device/CD_SEEK
cd.device/CD_TOCLSN
cd.device/CD_TOCMSF
cd.device/CloseDevice
cd.device/OpenDevice



cd.device/CD_ADDCHANGEINT                           cd.device/CD_ADDCHANGEINT

   NAME
       CD_ADDCHANGEINT -- Richtet einen Software-Interrupt-Handler für
                          Disk-Wechsel ein.

   FUNKTION
       Mit diesem Befehl kann ein Software-Interrupt-Handler zum Disk-
       Device hinzu gefügt werden, der aufgerufen wird, wenn immer eine
       Disk eingelegt oder entnommen wird.

       Er muss in einer sorgfältig initialisierten Exec-Interruptstruktur
       übergeben werden und er muss darauf vorbereitet sein, unmittelbar
       auf Einlegen/Entnehmen einer Disk zu reagieren. Der Interrupt wird
       von der Exec-Funktion Cause erzeugt, deshalb muss A6 frei gehalten
       sein.

       Um den Handler aufzurufen, muss eine Interrupt-Struktur initialisiert
       werden. Diese Struktur wird als io_Data dem Befehl CD_ADDCHANGEINT
       übergeben. Danach wird der Handler in die Handler-Kette eingebunden
       und aufgerufen, wenn ein Disk-Wechsel vorkommt. Vor Verlassen des
       Programms muss der Handler entfernt werden.

       Dieser Befehl antwortet nur, wenn der Handler entfernt wird. Das
       heißt, das Device hält die IO-Anforderung aufrecht, bis der Befehl
       CD_REMCHANGEINT mit der gleichen IO-Anforderung ausgeführt wird.
       Deshalb muss SendIO() mit diesem Befehl verwendet werden.
 
   IO REQUEST EINGABE
       io_Device       wird voreingestellt durch den Aufruf von OpenDevice()
       io_Unit         wird voreingestellt durch den Aufruf von OpenDevice()
       io_Command      CD_ADDCHANGEINT
       io_Length       Größe von (struct Interrupt)
       io_Data         Zeiger auf Interrupt-Struktur

   IO REQUEST RÜCKGABE
       io_Error - 0 bei Erfolg oder ein Fehlercode wie festgelegt in
                  <devices/cd.h>

   SIEHE AUCH
       CD_REMCHANGEINT, <devices/cd.h>, <exec/interrupts.h>,
       exec.library/Cause()


cd.device/CD_ADDFRAMEINT                             cd.device/CD_ADDFRAMEINT

   NAME
       CD_ADDFRAMEINT -- Richtet einen CD-Frame Software-Interrupt-Handler ein.

   IO REQUEST
       io_Device       wird voreingestellt durch den Aufruf von OpenDevice()
       io_Unit         wird voreingestellt durch den Aufruf von OpenDevice()
       io_Command      CD_ADDFRAMEINT
       io_Length       Größe von (struct Interrupt)
       io_Data         Zeiger auf Interrupt-Struktur

   RÜCKGABE
       io_Error        0 bei Erfolg oder ein Fehlercode wie festgelegt in
                       <devices/cd.h>

   FUNKTION
       Mit diesem Befehl kann eine Software-Interrupt-Handler zum Disk-
       Device hinzu gefügt werden, der aufgerufen wird, wenn immer ein
       neuer Frame erkannt wird, während CD-Audio abgespielt wird.

       Er muss in einer sorgfältig initialisierten Exec-Interruptstruktur
       übergeben werden und er muss darauf vorbereitet sein, unmittelbar
       einen Frame-Interrupt zu reagieren. Der Interrupt wird von der
       Exec-Funktion Cause erzeugt, deshalb muss A6 frei gehalten
       sein.

       Um den Handler aufzurufen, muss eine Interrupt-Struktur initialisiert
       werden. Diese Struktur wird als io_Data dem Befehl CD_ADDFRAMEINT
       übergeben. Danach wird der Handler in die Handler-Kette eingebunden
       und aufgerufen, wenn ein Frame-Ereignis vorkommt. Vor Verlassen des
       Programms muss der Handler entfernt werden.

       Dieser Befehl antwortet nur, wenn der Handler entfernt wird. Das
       heißt, das Device hält die IO-Anforderung aufrecht, bis der Befehl
       CD_REMFRAMEINT mit der gleichen IO-Anforderung ausgeführt wird.
       Deshalb muss SendIO() mit diesem Befehl verwendet werden.

   ANMERKUNG
       Der Interrupt-Handler kann vor oder nach dem Senden eines Abspiel-
       Befehls hinzu gefügt werden. Interrupts werden nur erzeugt, während
       CD-Audio abgespielt wird. Interrupts werden nicht erzeugt, wenn
       Audio pausiert.

   SIEHE AUCH
       CD_REMFRAMEINT, <devices/cd.h>, <exec/interrupts.h>,
       exec.library/Cause()


cd.device/CD_ATTENUATE                                 cd.device/CD_ATTENUATE

   NAME
       CD_ATTENUATE -- Umblenden der CD-Audio-Lautstärke (sofort oder
                       allmählich)

   IO REQUEST
       io_Device       wird voreingestellt durch den Aufruf von OpenDevice()
       io_Unit         wird voreingestellt durch den Aufruf von OpenDevice()
       io_Command      CD_ATTENUATE
       io_Data         NULL
       io_Length       Dauer der Lautstärke-Umblendung in Frames
       io_Offset       Gewünschter Lautstärke-Pegel (0 - 0x7FFF)
                       (-1 = nur Status)

   RÜCKGABE
       io_Error        Gibt einen Fehler (error) zurück, wenn das Laufwerk
                       die Umblendung nicht unterstützt
       io_Actual       Gegenwärtiger Lautstärke-Pegel (Umblendung kann
                       überwacht werden)

   FUNKTION
       Dieser Befehl schiebt die CD-Audio-Lautstärke von ihrem aktuellen
       Wert nach oben oder nach unten zu dem Wert, der in io_Offset
       enthalten ist. Der mögliche Bereich ist 0 (Stille) bis 0x7FFF
       (höchste Lautstärke). Wenn als Ziel-Lautstärke -1 angegeben wurde,
       wird die Lautstärkeeinstellung nicht verändert; die aktuelle
       Einstellung wird in io_Actual zurückgegeben.

       io_Length enhält die Länge der Umblendung. Der Wert in Sekunden
       ergibt sich, wenn io_Length durch die laufende Frame-Geschwindigkeit
       (gewöhnlich 75) geteilt wird.

       Es ist zu beachten, dass dieser Befehl endet, ehe die Umblendung
       beendet ist. Deshalb kann ein Umblend-Vorgang nicht abgebrochen
       werden. Es kann jedoch ein neuer Befehl CD_ATTENUATE gesandt werden,
       der jegliche zu Zeit ablaufende Umblend-Anweisung aufhebt. Ein Wert
       von Null für io_Length bedeutet sofortige Lautstärke-Umschaltung.

       Wenn ein Befehl zur allmählichen Umblendung vor dem Abspiel-Befehl
       gesendet wurde, beginnt der Blendvorgang, sobald der Abspiel-Befehl
       aktiv ist.

   BEISPIEL

   ANMERKUNGEN
       Dieser Befehl hat keine Auswirkung auf die Lautstärke des Amiga,
       nur auf CD-Audio.

       Wenn das Laufwerk nicht Lautstärkeänderung, sondern Dämpfung (mute)
       unterstützt, sollte ein Wert kleiner als $0800 als Dämpfung angesehen
       werden, gleich oder größer sollte volle Lautstärke sein. Wenn
       stufenweise (chunky) Veränderung unterstützt wird, sollte das Laufwerk
       so gut wie möglich arbeiten. Wenn das Laufwerk überhaupt keine
       Veränderung der Lautstärke unterstützt, sollte ein Fehler zurück
       gegeben werden. Selbst wenn nur "mute" unterstützt wird, sollte bei
       Anforderung einer allmählichen Änderung das Gerät einen Befehl zur
       Umblendung emulieren und die Änderung mit Rücksicht auf die $0800-
       Grenze ausführen.

   BUGS

   SIEHE AUCH
       CD_INFO


cd.device/CD_CHANGENUM                                 cd.device/CD_CHANGENUM

   NAME
       CD_CHANGENUM -- gibt den derzeitigen Wert des Disk-Wechsel-Zählers
                       zurück.

   FUNKTION
       Dieser Befehl gibt den derzeitigen Wert des Disk-Wechsel-Zählers
       zurück. Der Disk-Wechsel-Zähler erhöht seinen Wert jedesmal um 1,
       wenn eine Disk in das CD-Laufwerk eingelegt oder aus ihm entnommen
       wird.

   IO REQUEST EINGABE
       io_Device       wird voreingestellt durch den Aufruf von OpenDevice()
       io_Unit         wird voreingestellt durch den Aufruf von OpenDevice()
       io_Command      CD_CHANGENUM

   IO REQUEST RÜCKGABE
       io_Error -  0 bei Erfolg oder ein Fehlercode wie festgelegt in
                   <devices/cd.h>
                  
       io_Actual - wenn io_Error 0 ist, enthält dieses den derzeitigen Wert
                   des Disk-Wechsel-Zählers.


cd.device/CD_CHANGESTATE                             cd.device/CD_CHANGESTATE

   NAME
       CD_CHANGESTATE -- prüfen, ob zur Zeit eine "gültige (valid)" Disk
                         im Laufwerk ist. 

   FUNKTION
       Dieser Befehl prüft, ob eine "gültige (valid)" Disk in einem
       Laufwerk ist.

   IO REQUEST EINGABE
       io_Device       wird voreingestellt durch den Aufruf von OpenDevice()
       io_Unit         wird voreingestellt durch den Aufruf von OpenDevice()
       io_Command      CD_CHANGESTATE

   IO REQUEST RÜCKGABE
       io_Error - 0 bei Erfolg oder ein Fehlercode wie festgelegt in
                  <devices/cd.h>
       io_Actual - 0 bedeutet, es ist eine Disk vorhanden, während alles andere
                   anzeigt, das keine Disk vorhanden ist.

   ANMERKUNGEN
       Eine "gültige (valid)" Disk ist eine mit einem lesbaren
       Inhaltsverzeichnis.


cd.device/CD_CONFIG                                       cd.device/CD_CONFIG

   NAME
       CD_CONFIG -- Laufwerks-Voreinstellungen

   IO REQUEST
       io_Device       wird voreingestellt durch den Aufruf von OpenDevice()
       io_Unit         wird voreingestellt durch den Aufruf von OpenDevice()
       io_Command      CD_CONFIG
       io_Data         Zeiger (pointer) auf den ersten Eintrag in der TagList
       io_Length       0

   RÜCKGABE
       io_Error        0 bei Erfolg oder ein Fehlercode wie festgelegt in
                       <devices/cd.h>

   FUNKTION
       Dieser Befehl stellt einen oder mehrere Konfigurationspunkte ein.
       Die Konfigurationspunkte sind:

       TAGCD_PLAYSPEED                 Vorgabewert: 75
       TAGCD_READSPEED                 Vorgabewert: 75 (ist nicht ganz sicher)
       TAGCD_READXLSPEED               Vorgabewert: 75
       TAGCD_SECTORSIZE                Vorgabewert: 2048
       TAGCD_XLECC                     Vorgabewert: 1 (an)
       TAGCD_EJECTRESET                Vorgabewert: 0 (aus) oder 1 (an) möglich 

       Die Geschwindigkeitseinstellungen (...SPEED) werden in der Zahl der
       Frames (Sektoren) je Sekunde angegeben. Alle CD-ROM-Laufwerke schaffen
       die Geschwindigkeit von 75 Frames/Sekunde. Manche Laufwerke können
       150 Frames/Sekunde, einige sogar noch mehr. Zur Ermittlung der höchsten
       Framezahl/Sekunde ist der Befehl CD_INFO zu verwenden. Gültige Werte
       für Commodore CD-ROM-Laufwerke ohne Caddy sind 75 und 150 (normale und
       doppelte Geschwindigkeit). Alle anderen Werte sind ungültig. Es sollte
       immer sicher gestellt werden, dass das Laufwerk die geforderte
       Konfiguration beherrscht, entweder durch die Verwendung des Befehls
       CD_INFO und/oder durch Prüfung auf eine Fehlerbedingung nach der
       Übergabe der Anforderung.

       Es gibt drei verschiedene Typen von CD-ROM-Sektoren. Mode 1 Sektoren
       (2048 Bytes), Mode 2 Form 1 Sektoren (2048 Bytes) und Mode 2 Form 2
       Sektoren (2328 Bytes). Normalerweise sind Disks im Format Mode 1
       codiert. Mode 2 Form 1 ist grundsätzlich das Gleiche wie Mode 1;
       jedoch enthält das Sektor-Format Mode 2 Form 2 keine Angaben für
       CD-ROM-Fehlerkorrektur. Um Informationen zu lesen, die in diesem
       Format codiert sind, muss die Sektorgröße des Laufwerks auf 2328
       Bytes konfiguriert sein.

       Mit diesem Befehl kann die Fehlerkorrektur (Error correction (ECC))
       des Befehls READXL an- oder ausgeschaltet werden. Fehlerkorrektur
       kann sowohl in der Hardware als auch in der Software realisiert
       sein (abhängig vom CD-ROM-Laufwerk). Wenn ECC in der Software
       vorgenommen wird, kann die CPU-Belastung recht hoch werden. Auf CDs
       kommen Fehler recht selten vor, wenn sie nicht zahlreiche Kratzer
       aufweisen, und wenn das der Fall ist, geht das auf Kosten der
       CPU-Bandbreite. Wenn ECC in der Hardware eingerichtet ist, geht
       keine CPU-Zeit verloren -- in diesem Fall ist ECC immer an, ganz egal
       wie das Laufwerk konfiguriert ist, weil sie nichts kostet. Der Befehl
       READXL wird hauptsächlich zur Darstellung Film-ähnlicher Daten
       verwendet. Dabei ist Geschwindigkeit wichtig, die Datensicherheit
       ist es nicht; wenn jedoch die CPU während einer XL-animation nicht
       eingesetzt wird, besteht keine Notwendigkeit ECC auszuschalten (da
       CPU-Zeit hierbei ja verwendet werden kann). Der einzige Fall, in dem
       ECC abgeschaltet sein sollte, ist, wenn im Hintergrund des Befehls
       READXL intensive Berechnungen durchgeführt werden UND das Programm
       zeitkritisch ist. Wenn das erledigt ist, darf nicht vergessen werden,
       diesen Befehl wieder zurück zu setzen.

       Um den Computer in den Ausgangszustand zurück zu setzen (reset), wenn
       eine CD ausgeworfen wird (für eine Anwendung, die nicht von selbst
       endet), ist die Marke (tag) TAGCD_EJECTRESET zu verwenden. Nach
       Möglichkeit sollten Programme sauber zur Workbench zurückkehren
       können. Fehlerbedingungen sollten bei Disk-Ein/Ausgabe überwacht
       werden.

   BEISPIEL

       /* Konfiguration ReadXL für double-speed lesen und abschalten von */
       /* ECC, wenn der Befehl ReadXL verwendet wird.                    */
       
       struct TagItem ConfigList[] = {

           { TAGCD_READXLSPEED, 150 },
           { TAGCD_XLECC,       0   },
           { TAG_END,           0   }
           };

           ior->io_Command = CD_CONFIG;
           ior->io_Data    = (APTR)&ConfigList;
           ior->io_Length  = 0;
           DoIO(ior);

           if (ior->io_Error) printf("Could not be configured\n");

   ANMERKUNGEN
       Die Einstellung der Konfiguration verändert nicht das Verhalten
       eines Befehl zum Lesen oder zum Abspielen, wenn er schon läuft.

       Dieser Befehl kann sehr gefährlich sein. Wenn z.B. TAGCD_SECTORSIZE
       auf 2328 gesetzt ist, können keine Daten, die in Sektoren mit 2048
       Bytes codiert sind, mehr gelesen weden (z.B. kann das Dateisystem
       die Disk nicht mehr lesen). Wenn also Daten, die mit diesem Sektor-
       Format abgelegt sind, gelesen wurden, sollte sofort zum originalen
       vorgegebenen (default) Wert zurückgekehrt werden (selbst bei einem
       Lesefehler -- die Disk hätte ja mitten im Lesevorgang entfernt worden
       sein können). Dieser Befehl sollte von KEINEM ANDEREN als dem
       ausschließlichen Eigentümer der Disk verwendet werden.

   BUGS
       TAG_IGNORE, TAG_MORE und TAG_SKIP arbeiten nicht. Bitte nicht
       verwenden.

       Wenn die Geschwindigkeit von einfach (single speed) auf doppelt
       (double speed) oder von doppelt auf einfach umgeschaltet wird, wenn
       das Laufwerk in einfacher Geschwindigkeit Daten beschafft, die in
       doppelter Geschwindigkeit verwendet werden sollen, schaltet das
       Laufwerk nicht auf doppelte Geschwindigkeit um (und auch andersherum
       nicht). Um dieses Problem zu umgehen, ist auf die gewünschte
       Geschwindigkeit zu schalten, es ist zu beginnen mindestens 4k an
       Daten einzulesen (einfach zwei Bytes lesen), dann ist mit dem Lesen
       wieder am Anfang zu beginnen. Dadurch wird der Lesespeicher gelöscht
       und ein neuer Lesebefehl mit der gewünschten Geschwindigkeit
       ausgegeben. (Berichtigt in 40.24).

   SIEHE AUCH
       CD_INFO, <utility/tagitem.h>


cd.device/CD_EJECT                                         cd.device/CD_EJECT

   NAME
       CD_EJECT -- Öffnen oder Schließen des CD-Laufwerks

   IO REQUEST
       io_Command      CD_EJECT
       io_Data         NULL
       io_Length       geforderter Zustand des Laufwerks (0 == geschlossen,
                       1 == offen)
       io_Offset       0

   RESULTS
       io_Error        0 bei Erfolg oder ein Fehlercode wie festgelegt in
                       <devices/cd.h>
       io_Actual       vorheriger Zustand des Laufwerks

   FUNKTION
       Dieser Befehl öffnet das Laufwerk oder schließt es (Aus- oder
       Einfahren der Schublade). Der gewünschte Zustand wird in io_Length
       abgelegt. Der vorherige Zustand des Laufwerks wird in io_Actual
       zurückgegeben.

   BEISPIEL

   ANMERKUNGEN

   BUGS

   SIEHE AUCH


cd.device/CD_GETGEOMETRY                             cd.device/CD_GETGEOMETRY

   NAME
       CD_GETGEOMETRY -- gibt die Laufwerksgeometrie zurück.

   FUNKTION
       Dieser Befehl gibt einen vollständigen Satz an Informationen
       über den Aufbau des Laufwerks zurück. Die Information wird in der
       Struktur DriveGeometry zurückgegeben, die mit dem Zeiger io_Data
       bestimmt ist.

   IO REQUEST EINGABE
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_GETGEOMETRY
       io_Data         Zeiger auf eine Struktur DriveGeometry
       io_Length       Größe von (struct DriveGeometry)

   IO REQUEST RESULT
       io_Error  - 0 bei Erfolg oder ein Fehlercode wie festgelegt in
                   <devices/cd.h>
       io_Actual - Länge der übertragenen Daten.

   SIEHE AUCH
       CD_GETNUMTRACKS, <devices/trackdisk.h>


cd.device/CD_INFO                                           cd.device/CD_INFO

   NAME
       CD_INFO -- Gibt Informationen/Status des Gerätes zurück

   IO REQUEST
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_INFO
       io_Data         Zeiger auf Struktur CDInfo
       io_Length       Größe von (struct CDInfo)

   RESULTS
       io_Error        0 bei Erfolg oder ein Fehlercode wie festgelegt in
                       <devices/cd.h>
       io_Actual       Länge der übertragenen Daten

   FUNKTION

       Dieser Befehl gibt die aktuelle Konfiguration und den Status des
       Geräte-Treibers zurück.

   BEISPIEL

       struct CDInfo Info;

       ior->io_Command = CD_INFO;               /* Besorge Laufwerk-Info.  */
       ior->io_Data    = (APTR)Info;            /* Hierhin wollen wir sie  */
       ior->io_Length  = sizeof(struct CDInfo); /* Gibt Struktur-Größe aus */
       DoIO(ior);

       if (!ior->io_Error) {                    /* Command succeeded       */

           if (Info.Status & CDSTSF_PLAYING) printf("Audio is playing\n");
           else                              printf("Audio not playing\n");
           }

   ANMERKUNGEN

   BUGS

   SIEHE AUCH
       <devices/cd.h>


cd.device/CD_MOTOR                                         cd.device/CD_MOTOR

   NAME
       CD_MOTOR -- Steuerung des an/aus-Zustands eines Laufwerkmotors.

   FUNKTION
       Mit diesem Befehl wird der Drehteller-Motor gesteuert. Der Motor kann
       an- oder ausgeschaltet sein.

       Wenn der Motor gerade angeschaltet wurde, wartet der Gerätetreiber
       (device) ausreichend lange, um das Laufwerk auf Lesegeschwindigkeit
       kommen zu lassen. Es ist nicht nötig, den Motor von Hand an oder ab
       zu schalten, der Treiber tut dies automatisch, wenn er eine Anforderung
       bei stehendem Motor erhält.

   IO REQUEST EINGABE
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_MOTOR
       io_Length       der gewünschte Zustand des Motors, 0 um den Motor
                       ab zu schalten und 1, um ihn ein zu schalten.

   IO REQUEST RESULT
       io_Error - 0 bei Erfolg oder ein Fehlercode wie festgelegt in
                  <devices/cd.h>
       io_Actual - wenn io_Error 0 ist, enthält dieses den vorherigen Zustand
                   des Laufwerk-Motors.


cd.device/CD_PAUSE                                         cd.device/CD_PAUSE

   NAME
       CD_PAUSE -- Pausieren oder Weitermachen für den Abspiel-(play)-Befehl.

   IO REQUEST
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_PAUSE
       io_Data         NULL
       io_Length       Pausenmodus : 1 = Pause beim Abspielen; 0 = keine
                       Pause beim Abspielen;
       io_Offset       0

   RÜCKGABEN
       io_Actual - wenn io_Error 0 ist, ist hier der vorhergegangene Pausen-
                   Zustand enthalten.

   FUNKTION
       Dieser Befehl setzt die CD in den Pausenmodus oder nimmt sie wieder
       heraus. Der gewünschte Pausenzustand wird in io_Length übergeben.
       Dieser Befehl beeinflusst nur die Abspiel-Befehle. Wenn Audio
       abgespielt wird und der Pausenmodus eingeschaltet wird, unterbricht
       dieser Befehl sofort die Ausgabe, bis der Pausen-Zustand wieder
       aufgehoben wird. Wenn Audio nicht abgespielt wird und der Pausenmodus
       wird eingeschaltet, hat der Befehl keine unmittelbare Auswirkung.
       Wir dann ein Abspiel-Befehl übermittelt, sucht der Laser die richtige
       Position auf und pausiert dort. Der Abspielbefehl wartet, bis der
       Pausen-Zustand beendet ist (oder bis das Abspielen abgebrochen wird).

   BEISPIEL

   ANMERKUNGEN

   BUGS

   SIEHE AUCH


cd.device/CD_PLAYLSN                                     cd.device/CD_PLAYLSN

   NAME
        CD_PLAYLSN -- Spielt einen ausgewählten Abschnitt des CD-Audio
                      (LSN-Form).

   IO REQUEST
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_PLAYLSN
       io_Data         NULL
       io_Length       Länge des Abspielbereichs
       io_Offset       Anfangsposition

   RÜCKGABEN
       io_Error        0 bei Erfolg oder ein Fehlercode wie festgelegt in
                       <devices/cd.h>

   FUNKTION
       Mit diesem Befehl beginnt das Laufwerk CD-Audio ab der vorgegebenen
       Position abzuspielen, bis die eingestellte Länge erreicht ist.

       io_Offset gibt die Anfangsposition an. io_Length enthält den Zeitraum
       des Abspielen. Alle Daten sind angegeben im LSN-Format.

       Eine Rückgabe von DoIO() erfolgt nicht, ehe die angeforderte Zahl an
       Sektoren abgespielt ist. Eine Rückgabe von SendIO() findet statt,
       sobald das Abspielen (PLAY) begonnen hat. Zu diesem Zeitpunkt können
       weitere Befehle (wie CD_PAUSE) gesendet werden. Um das Abspielen vor
       dem vorgegebenen Ende abzubrechen, ist AbortIO() zu verwenden.

   BEISPIEL
       /* Spiele zwei Minuten und zehn Sekunden Audio mit Beginn bei */
       /* 20 Minuten, 58 Sekunden und 10 Frames.                     */

       ior->io_Command = CD_PLAYLSN;   /* Spiele CD-Audio         */
       ior->io_Offset  = 94360;        /* 20*(60*75) + 58*75 + 10 */
       ior->io_Length  = 9750;         /* 02*(60*75) + 10*75 + 00 */
       DoIO (ior);

   ANMERKUNGEN

   BUGS

   SIEHE AUCH
       CD_PLAYTRACK, CD_PAUSE, CD_SEARCH, CD_ATTENUATE


cd.device/CD_PLAYMSF                                     cd.device/CD_PLAYMSF

   NAME
        CD_PLAYMSF -- Spielt einen ausgewählten Abschnitt des CD-Audio
                      (MSF-Format).

   IO REQUEST
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_PLAYMSF
       io_Data         NULL
       io_Length       Länge des Abspielbereichs
       io_Offset       Anfangsposition

   RÜCKGABEN
       io_Error        0 bei Erfolg oder ein Fehlercode wie festgelegt in
                       <devices/cd.h>

   FUNKTION
       Mit diesem Befehl beginnt das Laufwerk CD-Audio ab der vorgegebenen
       Position abzuspielen, bis die eingestellte Länge erreicht ist.

       io_Offset gibt die Anfangsposition an. io_Length enthält den Zeitraum
       des Abspielen. Alle Daten sind angegeben im MSF-Format.

       Eine Rückgabe von DoIO() erfolgt nicht, ehe die angeforderte Zahl an
       Sektoren abgespielt ist. Eine Rückgabe von SendIO() findet statt,
       sobald das Abspielen (PLAY) begonnen hat. Zu diesem Zeitpunkt können
       weitere Befehle (wie CD_PAUSE) gesendet werden. Um das Abspielen vor
       dem vorgegebenen Ende abzubrechen, ist AbortIO() zu verwenden.

   BEISPIEL
       /* Spiele zwei Minuten und zehn Sekunden Audio mit Beginn bei */
       /* 20 Minuten, 58 Sekunden und 10 Frames.                     */

       ior->io_Command = CD_PLAYMSF;   /* Spiele CD-Audio        */
       ior->io_Offset  = 0x00143A0A;   /* $14=20, $3A=58, $0A=10 */
       ior->io_Length  = 0x00020A00;   /* $02=02, $0A=10, $00=00 */
       DoIO (ior);

   ANMERKUNGEN

   BUGS

   SIEHE AUCH
       CD_PLAYTRACK, CD_PAUSE, CD_SEARCH, CD_ATTENUATE


cd.device/CD_PLAYTRACK                                 cd.device/CD_PLAYTRACK

   NAME
       CD_PLAYTRACK -- Spielt eine oder mehrere Spuren (tracks) CD-Audio.

   IO REQUEST
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_PLAYTRACK
       io_Data         NULL
       io_Length       Zahl der abzuspielenden Spuren (tracks)
       io_Offset       Spielbeginn am Anfang dieser Spur

   RÜCKGABEN
       io_Error        0 bei Erfolg oder ein Fehlercode wie festgelegt in
                       <devices/cd.h>
   FUNKTION
       Durch diesen Befehl spielt das Laufwerk die angegebene Zahl an
       Audiospuren ab. Die Befehlsrückgabe erfolgt nach Abschluss der
       Audio-Ausgabe.

       io_Offset gibt die Spur-Nummer an (beginnend bei 1).

       io_Length gibt die Zahl der abzuspielenden Spuren an (0 ist eine
       ungültige Eingabe).

   BEISPIEL

       ior->io_Command = CD_PLAYTRACK;    /* Audiospuren abspielen */
       ior->io_Offset  = STARTTRACK;      /* Bginn bei dieser Spur */
       ior->io_Length  = 3;               /* Spiele drei Spuren    */
       DoIO(ior);

   ANMERKUNGEN

       PLAY-Befehle sind assynchron zu vielen anderen CD-Befehlen.
       Mit einer getrennten I/O-Anforderung (I/O request) können andere
       Befehle zum Gerätetreiber (device) gesandt werdeen, die das Verhalten
       der PLAY-Befehle verändern.

   BUGS

   SIEHE AUCH
       CD_PLAYMSF, CD_PLAYLSN, CD_PAUSE, CD_SEARCH, CD_ATTENUATE


cd.device/CD_PROTSTATUS                               cd.device/CD_PROTSTATUS

   NAME
       CD_PROTSTATUS -- Rückgabe, ob die aktuelle Disk schreibgeschützt ist.

   FUNKTION
       Mit diesem Befehl kann man feststellen, ob die aktuelle Disk
       schreibgeschützt ist. Zur Zeit meldet diese Funktion immer den
       Zustand "Schreibgeschützt". Wenn irgend einmal beschreibbare CDs
       zur Verfügung stehen, kann das geändert werden.

   IO REQUEST EINGABE
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_PROTSTATUS

   IO REQUEST RESULT
       io_Error - 0 bei Erfolg oder ein Fehlercode wie festgelegt in
                  <devices/cd.h>
       io_Actual - 0 bedeutet, die Disk ist NICHT schreibgeschützt, während
                   jeder andere Wert den Schreibschutz anzeigt.


cd.device/CD_QCODELSN                                   cd.device/CD_QCODELSN

   NAME
       CD_QCODELSN -- Melde aktuelle Diskposition.

   IO REQUEST
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_QCODELSN
       io_Data         Zeiger auf QCode Strukture
       io_Length       0 - MUSS Null sein (wegen zukünftiger Kompatabilität)

   RÜCKGABEN
       io_Error        0 bei Erfolg oder ein Fehlercode wie festgelegt in
                       <devices/cd.h>

   FUNKTION
       Dieser Befehl meldet die derzeit gültige Zeit-Information im
       Unterbereich des Q-Kanals (subcode Q channel time information). Dieser
       Befehl gibt nur Daten zurück, wenn CD-Audio spielt (oder pausiert).
       Zu jeder anderen Zeit wird ein Fehler zurückgegeben. Das Q-Code-Paket
       besteht aus:

       struct QCode {

           UBYTE        CtlAdr;        /* Datentype / QCode-Type             */
           UBYTE        Track;         /* Spurnummer                         */
           UBYTE        Index;         /* Spur-Subindex-Nummer               */
           UBYTE        Zero;          /* Das "Zero"-Byte des Q-Code-Packets */
           union LSNMSF TrackPosition; /* Position vom Anfang der Spur       */
           union LSNMSF DiskPosition;  /* Position vom Anfang der Disk       */
           };

   BEISPIEL

       struct QCode qcode;

       ior->io_Command = CD_QCODELSN;  /* TOC-Informationen besorgen */
       ior->io_Length  = 0;            /* MUSS Null sein             */
       ior->io_Data    = (APTR)qcode;  /* Hier wollen wir es haben   */
       DoIO (ior);

       if (!ior->io_Error) {           /* Befehl erfolgreich         */

           printf("Current position is: %ld\n", qcode.DiskPosition.LSN);
           }

   ANMERKUNGEN
       Dieser Befehl muss nicht unbedingt sofort eine Rückgabe machen. Es
       kann einige Frames dauern, bis ein gültiges Q-Code-Paket zurück
       gegeben werden kann. SendIO() und CheckIO() sind zu verwenden,
       wenn die Antwortzeit kritisch ist, jedoch nicht die Information.

   BUGS

   SIEHE AUCH
       CD_PLAYMSF, CD_PLAYLSN, CD_PLAYTRACK, <devices/cd.h>


cd.device/CD_QCODEMSF                                   cd.device/CD_QCODEMSF

   NAME
       CD_QCODEMSF -- Melde aktuelle Diskposition.

   IO REQUEST
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_QCODEMSF
       io_Data         Zeiger auf QCode Strukture
       io_Length       0 - MUSS Null sein (wegen zukünftiger Kompatabilität)

   RÜCKGABEN
       io_Error        0 bei Erfolg oder ein Fehlercode wie festgelegt in
                       <devices/cd.h>

   FUNKTION
       Dieser Befehl meldet die derzeit gültige Zeit-Information im
       Unterbereich des Q-Kanals (subcode Q channel time information).
       Dieser Befehl gibt nur Daten zurück, wenn CD-Audio spielt (oder
       pausiert). Zu jeder anderen Zeit wird ein Fehler zurückgegeben.
       Das Q-Code-Paket besteht aus:

       struct QCode {

           UBYTE        CtlAdr;        /* Datentype / QCode-Type             */
           UBYTE        Track;         /* Spurnummer                         */
           UBYTE        Index;         /* Spur-Subindex-Nummer               */
           UBYTE        Zero;          /* Das "Zero"-Byte des Q-Code-Packets */
           union LSNMSF TrackPosition; /* Position vom Anfang der Spur       */
           union LSNMSF DiskPosition;  /* Position vom Anfang der Disk       */
           };

   BEISPIEL

       struct QCode qcode;

       ior->io_Command = CD_QCODEMSF;  /* TOC-Informationen besorgen */
       ior->io_Length  = 0;            /* MUSS Null sein             */
       ior->io_Data    = (APTR)qcode;  /* Hier wollen wir es haben   */
       DoIO (ior);

       if (!ior->io_Error) {           /* Befehl erfolgreich         */

           printf("Current position is: %02d:%02d:%02d\n",
               qcode.DiskPosition.MSF.Minute,
               qcode.DiskPosition.MSF.Second,
               qcode.DiskPosition.MSF.Frame);
           }

   ANMERKUNGEN
       Dieser Befehl muss nicht unbedingt sofort eine Rückgabe machen. Es
       kann einige Frames dauern, bis ein gültiges Q-Code-Paket zurück
       gegeben werden kann. SendIO() und CheckIO() sind zu verwenden, wenn
       die Antwortzeit kritisch ist, jedoch nicht die Information.

   BUGS

   SIEHE AUCH
       CD_PLAYMSF, CD_PLAYLSN, CD_PLAYTRACK, <devices/cd.h>


cd.device/CD_READ                                           cd.device/CD_READ

   NAME
       CD_READ -- Daten von der Disk lesen.

   FUNKTION
       Liest Daten von der Disk in den Speicher. Auf Daten kann an WORD-
       Grenzen zugegriffen werden (es besteht keine Beschränkung auf Sektor-
       Grenzen wie bei normalen Disk-Gerätetreibern (devices)). Die Länge
       der Daten kann auch in WORD-Größe angegeben werden.

   IO REQUEST EINGABE
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_READ
       io_Data         Zeiger auf den Puffer, wo die Daten hin kommen sollen.
       io_Length       Zahl der zu lesenden Bytes, es muss ein Vielfaches
                       von WORD sein.
       io_Offset       Abstand vom Anfang der Disk in Bytes zur Angabe,
                       ab wo die Daten zu lesen sind, es muss ein Vielfaches
                       von WORD sein. 

   IO REQUEST RESULT
       io_Error  - 0 bei Erfolg oder ein Fehlercode wie festgelegt in
                   <devices/cd.h>
       io_Actual - wenn io_Error 0 ist, Zahl der tatsächlich übertragenen
                   Bytes

   ANMERKUNGEN
       Wenn während dem Versuch eines CD_READ ein Fehler auftritt,
       versucht die Software den Zugriff bis zu 10 Mal erneut, bis sie
       die Anforderung abbricht. Wenn es sich um ein Double-Speed-Laufwerk
       handelt, bei dem der Fehler auftritt, wird ein weiterer Versuch in
       doppelter Geschwindigkeit ausgeführt und wenn der misslingt, laufen
       die nächsten neun Versuche in einfacher Geschwindigkeit.

   SIEHE AUCH
       CD_READXL


cd.device/CD_READXL                                       cd.device/CD_READXL

   NAME
       CD_READXL -- Von der CD-ROM in den Speicher via Transferliste lesen.

   IO REQUEST
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_READXL
       io_Data         Zeiger auf die Transferliste (d.h. struct List *).
       io_Length       maximale Übertragungslänge (Vielfaches von WORD) oder 0.
       io_Offset       Byte-Abstand vom Beginn der Disk als Angabe, wo mit dem
                       Lesen der Daten begonnen werden soll, muss ein
                       Vielfaches von WORD sein.

   RÜCKGABEN
       io_Error        0 bei Erfolg oder ein Fehlercode wie festgelegt in
                       <devices/cd.h>
       io_Actual       falls io_Error 0 ist, Zahl der tatsächlich übertragenen
                       der Bytes

   FUNKTION
       Dieser Befehl beginnt an einem angegebenen Ort auf der Disk mit
       dem Lesen der Daten und legt sie im Speicher an den Bezugspunkten
       (nodes) ab, die in einer Transferliste angegeben sind. Der Zeiger
       auf die Liste mit den Bezugspunkten ist in io_Data abgelegt. Wenn
       eine nicht-zirkulare Transferlist vorhanden ist, muss io_Length
       einfach auf 0 gesetzt werden (0 ist ein spezieller Wert und bedeutet,
       dass io_Length zu ignorieren ist) -- die Übertragung endet, wenn
       die Transferliste abgearbeitet ist. Wenn eine zirkulare Transferlist
       vorhanden ist, hört diese Liste nie auf. In diesem Falle endet die
       Übertragung, wenn io_Length Bytes übertragen sind.

       Die Felder in der CDXL node structure sind:

       struct  CDXL {

           struct MinNode  Node;         /* doppelte Verbindung              */
           char           *Buffer;       /* Bestimmungsort der Daten         */
           LONG            Length;       /* muss geradzahlige Anzahl von     */
                                         /* Bytes sein                       */
           LONG            Actual;       /* übertragene Bytes                */
           APTR            IntData;      /* Datenseg. für Interrupt Server   */
           VOID            (*IntCode)(); /* Code-Eintrag f. Interrupt Server */
           };

       Die Philosophie hier ist, dass man einen Puffer einrichtet, der
       gefüllt werden soll, CDXL-Bezugspunkte (nodes) erzeugt, die den Ort
       und die Größe dieses Puffers beschreiben, alle diese Bezugspunkte in
       der gewünschten Reihenfolge verbindet (oder sogar eine zirkulare
       Liste für Animationen erstellt) und den Befehl ausführt. Die Daten
       fließem in den vorgesehenen Puffer bis die Liste abgearbeitet ist,
       bis ein Eintrag mit der Länge Null erkannt wird, bis io_Length Bytes
       übertragen wurden (wenn io_Length ungleich Null ist) oder bis der
       Befehl mit AbortIO() abgebrochen wurde.

       Wenn in das Feld (*IntCode)() ein Zeiger auf eine Interrupt-Routine
       gesetzt wird, wird diese Routine aufgerufen, wenn die Übertragung
       für diesen Bezugspunkt erledigt ist. Der Code wird aufgerufen, ehe
       der Treiber zum nächsten Punkt weitergeht. Der Interrupt sollte nach
       den gleichen Regeln wie Standard-Interrupts aufgebaut sein (siehe
       AddIntServer der Exec Autodocs). Im Register A2 steht ein Zeiger auf
       den Bezugspunkt, der gerade erledigt wurde. Die Liste kann mit dem
       Interrupt manipuliert werden. Der Code muss kurz sein (es handelt
       sich um einen Interrupt). Bei der Rückkehr aus diesem Interrupt ist
       D0 frei zu geben und eine RTS-Anweisung sollte für den Rücksprung
       verwendet werden.

       Server werden mit folgenden Register-Konventionen aufgerufen:
       
           D0 - scratch
           D1 - scratch

           A0 - scratch
           A1 - server is_Data pointer (scratch)
           A2 - pointer to CDXL node just completed

           A5 - jump vector register (scratch)

           Alle anderen Register müssen erhalten bleiben
           
   BEISPIEL

   ANMERKUNGEN
       Es ist sicher zu stellen, dass kleine Puffer nicht über Gebühr
       benutzt werden. Jedesmal wenn ein Bezugspunkt (node) erledigt ist,
       wird ein Interrupt erzeugt. Wenn der Computer anfängt träge zu
       arbeiten oder wenn der Befehl CD_READXL abbricht, werden sicher
       zuviele Interrupts erzeugt. Es nicht sehr wirkungsvoll, wenn in
       einer vertikalen Austastlücke mehr als nur ein paar dieser
       Interrupts erzeugt werden.

       Anders als beim Befehl READ wiederholt der Befehl READXL nicht den
       Leseversuch des Sektors, wenn ein Fehler auftritt. Da der Befehl
       READXL hauptsächlich für Animationen gedacht ist, wird der Fluss der
       Daten als wichtiger angesehen als die Daten selbst. Eine Fehlermeldung
       wird in io_Error zurückgegeben, wenn ein Datenfehler auftritt. Auf
       keinen Fall wird der Befehl auf eine geringere Geschwindigkeit zurück
       fallen, wenn ein Fehler auftritt.

   BUGS

   SIEHE AUCH
       CMD_READ, CD_SEEK, Autodocs - AddIntServer


cd.device/CD_REMCHANGEINT                           cd.device/CD_REMCHANGEINT

   NAME
       CD_REMCHANGEINT -- Entfernen eines Software-Interrupt-Handlers
                          bei Diskwechsel.

   FUNKTION
       Dieser Befehl entfernt einen Software-Interrupt für Disk-Wechsel, der
       durch eine vorherige Verwendung von CD_ADDCHANGEINT hinzu gefügt wurde.

   IO REQUEST EINGABE
       Die gleiche IO-Anforderung, die für CD_ADDCHANGEINT benutzt worden war.

       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_REMCHANGEINT
       io_Length       Größe von (struct Interrupt)
       io_Data         Zeiger auf Interrupt-Strukture

   IO REQUEST RESULT
       io_Error - 0 bei Erfolg oder ein Fehlercode wie festgelegt in
                  <devices/cd.h>

   SIEHE AUCH
       CD_ADDCHANGEINT, <devices/cd.h>


cd.device/CD_REMFRAMEINT                             cd.device/CD_REMFRAMEINT

   NAME
       CD_REMFRAMEINT -- Entfernen eines CD-Frame-Interrupt-Handlers.

   FUNKTION
       Dieser Befehl entfernt einen CD-Frame-Software-Interrupt, der durch
       eine vorherige Verwendung von CD_ADDFRAMEINT hinzu gefügt wurde.

   IO REQUEST
       Die gleiche IO-Anforderung, die für CD_ADDFRAMEINT benutzt worden war.

       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_REMFRAMEINT
       io_Length       Größe von (struct Interrupt)
       io_Data         Zeiger auf Interrupt-Strukture

   RÜCKGABEN
       io_Error        0 bei Erfolg oder ein Fehlercode wie festgelegt in
                       <devices/cd.h>
   BUGS

   SIEHE AUCH
       CD_ADDFRAMEINT, <devices/cd.h>


cd.device/CD_SEARCH                                       cd.device/CD_SEARCH

   NAME
       CD_SEARCH -- Konfigurieren des Modus, in welchem der Befehl PLAY
                    läuft.

   IO REQUEST
       io_Command      CD_SEARCH
       io_Data         NULL
       io_Length       Suchmodus
       io_Offset       0

   RÜCKGABEN
       io_Actual - wenn io_Error 0 ist, ist hier der vorhergehende Suchmodus
                   enthalten.

   FUNKTION
       Dieser Befehl lässt den Abspielbefehl schnell vorwärts, schnell
       rückwärts oder normal laufen. Diese Moden sind definiert als:

       CDMODE_NORMAL   0   Normales Spiele (aktuelle Einstellung der
                           Geschwindigkeit)
       CDMODE_FFWD     1   Spielen im Modus schnell forwärts  
       CDMODE_FREV     2   Spielen im Modus schnell rückwärts

       Der Suchmodus kann eingestellt werden, ehe der Abspielbefehl gesendet
       wurde oder während des Abspiels. Wenn CD_SEARCH vor einem Abspielbefehl
       gesendet wurde, wird der Modus eingestellt und der Befehl kommt sofort
       zurück. Wenn der Modus auf REV eingestellt ist, wenn der Spielbefehl
       gesendet wird, beginnt das Abspielen am eingestellten Endpunkt und
       arbeit rückwärts bis zum Anfangspunkt.

       Wird CD_SEARCH während dem Abspielen gesendet, wird das Abspiel
       automatisch auf den gewünschten Modus geschaltet und fortgesetzt,
       bis der originale Abspielbefehl erledigt ist. Wenn der REV-Modus
       eingestellt ist und der Beginn des Abspielens vor dem Umschalten
       auf Vorwärts-Spiel erreicht wird, endet der Spielbefehl ohne Fehler.

   BEISPIEL
       /* Suchen im schnellen Forwärts-Modus. */
       ior->io_Command = CD_SEARCH;
       ior->io_Data    = NULL;
       ior->io_Offset  = 0;
       ior->io_Length  = CDMODE_FFWD;
       DoIO(ior);

   ANMERKUNGEN

   BUGS

   SIEHE AUCH


cd.device/CD_SEEK                                           cd.device/CD_SEEK

   NAME
       CD_SEEK -- Laserpostion auf bestimmte Stelle einrichten.

   FUNKTION
       CD_SEEK bewegt den Laser ungefähr auf die Stelle, die angegeben wurde.
       Im Feld io_Offset sollte die Position stehen, zu welchem der Laser zu
       setzen ist.

   IO REQUEST EINGABE
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_SEEK
       io_Offset       Position, zu der der Kopf bewegt werden soll
                       (immer LSN-Format)

   IO REQUEST RESULT
       io_Error - 0 bei Erfolg oder ein Fehlercode wie festgelegt in
                  <devices/cd.h>


cd.device/CD_TOCLSN                                       cd.device/CD_TOCLSN

   NAME
       CD_TOCLSN -- Gibt Informationen über das Inhaltsverzeichnis (TOC) der
                    CD zurück (LSN-Format).

   IO REQUEST
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_TOCLSN
       io_Data         Zeiger auf Array, wo das Verzeichnis gespeichert
                       werden soll
       io_Length       Zahl der CDTOC-Einträge, die geholt werden sollen
       io_Offset       Eintrag, bei dem begonnen werden soll
                       (Eintrag 0 bedeutet zusammengefasste Information)

   RÜCKGABEN
       io_Error        0 bei Erfolg oder ein Fehlercode wie festgelegt in
                       <devices/cd.h>
       io_Actual       Tatsächliche Zahl der kopierten Einträge

   FUNKTION
       Dieser Befehl gibt das Inhaltsverzeichnis der Disk zurück, die sich
       im Laufwerk befindet. Das Inhaltsverzeichnis besteht aus bis zu 100
       Einträgen. Eintrag Null ist eine zusammengefasste Information, welche
       die Zahl der Spuren und Gesamtzahl der Minuten auf der Disk enthält.
       Einträge 1 bis N enthalten Informationen über jede einzelne Spur. Alle
       Informationen über Positionen sind im LSN-Format.

       Das Feld io_Data zeigt auf ein Array von CDTOC-Strukturen zur Aufnahme
       der TOC-Daten.

       Das Feld io_Length enthält die Zahl der Einträge, die abgeholt werden
       sollen. Das Array, auf das durch io_Data verwiesen wird, muss
       mindestens diese Zahl an Elementen aufnehmen können.

       Das Feld io_Offset gibt die Eintragsnummer an, bei der mit dem Kopieren
       der TOC-Daten nach *io_Data begonnen werden soll. 

       Eintrag Null (der summarische Eintrag) enthält folgendes:

       struct TOCSummary {

           UBYTE        FirstTrack;    /* Erste Spur auf Disk (immer 1)  */
           UBYTE        LastTrack;     /* Letzte Spur auf Disk           */
           union LSNMSF LeadOut;       /* Beginn des Ausleitungsspur     */
           };

       Spureinträge (Einträge 1 bis Zahl der Spuren) enthalten:

       struct TOCEntry {

           UBYTE        CtlAdr;        /* Q-Code-Info               */
           UBYTE        Track;         /* Spurnummer                */
           union LSNMSF Position;      /* Startposition dieser Spur */
           };

       CDTOC wird beschrieben als Verbindung dieser beiden Strukturen:

       union CDTOC {

           struct TOCSummary Summary;  /* Erster Eintrag ist summarische info */
           struct TOCEntry   Entry;    /* Einträge 1-N sind Spureinträge      */
           };


   BEISPIEL
       
       union CDTOC tocarray[100];

       ior->io_Command = CD_TOCLSN;        /* Besorge TOC-Information      */
       ior->io_Offset  = 0;                /* Beginn mit summarischer Info */
       ior->io_Length  = 100;              /* Max. 99 Spuren + summarisch  */
       ior->io_Data    = (APTR)tocarray;   /* Hier soll es hin             */
       DoIO (ior);

       if (!ior->io_Error) {               /* Befehl erfolgreich           */

           firsttrack   = tocarray[0].Summary.FirstTrack;
           lasttrack    = tocarray[0].Summary.LastTrack;
           totalsectors = tocarray[0].Summary.LeadOut.LSN -
                          tocarray[1].Entry.Position.LSN;
                           }

   ANMERKUNGEN

       In oben gezeigten Beispiel ist die Menge der Daten auf der Disk
       berechnet als gleich dem Ort der Ausleitungs-Spur minus dem Beginn
       der ersten Spur (was niemals Null ergibt). 
       [Anmerkung für die Redaktion: Im englischen Text ist nicht eindeutig,
       worauf sich "Null" bezieht: Die berechnete Differenz oder den Beginn
       der ersten Spur. Ggf. bitte ändern]

   BUGS

   SIEHE AUCH


cd.device/CD_TOCMSF                                       cd.device/CD_TOCMSF

   NAME
       CD_TOCMSF -- Gibt Informationen über das Inhaltsverzeichnis (TOC) der
                    CD zurück (MSF-Format).

   IO REQUEST
       io_Device       voreingestellt durch den Aufruf OpenDevice()
       io_Unit         voreingestellt durch den Aufruf OpenDevice()
       io_Command      CD_TOCMSF
       io_Data         Zeiger auf Array, wo das TOC abgelegt werden soll
       io_Length       Zahl der CDTOC-Einträge, die geholt werden sollen
       io_Offset       Eintrag, bei dem begonnen werden soll
                       (Eintrag 0 ist zusammengefasste Information)

   RÜCKGABEN
       io_Error        0 bei Erfolg oder ein Fehlercode wie festgelegt in
                       <devices/cd.h>
       io_Actual       Tatsächliche Zahl der kopierten Einträge

   FUNKTION
       Dieser Befehl gibt das Inhaltsverzeichnis der Disk zurück, die sich
       im Laufwerk befindet. Das Inhaltsverzeichnis besteht aus bis zu 100
       Einträgen. Eintrag Null ist eine zusammengefasste Information, welche
       die Zahl der Spuren und Gesamtzahl der Minuten auf der Disk enthält.
       Einträge 1 bis N enthalten Informationen über jede einzelne Spur. Alle
       Informationen über Positionen sind im MSF-Format.

       Das Feld io_Data zeigt auf ein Array von CDTOC-Strukturen zur Aufnahme
       der TOC-Daten.

       Das Feld io_Length enthält die Zahl der Einträge, die abgeholt werden
       sollen. Das Array, auf das durch io_Data verwiesen wird, muss
       mindestens diese Zahl an Elementen aufnehmen können.

       Das Feld io_Offset gibt die Eintragsnummer an, bei der mit dem
       Kopieren der TOC-Daten nach *io_Data begonnen werden soll.

       Eintrag Null (der summarische Eintrag) enthält folgendes:

       struct TOCSummary {

           UBYTE        FirstTrack;    /* Erste Spur auf Disk (immer 1)   */
           UBYTE        LastTrack;     /* Letzte Spur auf Disk            */
           union LSNMSF LeadOut;       /* Beginn der Ausleitungsspur      */
           };

       Spureinträge (Einträge 1 bis Zahl der Spuren) enthalten:

       struct TOCEntry {

           UBYTE        CtlAdr;        /* Q-Code-Info                */
           UBYTE        Track;         /* Spurnummer                 */
           union LSNMSF Position;      /* Startposition dieser Spur  */
           };

       CDTOC wird beschrieben als Verbindung dieser beiden Strukturen:

       union CDTOC {

           struct TOCSummary Summary;  /* Erster Eintrag summarische Info */
           struct TOCEntry   Entry;    /* Einträge 1-N sind Spur-Einträge */
           };

   BEISPIEL
       
   ANMERKUNGEN

   BUGS

   SIEHE AUCH


cd.device/CloseDevice                                   cd.device/CloseDevice

   NAME
       CloseDevice - Zugriff auf CD beenden

   SYNOPSIS
       CloseDevice(IORequest);
                   A1

   FUNKTION
       Diese Funktion beendet den Zugriff auf die Einheit, die mit
       OpenDevice() geöffnet wurde.

   EINGABEN
       iORequest - Zeiger auf struct(IOStdReq)

   RÜCKGABEN

   ANMERKUNGEN

   SIEHE AUCH
       OpenDevice()


cd.device/OpenDevice                                     cd.device/OpenDevice

   NAME
       OpenDevice - Öffnet eine CD-Einheit für Zugriff

   SYNOPSIS
       error = OpenDevice("cd.device", UnitNumber, IORequest, flags);
       D0                 A0           D0          A1         D1

   FUNKTION
       Öffnet das cd.device und erzeugt einen IORequest, um auf die CD
       zugreifen zu können.

   EINGABEN
       UnitNumber - Gewöhnlich Null; Jedoch wird das beschrieben als:
                    Einer-Stelle     = Unit (SCSI unit Nummer)
                    Zehner-Stelle    = LUN (Disk im Disk-Wechsler)
                    Hunderter-Stelle = Karten-Nummer (SCSI Karte)
                    Tausender-Stelle = Reserviert (muss Null sein)
       IORequest  - Pointer to a struct(IOStdReq)
       flags      - Sollte Null sein.

   RÜCKGABEN
       error        0 = Erfolg, andernfalls ist das ein Fehler.

   ANMERKUNGEN

   SIEHE AUCH
       CloseDevice()



@ENDNODE




@NODE "Forum1" "Suche Flink"
@TOC "MAIN"

@{b}Geschrieben von Erik Adler (erikabg@gmx.de) am 07. Dezember 2000:@{ub}


Ich habe mich damit beschäftigen müssen eine neue 1.3 Workbench Disk für 
mein CDTV erstellen zu müssen, weil die alte kaputt gegangen war. Da ich aber 
keinen Ersatz hatte, beschloß ich eine BootCD zu erstellen, die die Workbench 
von CD lädt. Das hat mich 17 Rohlinge und eine Woche intensiven Lesens 
gekostet, aber nun ist es vollbracht. 
Das Image wurde mit MakeCD im WinUAE in Windows erstellt (Disc-at-Once, 
RAW-Image), auf ein PC Laufwerk kopiert und mit Nero 5.0 gebrannt. Es ist 
mit Extras und OilImperium etwa 5 MB groß geworden. 
Wer so etwas auch machen muß und Probleme hat, schreibe mal ne mail. 

@ENDNODE

@NODE "Forum2" "Communicator II"
@TOC "MAIN"

@{b}Geschrieben von Martin Koulen (M.Koulen@gmx.de) am 10. Dezember 2000:@{ub}


Hallo suche dringend die Disketten für den Communicator II meine
haben einen Schreib/Lesefehler.Bin ausserdem immmer auf der Suche 
CDTV Software. Habe ne Menge CD32 Titel abzugeben. Bis dann. 

@ENDNODE

@NODE "Forum3" "Ich glaub' ich sehe nicht richtig!"
@TOC "MAIN"

@{b}Geschrieben von Darkage am 15. Dezember 2000:@{ub}


Das kann doch wohl nicht ernst gemeint sein, eine (damals sicher gute, aber 
mittlerweile) uralte Hardware samt einem lausig schlechten Animationsformat, 
das noch nicht mal simpeltste Kompressionen geschweige denn vernünftige 
Auflösungen / Farbtiefen kennt, supporten zu wollen! Wenn ich mir CDXL so 
ansehe, kommt in mir der Verdacht auf, bei Commodore mußte damals von einem 
Tag auf den anderen ganz fix ein neues Animationsformat erstellt werden - von 
durchdacht, offen oder flexibel kann bei dem Ding sicher nicht die Rede sein.

Und DAS soll noch unterstützt werden? Na ich muß mal schauen, was ich auf 
meinem C64 noch finde, da gibt es bestimmt auch noch irgend welche völlig 
veralteten Formate, die ich wieder aufwärmen könnte...

@ENDNODE

@NODE "Forum4" "Searching for a communicator"
@TOC "MAIN"

@{b}Geschrieben von MrX_Cuci (mrx@commodore-ale.com) am 20. Dezember 2000:@{ub}


The titel saya it all.
Sent me your price.

Cheers
MrX_Cuci 

@ENDNODE

@NODE "Forum5" "Suche CDTV Developer-Kit ..."
@TOC "MAIN"

@{b}Geschrieben von CD32-Allianz (CD32-Allianz@gmx.de) am 04. Januar 2001:@{ub}


Suche CDTV Developer-Kit da ich es mit auf die CD32 Forever nehmen möchte.
Wäre ausserdem jemand so lieb und schickt mir auch mal das CDXL.Datatype 
vom neuen AmigaOS3.9?

-> The CD32 is born again!

@ENDNODE

@NODE "Forum6" "CD-Rom mit CD32 nutzen?"
@TOC "MAIN"

@{b}Geschrieben von Dr. Zarkov (dr.zarkov@t-online.de) am 09. September 2000:@{ub}


Ich habe heute ein SX32 erfolgreich in mein CD32 eingebaut. 
Das Problem: wie kann ich das eingebaute CD-Romlaufwerk auch
als solches nutzen? CDs werden nicht erkannt, er bootet allerdings 
wie gehabt von CD32 Spiele-CDs. Idefix mit CacheCDFS brachte keinen 
Erfolg, es wird ein "unbekanntes SCSI Gerät" am CD.device und am 
CDTV.device angezeigt, jedoch wird kein CD-Rom gemountet. 

Watt nun?

@ENDNODE

@NODE "Forum7" "CD32 im Tower"
@TOC "MAIN"

@{b}Geschrieben von Michael Stiefel (WStiefel@t-online.de) am 06. Oktober 2000:@{ub}


Hilfe!

Wer kann mir helfen das CD32 in ein Big-Tower-Gehäuse einzubauen. 
Mein Problem liegt beim CD-ROM, kann man statt dem Standartlaufwerk 
auch ein IDE-Laufwerk verwenden?

Mike 

@ENDNODE

@NODE "Forum8" "CD32Games Downloaden"
@TOC "MAIN"

@{b}Geschrieben von cd32fan am 20. August 2000:@{ub}


Hi!

Wo kann man sich CD32-Games Downloaden? 
Ich meine damit Hauptsächlich Spiele von Privatpersonen, 
die ihre Amiga Games wie in Outside No2 beschrieben, 
erstellt haben!

@ENDNODE

@NODE "Forum9" "Festplatte für SX32"
@TOC "MAIN"

@{b}Geschrieben von Matthias (supermatse@gmx.de) am 24. August 2000:@{ub}


Welche Festplatten kann ich ohne großen Aufwand (also ohne 
zusätzlichen Trafo) in mein SX32 einbauen?

@ENDNODE

@NODE "Forum10" "Gibt es XenonII für`s CD³²?"
@TOC "MAIN"

@{b}Geschrieben von CD³²-Allianz (CD32-Allianz@gmx.de) am 29. Oktober 2000:@{ub}


Suche für einen interessenten dieses Spiel sofern
es dieses für das CD³² gibt.

-> The CD³² is born again!

@ENDNODE

@NODE "Forum11" "Lotus fürs CD32"
@TOC "MAIN"

@{b}Geschrieben von Andreas S. am 22. November 2000:@{ub}


Woher bekomme ich noch das Spiel Lotus für das CD32? 
Gibt es da noch irgendwelche Privatpersonen, die das Spiel 
besitzen und verkaufen möchten? 
Die Händler der Linkseiten haben es jedenfalls nicht mehr.

@ENDNODE

@NODE "Forum12" "Microcosm Musik"
@TOC "MAIN"

@{b}Geschrieben von Wolfgang (wolfgang.lipper@pixelpark.com) am 21. September 2000:@{ub}


Hi

Wo bekomme ich die geniale Microcosm Musik der CD32 Version her?
Die PC-Version ist grottenschlecht. Gibts die irgendwo als MP3?

Vielen Dank!

@ENDNODE

@NODE "Forum13" "PC mit CD32 vernetzen"
@TOC "MAIN"

@{b}Geschrieben von Mike (WStiefel@t-online.de) am 20. November 2000:@{ub}


Wie kann ich mein geliebtes CD32 mit meinem verhassten PC verbinden?
Über Nullmodemkabel oder so, möglichst ohne diesen Communicator 
den es gibt.

@ENDNODE

@NODE "Forum14" "PC Tastatur am SX32Pro"
@TOC "MAIN"

@{b}Geschrieben von Robert (rkon@gmx.de) am 06. Oktober 2000:@{ub}


Im SX32Pro ist doch ein PC Tastaturadapter eingebaut. In der Anleitung 
steht, daß man da irgendwie ein Kabel verlegen muß. Hat das jemand 
hinbekommen und kann mir helfen?

@ENDNODE

@NODE "Forum15" "suche SX32"
@TOC "MAIN"

@{b}Geschrieben von Mike (WStiefel@t-online.de) am 20. November 2000:@{ub}


Wer hat mir ein SX32, oder kann mir zumindet sagen wo ich eins 
bekommen kann?
Habe nur dieses "sperrige" SX1. Bitte helft mir. 

Zahle auch gut!!!

@ENDNODE

@NODE "Forum16" "Suche SX32pro"
@TOC "MAIN"

@{b}Geschrieben von Micha (radcliffe@gmx.de) am 05. Oktober 2000:@{ub}


Hi LeutZ,

ich suche ein voll funktionstüchtiges SX32pro (möglichst 50MHz und ein 
bissl RAM), vielleicht noch ne AMIGA-Tastatur dazu. Benutze im Moment 
das SX-1, abba die 020 reicht nicht mehr...

Schreibt bitte an die genannte email-Adresse.

Heißen Dank,

MdG 
 
@ENDNODE

@NODE "Forum17" "Workbench-CD-ROM"
@TOC "MAIN"

@{b}Geschrieben von Werner Bittl (werner@backintime.de) am 11. November 2000:@{ub}

 
Hallo!

Im Handel ist eine CD-ROM für CD32 erhältlich, auf der die Workbench 
gebrannt ist.
Hat diese CD-ROM jemand von euch schon in Gebrauch? 
Kann man damit etwas anfangen?

Das Problem ist ja, dass davon nur gelesen werden kann. Z. B. können 
keine ENV-Einträge statt finden. Auch besitzt das CD32 ja nur 2 MB 
CHIP-Ram.
Damit kann man nun wirklich nicht allzu viel anfangen.

Reicht diese CD-ROM evtl. aus, um Spiele aus CD-ROM-Spiele-Sammlungen 
zu starten (wie Epic Amiga Classix I + II) oder Bilder und Mods von 
Aminet-CD-ROMs anzeigen zu lassen bzw. zu starten?

@ENDNODE

@NODE "Forum18" "CD32 & OS3.9"
@TOC "MAIN"

@{b}Geschrieben von CD32-Allianz (CD32-Allianz@gmx.de) am 27. Januar 2001:@{ub}


In den letzten Tagen erreichte mich eine eMail in derer
eine CD32 Userin, diese ein CD32+SX1+8MB+2.5"Toshiba
IDE 3200MB mit OS3.5 besitzt. Seit der Messe nun besitzt
sie das AmigaOS 3.9 dieses sie aber noch nicht auf Ihrem
CD32 installiert hat. Lohnt sich das Update für sie?
Welche Erfahrungswerte habt Ihr mit einem CD32 & OS3.9
sammeln können? 

@ENDNODE

@NODE "Forum19" "cdtv mit festplatte?"
@TOC "MAIN"

@{b}Geschrieben von lars am 28. Januar 2001:@{ub}


gibt es irgendeine mölichkeit im cdtv eine festplatte 
zu betreiben?
controller für einen amiga 500 umbauen? 

@ENDNODE

@NODE "Forum20" "Ein paar Fragen..."
@TOC "MAIN"

@{b}Geschrieben von Ampow (ampow@gmx.net) am 18. Januar 2001:@{ub}


Hallo Cd-32 Freaks!

Hab da mal ein paar Fragen zu dem Teil, ich hoffe, ihr wißt Rat!?

1.) Das Cd-32 hat doch so einen speziellen Chip (Akiko oder so), 
    welche Funktion hat er? Graphix?

2.) Gibts dafür eigendlich Software, die ohne ihn nicht funzt? 
    Wenn ja, welche Spiele sollen das sein?

3.)Irgendeine Idee um auf einem Pc eine bootfähige Cd-32 Cd zu erstellen?
   Scheitert bislang an der Kürzung der Dateinamen vom Pc! Falls jemand 
   eine Lösung mit Sharewarebrennprogrammen über WinUAE verfügt, 
   bitte melden!

Danke!

Ampow 

@ENDNODE

@NODE "Forum21" "Suche PIRATES! für CD32"
@TOC "MAIN"

@{b}Geschrieben von BoingmaX (boing@amigapage.de) am 22. Januar 2001:@{ub}


Siehe Titel ...

@ENDNODE

@NODE "Forum22" "Wendatta für CD32"
@TOC "MAIN"

@{b}Geschrieben von Werner Bittl (werner@backintime.de) am 27. Januar 2001:@{ub}


Die Wendatta-CDROM von 1996 soll ja angeblich auch für CD32 sein.
Steht jedenfalls drauf.

Der Witz ist nur, dass nach Starten des eigentlichen Spiels der
Ladevorgang mit der Meldung "Zuwenig Speicherplatz vorhanden...benötigt 
wird 3 MB" - jetzt mal frei wiedergegeben.

Irgendwie kommt man sich hier etwas verarscht vor. :-(

@ENDNODE

@NODE "Forum23" "Wing Commander CD32"
@TOC "MAIN"

@{b}Geschrieben von Michael (m.mayerhofer@aon.at) am 21. Januar 2001:@{ub}


Hab Wing Commander CD32 auf meinen A1200 installiert.
Es läuft auch einwandfrei, bis auf die Speicherfunktion da kommt 
immer nur einen Fehlermeldung. Gibt es eine Möglichkeit oder ein 
Programm das man die Spielstände auf der Festplatte speichern kann?

Danke im Voraus

Michael

@ENDNODE

@NODE "Forum24" "Worms"
@TOC "MAIN"

@{b}Geschrieben von Stefan Möbius (smoebius@freenet.de) am 22. Januar 2001:@{ub}


Ich habe Probleme mit Worms CD32.
Ich starte das Spiel über den Emulator und es lädt auch ganz normal.
An der Stelle wo die Codeabfrage kommt kann ich nichts über Tastatur
eingeben.
Der Joystick reagiert,aber halt nur für das erste Zeichen. 

Mein Rechner 1200/PPC/060/BVisionPPC/4xIDE Adapter 

@ENDNODE

@NODE "Forum25" "Suche CDTV Logo"
@TOC "MAIN"

@{b}Geschrieben von CD32-Allianz (CD32-Allianz@gmx.de) am 28. Januar 2001:@{ub}


Kann mir jemand das CDTV Logo zuschicken?

@ENDNODE


@NODE "cd32user" "Dies ist die CD32/CDTV User Liste!"
@TOC "MAIN

@{"Rechtliches" link Rechtliches}

@{"Sich in die cd32/CDTV User list eintragen." link Eintrag}
@{"Eingetragene User" link user}

@{"Adresse des Machers" link Macher}
@ENDNODE

@NODE Rechtliches "Rechtliches"

1)
Beim zuschicken erkläre ich mich bereit, alle Punkte an zu erkennen.

2)
Bei nicht Befolgung der hier genannten Punkte ist der Macher der
Liste befugt, gegen diese Person Rechtliches Schritte einzuleiten.
Außerdem behält sich der Macher vor, diese Person aus der liste
zu löschen, falls die Person in der Liste eingetragen sein

3)
Alle Persönlichen Angaben, die sie angeben, können veröffentlicht
werden. Wenn sie dies nicht wollen, geben sie die angaben nicht
an oder weisen sie Darauf hin.

4)
Alle Persönlichen angaben, die hier veröffentlicht werden, dürfen
nicht für Kommerzielle in jeglicher form, darzu gehört auch Werbung,
Zwecke benutzt werden. Bei Nichtbefolgung siehe Punkt 2.

5)
Der Macher der Liste behalt sich vor, Persönliche Angaben zu
veröffentlichen, insbesondere Angaben ohne Vor-, Nachname und
Postleitzahl (PLZ).

6)
Alle, die diese Liste durchschauen, müssen den Punkt 2 und 4 beachten!

7)
Alle Persönlichen angaben ohne Gewähr! Bei Fehlern in den angaben,
ist der Macher der Liste so schnell wie möglich zu Informieren.


Wenn noch fragen sind, dann schicken sie mir eine e-mail oder per Post an:

Henning Schlautmann
Scharpwinkelring 85
44653 Herne

e-mail: 68Kassembler@gmx.de

@{"Der Macher der Liste." link Macher}
@ENDNODE

@NODE Eintrag "Sich in die CD32/CDTV User List eintragen."

Rechtliches:

Mit den abschicken der Persönlichen Daten an Henning Schlautmann erkläre
ich mich bereit, das meine Persönlichen angaben und sonstige angaben,
die ich hier angebe, zu veröffentlichen. Ich trage für die
Richtigen angaben und die möglichen folgen einer Veröffentlichung
die Verantwortung.

Außerdem wenn sie mir die Daten per Post zuschicken ist es Erforderlich
in die erste Zeile zu schreiben:

Hiermit Erkläre ich mich bereit, das meine Persönlichen Angaben
in der CD32/CDTV User Liste Veröffentlicht werden darf.

Weitere Informationen zu @{"Rechtliches" link Rechtliches} unter @{"diesen link." link Rechtliches}

Für eventuelle fragen an:

68Kassembler@gmx.de

Was sie Angeben müssen!

Ihr Vorname
Ihr Nachname
Ihre Postleitzahl (PLZ)
Und in welchen land sie Leben!

Was sie zusätzlich angeben können:

Ihre Vollständige Adresse
Ihre e-mail Adresse
Ihre Internet Seite
Ob sie ein CD32/CDTV besitzten oder ob sie daran nur interessiert sind oder
ob sie sich ein CD32/CDTV kaufen wollen.
Sonstiges


Das ganze dann in eine e-mail schreiben und an:

cd32-User_List@freenet.de

Wenn sie keinen Internet Zugang haben oder Sonstige Probleme auftauchen,
dann schicken sie mir die Angaben per Post.
Meine Adresse ist:

Henning Schlautmann
Scharpwinkelring 85
44653 Herne

@{"Der Macher" link Macher}
@ENDNODE

@NODE User "Eingetragene User"

Es sind momentan 15 User eingetragen.

Wählen sie die Postleitzahl aus, unter der sie nach sehen möchten.

0xxxx Kein Eintrag
1xxxx Kein Eintrag
2xxxx Kein Eintrag
@{"3xxxx" link user3xxxx}
@{"4xxxx" link user4xxxx}
@{"5xxxx" link user5xxxx}
6xxxx Kein Eintrag
7xxxx Kein Eintrag
@{"8xxxx" link user8xxxx}
@{"9xxxx" link user9xxxx}

@{"Aus den Ausland" link useraus}
@ENDNODE

@NODE "user3xxxx"

Matthias Neubauer
Eichsfelder Str. 17
35279 Neustadt
Deutschland

e-mail: mcdee@planet-interkom.de

Besitzt ein CD32 und interessiert sich für das CDTV

@{"Zurück" link user}
@ENDNODE

@NODE user4xxxx

Henning Schlautmann
Scharpwinkelring 85
44653 Herne

e-mail: 68Kassembler@gmx.de

Interessiert sich für das CD32/CDTV


Thorsten Schölzel
Am Scholtenbusch 17
46539 Dinslaken
Deutschland

e-mail: CD32-Allianz@gmx.de

http://home.t-online.de/home/amiga-freak

Interessiert sich für das CD32/CDTV


Ingo Schmitz
Bergstraße 42
49509 Recke
Deutschland

e-mail: Schmitz-Recke@t-online.de

Besitzt CD32


Marcel Maurmann
Reichsstraße 39
42275 Wuppertal
Deutschland

e-mail: marcel.maurmann@t-online.de

Besitzt CDTV

@{"Zurück" link user}
@ENDNODE

@NODE user5xxxx

Ronald Schmitz
Am Südhang 2
58300  Wetter
Deutschland

e-mail: QBRon@gmx.de

Besitzt ein CD32 und interessierst sich für das CDTV.

@{"Zurück" link user}
@ENDNODE

@NODE user8xxxx

Bernhard Aschberger
Kampenwandstr. 35
83301 Traunreut
Deutschland

e-mail: Moon.Child@t-online.de

Besitzt ein CD32

@{"Zurück" link user}
@ENDNODE

@NODE user9xxxx

Jürgen Müller
Allendestr. 83
98574 Schmalkalden
Deutschland

e-mail: mueller-j@t-online.de

Besitzt ein CD32 und interessiert sich für das CDTV.

@{"Zurück" link user}
@ENDNODE

@NODE userAus

Florian Stadler
Geblergasse 33
1170 Wien
Österreich

e-mail: weyland_yutani7@yahoo.com

http://www.vkf.megapage.de

Besitzt das CD32 und CDTV


Christian Kitzler
Ing.-Bachmannstraße 10
4606 WELS
Österreich

e-mail: crisu@liwest.at

Besitzt das CD32


Marc Gutzwiller
Gempenring 25
4147 Aesch
Schweiz

e-mail: Gutzi@åmiganation.de

Besitzt das CD32 und ist interessiert an das CDTV.


Antony Mo
Van Loonstraat 28
6591 HP Gennep
Niederlande

e-mail: awmosoft@hotmail.com

Besitzt das CD32 und CDTV.


Jens-Vagner Andersen
Ostre Langgade 25
8643 Ans By
Denmark

e-mail: jens-vagner@andersen.mail.dk

Besitzt das CD32 und ist interessiert an das CDTV.


Georg Fuchs
Waltendorfer Haupstrasse 98
8042 Graz
Österreich

e-mail: commodore@aon.at

Besitzt ein CD32

Will sich ein CDTV kaufen.

@{"Zurück" link user}
@ENDNODE

@NODE Macher "Der Macher der Liste!"

Meine Adresse ist:

Henning Schlautmann
Scharpwinkelring 85
44653 Herne

e-mail: 68Kassembler@gmx.de

Hier können sie Fragen und/oder hiere Persönlichen angaben schicken.
Bevor sie ihre Persönlichen Angaben schicken beachten sie die
Rechtlichen angelegenheiten! Bei zuschicken ihrer Persönlichen
angaben, erklären sie sich bereit, die Rechtlichen Grundlagen
dieser Liste anzuerkennen!


Wenn sie ihre Persönlichen Angaben zuschicken, dann schreiben
sie es in die erste Zeile:
Hiermit Erkläre ich mich bereit, das meine Persönlichen angaben
Veröffentlicht werden dürfen.

Wenn sie das nicht machen, werden die angaben nicht Veröffentlicht.
@ENDNODE


@NODE "Werbung" "Werbung inserieren - Jetzt erst recht!"
@TOC "MAIN"

@{b}@{u}Werbung inserieren - Jetzt erst recht!@{ub}@{uu}

Leider gab es in letzter Zeit kein geeignetes Medium um eine
Anzeige für und rund um das CD³² & CDTV zu inserieren, das soll 
durch die CD³² Outside geändert werden. Denn hier sprechen Sie
CD³² & CDTV User an, ein besseres Medium gibt es nicht.

Sie dürfen soviel Werbung machen wie Sie können, als einzigste
Gegenleistung müssen Sie uns kostenlos ein CD³² Spiel unserer
Wahl übersenden. @{b}Wir nehmen kein Geld!@{ub}
Mehr verlangen wir nicht um hier in der CD³² Outside Werbung
machen zu dürfen.

@{b}Auch CD³² & CDTV Software-Entwickler dürfen Werbung inserieren!@{ub}
Als Gegenleistung verlangen wir als einzigstes Ihr Software-Produkt
für das Sie werben wollen, dies wird und soll dann zu Testzwecken
eingesetzt werden.

Bitte seien Sie nicht im Glauben, Ihre Anzeige wäre nur 
rausgeschmissenes Geld, so ist es nicht. Es gibt immer noch eine
Menge CD³² & CDTV User. 
Wir selber versuchen die CD³² Outside so gut wie es nur geht zu
vermarkten, was uns auch schon mit Erfolg geglückt ist, denn
die CD³² Outside wird dort erhältlich sein:

- Im CD³²-Corner/powered by CD³²-Allianz
- AmiNet
- AmigaPlus CD-Rom 
- AmigaFuture CD-Rom
- AmiNet CD-Rom

Damit bietet sich uns ein breites Spektrum, wo wir CD³² 
& CDTV User aber auch normale Amiga-User ansprechen können. 


@{b}Auf das es mit Erfolg gekrönt sein wird!@{ub}

@ENDNODE

@NODE "Impressum" "Impressum"
@TOC "MAIN"

@{b}Redaktion & Mithilfe@{ub}

Die CD³² Outside ist ein Amiga-Guide Magazin mit
Ziel, die CD³² User zu erreichen, die keine 
Möglichkeit haben ins Internet zu gelangen.

Die Gestaltung sowie das Erstellen der CD³² Outside
liegt komplett in den Händen der CD³²-Allianz.



@{u}Folgenden Leuten wollen wir für Ihre Mitarbeit danken:@{uu}


- Gernod Schomberg (für die deutsche Übersetzung der Entwicklerunterlagen)

- Henning Schlautmann (für die CD32/CDTV User-Liste sowie den HTML-Versionen
                       der CD32 Outside)

- Stefan Müller (für das Review von Pinball Illusions & Fighting Spirit)

- Robert C. (für das Review von Erben der Erde & Lotus Trilogy)


@{u}desweiteren Danken wir:@{uu}

- allen CD32/CDTV Usern die sich an unserem Forum beteiligt haben.

- jedem der immernoch an das CD32 & CDTV glaubt!

- alle die mich mit Rat und Tat unterstützt haben.



@{b}Aufruf@{ub}

CD³² Outside lebt von der Beteiligung der Leser, von Euch! 
Wenn Ihr einen Beitrag für uns habt, dann zögert nicht lange, sondern 
schickt ihn uns bitte für eine Veröffentlichung zu! Dabei kann es sich 
sowohl um aktuelle News, als auch um Messeberichte, Produkttests, 
Interviews etc. handeln. 
Übrigens müssen Eure Texte nicht unbedingt exklusiv für CD³² Outside sein. 
Falls Ihr sie bereits in anderen Publikationen veröffentlicht habt, genügt 
uns Eure Erlaubnis, sie innerhalb von CD³² Outside weiterzuverbreiten, 
sofern Ihr die Rechte an den Artikeln nicht aufgegeben habt.

Natürlich sind wir auch sehr an Kritik, Anregungen, also an Eurer Meinung 
zu CD³² Outside interessiert.



@{b}Rechtliches@{ub}

CD³² Outside darf PRIVAT frei kopiert werden, solange als Gegenleistung 
(einschl. Datenträger und Porto) nicht mehr als 1,50 Euro bzw. ein 
vergleichbarer Betrag in einer anderen Währung verlangt wird. Eine 
gewerbliche Weiterverbreitung bedarf jedoch der Zustimmung der 
CD³²-Allianz.

Die Zusammenstellung steht unter dem Copyright der CD³²-Allianz.

Die von der CD³² Outside-Redaktion verfassten Artikel stehen unter dem 
Copyright des jeweiligen Autors und dürfen ohne dessen Genehmigung und der 
des leitenden Redakteurs nicht verändert oder republiziert werden. 

Die CD³² Outside-Redaktion behält sich das Recht vor, Beiträge auf Fehler zu 
korrigieren, sinngemäß zu kürzen oder zu republizieren, verpflichtet sich 
jedoch nicht, jeden erhaltenen Beitrag zu veröffentlichen.

Über die Aufnahme von CD³² Outside in weitere Magazine, PD-Serien, auf CD-
ROMs etc. entscheidet der leitende Redakteur der CD³² Outside.



@{b}Unsere Anschrift@{ub}

CD³²-Allianz
c/o Thorsten Schölzel
Am Scholtenbusch 17
46539 Dinslaken

Tel: 02064/ 9 03 74

eMail: CD32-Allianz@gmx.de
Web: http://home.t-online.de/home/amiga-freak

@ENDNODE

@NODE "Vorschau" "Vorschau auf die 4.Ausgabe der CD32 Outside"
@TOC "MAIN"

In der 4.Ausgabe der CD32 Outside werden wir einen
Blick auf die Weiterentwicklung des CDXL-Formates 
"CDXL v2 - The Next Generation" wagen,
welche Vorteile hat es und wie weit ist die Entwicklung,
lesen Sie dieses in der nächsten Ausgabe.

Das Feedback aus der Leserschaft der CD32 Outside wird
besser und grösser, so dass wir noch mehr Reviews sowie
Forumsbeiträge bringen können.

Hoffen wir mal das der Strom an News-Meldungen nicht
abreißt und das es in den nächsten Monaten auch in Sachen 
Spiele-Neuerscheinungen endlich vorran geht. 
Das es tatsächlich noch CD32 & CDTV User gibt,
kann man der CD32/CDTV User-Liste entnehmen. Für diese
Liste möchte ich dem Ideengeber und Betreuer Henning
Schlautmann recht herzlich danken.
Diese Liste gibt auch mir einen Überblick darüber ob
sich meine Mühe lohnt oder nicht.

Ich danke an dieser Stelle allen diese sich an dieser
3.Ausgabe der CD32 Outside beteiligt haben, ohne Euch
hätte es wohl diese Ausgabe nie gegeben, Dankeschön!


Bis zur nächsten Ausgabe,

Euer

Thorsten Schölzel


@ENDNODE



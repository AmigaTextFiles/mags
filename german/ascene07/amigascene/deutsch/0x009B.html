<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
	<TITLE>AmigaScene 0x07 - Effizientes Programmieren</TITLE>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML;CHARSET=iso8859-1">
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#101010" LINK="#BF0000" VLINK="#101010" ALINK="#E04040">
	<TABLE WIDTH="100%" CELLPADDING=3 CELLSPACING=0 BORDER=0>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=TOP WIDTH="80%" HEIGHT=75>
				<A NAME="00" HREF="welcome.html"><IMG SRC="../images/_amiga.gif" WIDTH=125 HEIGHT=48 ALT="[Amiga]" ALIGN=RIGHT BORDER=0></A><A HREF="#99"><IMG SRC="../images/_krumm_lo.gif" WIDTH=37 HEIGHT=29 ALT="[Down]" ALIGN=LEFT BORDER=0></A>
				<BR CLEAR=ALL><BR>
				<TABLE ALIGN=CENTER WIDTH=170 BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=CENTER>
					<A HREF="../deutsch/0x009B.html"><IMG WIDTH=16 HEIGHT=10 SRC="../images/__german.gif" ALT="[ german ]" BORDER=1></A>
				</TD></TR></TABLE>
 			</TD>
			<TD BGCOLOR="#BF0000" VALIGN=TOP ALIGN=RIGHT WIDTH=175>
				<A HREF="welcome.html"><IMG SRC="../images/_scene.gif" WIDTH=110 HEIGHT=47 ALT="[Scene]" ALIGN=LEFT BORDER=0></A>
				<A HREF="0x009A.html"><IMG SRC="../images/_gerade_li.gif" WIDTH=22 HEIGHT=41 ALT="{" BORDER=0></A><A HREF="0x009C.html"><IMG SRC="../images/_gerade_re.gif" WIDTH=23 HEIGHT=41 ALT="}" BORDER=0></A>
			</TD>
		</TR>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=MIDDLE ALIGN=CENTER>
				<CENTER>&nbsp;<BR>

					<IMG WIDTH=155 HEIGHT=25 SRC="../images/_workshop_.gif" ALT="[Workshop]">&nbsp;<BR><BR>

					<TABLE WIDTH="90%" BORDER=0>
						<TR><TD ALIGN=CENTER><FONT SIZE="-1">

| <A HREF="0x009B.html">Effizientes Programmieren</A> |

						</FONT></TD></TR>
					</TABLE>&nbsp;<BR>
				</CENTER>
			</TD>
			<TD BGCOLOR="#BF0000" VALIGN=TOP ALIGN=CENTER WIDTH=175 ROWSPAN=2>
				<CENTER>&nbsp;<BR>
					<IMG SRC="../images/__.gif" HEIGHT=1 WIDTH=175 ALT=" "><BR> 
					<A HREF="0x0093.html"><IMG WIDTH=77  HEIGHT=25 SRC="../images/_cover.gif"     ALT="[Cover]"     BORDER=0></A><BR>
					<A HREF="0x0094.html"><IMG WIDTH=117 HEIGHT=25 SRC="../images/_editorial.gif" ALT="[Editorial]" BORDER=0></A><BR>
					<A HREF="0x0095.html"><IMG WIDTH=85  HEIGHT=25 SRC="../images/_inhalt.gif"    ALT="[Inhalt]"    BORDER=0></A><BR>
					<A HREF="0x0096.html"><IMG WIDTH=70  HEIGHT=25 SRC="../images/_news.gif"      ALT="[News]"      BORDER=0></A><BR>
					<A HREF="0x0097.html"><IMG WIDTH=131 HEIGHT=25 SRC="../images/_hardware.gif"  ALT="[Hardware]"  BORDER=0></A><BR>
					<A HREF="0x0098.html"><IMG WIDTH=121 HEIGHT=25 SRC="../images/_software.gif"  ALT="[Software]"  BORDER=0></A><BR>
					<A HREF="0x009B.html"><IMG WIDTH=135 HEIGHT=25 SRC="../images/_workshop.gif"  ALT="[Workshop]"  BORDER=0></A><BR>
					<A HREF="0x009C.html"><IMG WIDTH=73  HEIGHT=25 SRC="../images/_spiele.gif"    ALT="[Spiele]"    BORDER=0></A><BR>
					<A HREF="0x009F.html"><IMG WIDTH=91  HEIGHT=25 SRC="../images/_special.gif"   ALT="[Special]"   BORDER=0></A><BR>
					<A HREF="0x00A0.html"><IMG WIDTH=112 HEIGHT=25 SRC="../images/_feedback.gif"  ALT="[Feedback]"  BORDER=0></A><BR>
					<A HREF="0x00A1.html"><IMG WIDTH=46  HEIGHT=25 SRC="../images/_etc.gif"       ALT="[Etc]"       BORDER=0></A><BR>
				<BR></CENTER>
			</TD>
		</TR>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=TOP ALIGN=LEFT>

<BR><H1 ALIGN=LEFT><FONT FACE="Arial"><B>Effizientes Programmieren - Teil 6</B></FONT></H1>&nbsp;

<BR><FONT SIZE="+1">Als Abschlu&szlig; dieses Kurses besch&auml;ftigen wir
uns noch mit den verschiedensten Sortiermethoden. Dabei werden wir die
wichtigsten Verfahren behandeln und uns auch Gedanken &uuml;ber ihr
Laufzeitverhalten machen. </FONT><BR>

<BR><CENTER><A NAME="01" HREF="#00"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#02"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR>Es gibt wohl ein Thema, das bei keiner Abhandlung &uuml;ber effiziente
Algorithmen fehlen darf: die Sortierverfahren. Gerade auf diesem Gebiet
wurden langj&auml;hrige Forschungen betrieben und in keinem anderen Bereich
sind die Geschwindigkeitsvorteile eines guten Algorithmusses gegen&uuml;ber
einem schlechten so deutlich geworden wie bei den Sortierverfahren.
Prinzpiell gibt es eine wahre Unzahl an verschiedenen Methoden,
Schl&uuml;sseln aus einer unsortierten Liste a[N] in sortierter Form
anzureihen, einige davon sind jedoch entweder zu uneffizient oder allzu
exotisch um in diesem Kurs ber&uuml;cksichtigt werden zu k&ouml;nnen.
Trotzdem wollen wir mit den elementaren Sortierverfahren beginnen und uns
anschlie&szlig;end mit etwas diffizileren besch&auml;ftigen.<BR>

<BR><CENTER><A NAME="02" HREF="#01"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#03"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR>Unser erster Algorithmus nennt sich Sortieren durch Auswahl und geht
nach der folgenden, recht einfachen Methode vor: es werden alle Elemente
der Reihe nach durchgegangen und in einer Variablen vermerkt, wo das
kleinste zu finden ist. Nach dem Durchlauf wird dieses Element mit dem
ersten vertauscht (mit a[0]). Somit befindet sich das kleinste Element
schon einmal am Anfang der zu sortierende Liste. Nun suchen wir im der
restlichen Feld a[1]..a[N-1] wieder den kleinsten Eintrag und vertauschen
ihn mit dem Feld a[1]. Auf diese Weise fahren wir N-1 mal fort, denn dann
sind alle Elemente in die richtige Reihenfolge gebracht und unsere Aufgabe
beendet. Das Programm zu &quot;Sortieren durch Auswahl&quot; finden Sie in
Listing 1. Leider ist dieser Suchvorgang nicht besonders schnell, da das
Verfahren zwei inneinander geschachtelte Schleifen besitzt - das kostet
nat&uuml;rlich Zeit. Einen anderen Weg geht &quot;Bubblesort&quot;. Hier
wird die Liste durchlaufen und dabei jedes Feld a[i] mit seinem Nachfolger
a[i+1] verglichen. Ist dabei a[i]&gt;a[i+1] werden die beiden Elemente
vertauscht. Dadurch wandert das gr&ouml;&szlig;te Element der Liste mit dem
ersten Durchlauf an das Ende des Feldes. Der letzte Feldeintrag a[N-1]
mu&szlig; also im weiteren nicht mehr betrachtet werden. Die &uuml;brigen
Elemente a[0]..a[N-2] m&uuml;ssen allerdings noch nicht sortiert sein, da
sich ihre Positionen jeweils maximal um eins nach links bewegt haben
k&ouml;nnen. Deshalb werden diese wiederum auf dieselbe Weise durchlaufen.
Dies wird dann sooft wiederholt, bis keine Vertauschungen von
Nachbarelementen mehr n&ouml;tig waren, denn dann ist die Liste sicher
sortiert. Bubblesort k&ouml;nnen Sie in Listing 2 finden. Auch hier kommen
zwei geschachtelte Schleifen vor, die &auml;u&szlig;ere wird jedoch im
allgemeinen fr&uuml;her terminieren als jene beim Sortieren durch Auswahl,
weshalb das Bubblesort auch meist schneller geht. Es gibt jedoch auch
F&auml;lle, wo auch Sortieren durch Auswahl seine Berechtigung hat,
n&auml;mlich dann, wenn viele Datenmengen beim Vertauschen von Elementen
bewegt werden m&uuml;ssen. Beim Sortieren durch Auswahl werden n&auml;mlich
immer maximal N Vertauschungen durchgef&uuml;hrt, w&auml;hrend beim
Bubblesort unter Umst&auml;nden viele Elemente lange herumgeschoben werden,
bis sie am richtigen Platz gelandet sind.<BR>

<BR>Bubblesort ist trotzdem ein sehr popul&auml;res Verfahren, obwohl es in
seinem Laufzeitverhalten nur als ziemlich schlecht bezeichnet werden kann.
Allerdings ist es leicht zu implementieren und kann in speziellen
F&auml;llen sogar sehr schnell sein, n&auml;mlich genau dann, wenn die
Liste schon recht gut sortiert ist und durch ein paar Vertauschungen
schnell fertigsortiert werden kann. Seinen Namen hat Bubblesort
&uuml;brigens dadurch erhalten, da&szlig; die gr&ouml;&szlig;ten Elemente
immer wie Luftblasen im Wasser an das Ende der Liste
&quot;aufsteigen&quot;.<BR>

<BR>Sortieren durch Suchen und Bubblesort sind - wie gesagt - recht
einfache, elementare Suchverfahren. Wenn Sie schnell mal ein Suchverfahren
brauchen und die Geschwindigkeit keine allzugro&szlig;e Rolle spielt, haben
diese Verfahren durchaus ihre Daseinsberechtigung. F&uuml;r
&quot;kritischere&quot; Aufgaben mit gr&ouml;&szlig;eren Datenmengen sollte
aber eher einer der folgenden Algorithmen Anwendung finden.<BR>

<BR><CENTER><A NAME="03" HREF="#02"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#04"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR>Das - f&uuml;r unseren Kenntnisstand - am einfachsten zu verstehende
Sortierverfahren ist Heapsort. Sie erinnern sich sicherlich noch an die
Datenstruktur Heap (Halde) aus dem dritten Teil unseres Kurses.
Gleichg&uuml;ltig welches Element man zuletzt auf den Heap gelegt hat, man
bekommt bei einer Leseoperation immer das kleinste zur&uuml;ckgeliefert.
Wenn wir die Daten also als Heap vorliegen haben, k&ouml;nnen wir sie recht
einfach sortieren. Wir holen uns das erste Element vom Heap und legen es an
die Position a[0], das zweite kommt nach a[1] usw. Am Ende ist a[0]..a[N-1]
fertig sortiert. Dieses Verfahren arbeitet sehr effizient. Wenn man die
Daten also in einem Heap gespeichert hat, bietet sich die Verwendung von
Heapsort geradezu an. Leider ist das nicht immer m&ouml;glich, weshalb wir
nun zu den beiden letzten (und leistungsf&auml;higsten) Algorithmen kommen:
Quicksort und Mergesort.<BR>

<BR><CENTER><A NAME="04" HREF="#03"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#05"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR>Beide haben zwei Dinge gemeinsam: sie folgen derselben Strategie und
erfordern zum vollst&auml;ndigen Verst&auml;ndnis einiges an
Abstraktionsverm&ouml;gen. Letzteres liegt in ihrem rekursiven Aufbau
begr&uuml;ndet. Grunds&auml;tzlich m&uuml;ssen Sie sich folgendes immer vor
Augen halten: die Algorithmen funktionieren! Das klingt auf den ersten
Blick banal, wenn sie das nicht tun w&uuml;rden, w&auml;ren sie eine
genauere Betrachtung wohl kaum wert. Trotzdem ist diese Erkenntnis wichtig.
Sie l&auml;&szlig;t n&auml;mlich den Schlu&szlig; zu, da&szlig;, wenn sich
der Algorithmus selbst aufruft (mit einer Teilfolge der gesamten Liste als
Argument), die angegebene Folge von Elementen sortiert ist. F&uuml;r den
Anf&auml;nger, der mit Rekursionen nicht sehr vertraut ist, stellt das oft
ein gro&szlig;es Problem dar. Der Algorithmus verwendet sich n&auml;mlich
selbst mit dem erwarteten Ergebnis noch bevor er vollst&auml;ndig
ausformuliert wurde. Wenn man jedoch bei jedem rekursiven Aufruf davon
ausgeht, da&szlig; der Algorithmus das erwartete Ergebnis liefert, ist eine
weitere Verfolgung der Routine nicht weiter schwierig. Sie sollten sich
diese Betrachtungsweise auch angew&ouml;hnen, wenn Sie eigene rekursive
Algorithmen entwickeln. Nehmen Sie bei jedem rekursiven Aufruf an, ihr
Algorithmus tut mit dem angegebenen Teil genau das, was Sie von ihm
erwarten, und das obwohl Sie ihn noch nicht fertig haben. Das hilft Ihnen,
den bei rekursiven Programmen immer schwer zu durchschauenden
Programmflu&szlig; besser zu &uuml;berblicken. Kommen wir jetzt aber
zur&uuml;ck zum Thema. Quicksort ist wohl das bekannteste Sortierverfahren.
Es wurde 1962 von C.A.R. Hoare ver&ouml;ffentlicht und hat seinen Namen
nicht zu unrecht. Es folgt der sogenannten Divide-and-Conquer-Strategie,
einer &uuml;berhaupt sehr popul&auml;ren und vielf&auml;ltig einsetzbaren
Idee. Divide-and-Conquer ist eine englische &Uuml;bersetzung des
lateinischen Originals &quot;divide et impera&quot;. Dieser Begriff wurde
schon von C. Julius Caesar gepr&auml;gt, der die Divide-and- Conquer
Strategie im Krieg gegen die Gallier einsetzte (&quot;de bello
gallico&quot;). Er n&uuml;tzte die Teilung Galliens in verschiedene
St&auml;mme aus. Diese waren sich dann untereinander so uneinig, da&szlig;
sie sich zu keiner Gesamtmacht gegen die r&ouml;mischen Truppen
zusammenschlie&szlig;en konnten. Caesar hatte es also nicht mit einem recht
gro&szlig;en Problem, sondern nur mit mehreren l&ouml;sbaren Teilproblemen
zu tun.<BR>

<BR>Auch in der Informatik verfolgt man gerne denselben Gedanken. Ein
ber&uuml;hmtes Beispiel ist die fortschreitende Modularisierung von
Programmen. Man teilt das Problem in mehrere Teilprobleme auf, diese werden
dann von unterschiedlichen Moduln gel&ouml;st. Diese Module einzeln sind
recht einfach zu entwickeln, das gesamte Programm aber in einem St&uuml;ck
geradezu unm&ouml;glich. Sie sehen also, die Grundregeln moderner
Programmiertechniken gehen sogar schon bis zur alten R&ouml;merzeit
zur&uuml;ck.<BR>

<BR><CENTER><A NAME="05" HREF="#04"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#06"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR>Gehen wir nun aber genauer auf die Arbeitsweise von Quicksort ein. Wenn
die lineare Liste nur ein oder gar kein Element enth&auml;lt, wird gleich
abgebrochen, denn in diesen F&auml;llen gibt es nichts zu sortieren.
Andernfalls wird zuerst ein beliebiges Element k, das sogenannte
Pivotelement, aus der Folge a[0]..a[N-1] ausgew&auml;hlt. Dann wird die
Liste in zwei Teilfolgen F1 und F2 aufgeteilt, wobei F1 alle Elemente
enth&auml;lt, die kleiner als k sind, und F2 alle gr&ouml;&szlig;eren.
Danach wird der Quicksort-Algorithmus auf jede der beiden Folgen ebenfalls
angewandt. Dadurch werden diese vollst&auml;ndig sortiert (Quicksort
funktioniert!). Anschlie&szlig;end werden die Folgen in der Reihenfolge F1,
k, F2 zusammengeh&auml;ngt - fertig.<BR>

<BR>Problematisch ist jedoch die Implementierung der Aufteilung (Divide) in
zwei Teilfolgen. Die meisten Quicksort-Implementationen gehen dabei aber
einen trickreichen Weg. Anstatt aus der urspr&uuml;nglichen Folge
a[0]..a[N-1] durch umst&auml;ndliche Kopieroperationen zwei weitere zu
machen wird die Folge a selber in zwei Teile geteilt. Man ben&uuml;tzt dazu
&uuml;blicherweise zwei Indices - einen auf den Anfang der
urspr&uuml;nglichen Folge (l f&uuml;r links) und einen auf das Ende (r).
F&uuml;r den ersten Aufruf von Quicksort sind diese 0 bzw. N-1. Dann wird l
solange hinaufgez&auml;hlt, bis a[l]&gt;k. Somit wissen wir, da&szlig; alle
a's bis exklusive a[l] teil von F1 sind. a[l] selber geh&ouml;rt aber nach
F2, da es gr&ouml;&szlig;er als k ist. Danach wird r solange dekrementiert,
bis a[r]&lt;k ist. a[r+1] bis a[N-1] geh&ouml;ren also nach F2, a[r] selbst
aber nach F1. Deshalb wird a[l] mit a[r] vertauscht und die beiden Elemente
stehen wieder richtig. Dies wird solange praktiziert, bis l&gt;r, dann ist
die Aufteilung perfekt. In diesem Fall stehen alle Elemente von F1 links
von l und alle Elemente von F2 rechts von l. An die Position l selbst wird
nun noch k reingesetzt, das ja zwischen F1 und F2 liegen soll.
Schlu&szlig;endlich werden die beiden Folgen durch rekursive Aufrufe von
Quicksort sortiert. Listing 3 stellt die eben beschriebene Version von
Quicksort als fertiges C-Programm dar. Wie Sie sicher wissen, geh&ouml;rt
Quicksort in der Form der ANSI-C-Funktion qsort() zu den Standardfunktionen
ihrer C-Bibliothek. Trotzdem kann es nicht schaden &uuml;ber die
Funktionsweise dieses Sortieralgorithmusses Bescheid zu wissen. Als letztes
der Sortierverfahren wollen wir uns noch mit Mergesort besch&auml;ftigen,
das - wie Quicksort - der Divide-and-Conquer-Strategie folgt.<BR>

<BR><CENTER><A NAME="06" HREF="#05"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_li.gif" ALT=" " BORDER=0></A><A HREF="#99"><IMG WIDTH=13 HEIGHT=26 SRC="../images/_schraeg_re.gif" ALT=" " BORDER=0></A></CENTER>&nbsp;

<BR>Mergesort - im Deutschen oft auch als Sortieren durch Verschmelzen
bezeichnet - wurde 1945 von John von Neumann entwickelt. Es macht sich die
Tatsache zunutze, da&szlig; das Verschmelzen von Folgen schneller geht als
dessen Sortierung. Mergesort sortiert auf folgende geniale Weise: Die
Urspr&uuml;ngliche Liste a wird auch hier in zwei m&ouml;glichst gleich
gro&szlig;e Teilfolgen F1 und F2 aufgeteilt. Als Teilungspunkt wird dabei
genau das mittlere Element genommen. Beachten Sie aber, da&szlig; hier
nicht wie bei Quicksort gilt, da&szlig; alle Elemente in F1 kleiner als k
und alle Elemente in F2 gr&ouml;&szlig;er als k sind. Die Teilfolgen
enthalten einfach irgendwelche Schl&uuml;sseln. Danach wird der
Mergesort-Algorithmus (er funktioniert!) auf beide Folgen angewandt. Wir
gehen davon aus, da&szlig; diese danach sortiert sind. Nun nehmen wir die
beiden Folgen und verschmelzen sie wieder zu einer einzigen, wobei wir die
Sortierung beibehalten. Unser Problem reduziert sich beim Sortieren durch
Verschmelzen, wie leicht zu erraten, auf das Verschmelzen von zwei
sortierten Folgen F1 und F2 zu einer sortierten Folge F. Dies ist aber
leicht zu bewerkstelligen. Wir ben&ouml;tigen dazu zwei Indices - i und j.
i zeigt dabei auf das erste Element in F1 und j in das erste Element in F2.
Nun wird F1[i] mit F2[j] verglichen. Ist F1[i] kleiner wird dieses in F
eingetragen und i um eins erh&ouml;ht, andernfalls tragen wir F2[j] in F
ein und inkrementieren j. So verfahren wir bis entweder i oder j das Ende
der jeweiligen Folge &uuml;berschreitet. In diesem Falle h&auml;ngen wir
noch alle Elemente der jeweilgen anderen Folge an F an und sind fertig. Die
Verschmelzung l&auml;&szlig;t sich also bequem und schnell in einem
Durchgang durch die beiden Teilfolgen bewerkstelligen.<BR>

<BR>Wenn Sie sich das Mergesort-Programm in Listing 4 genauer ansehen,
werden Sie bemerken, da&szlig; Mergesort die gegebene Liste einmal in zwei
Teilfolgen unterteilt. Jede von diesen wird dann wieder in zwei weitere
unterteilt usw. Diese Unterteilung geht soweit, da&szlig; jede Folge nur
mehr ein einziges Element enth&auml;lt, das nicht mehr aufgeteilt werden
kann. Diese Folgen der L&auml;nge eins kann man jede f&uuml;r sich
prinzpiell als sortiert betrachten. Die Sortierung erfolgt beim Mergesort
also im Prinzip implizit durch wiederholtes Aufteilen der Folgen. Diese N
&quot;sortierten&quot; Einser-Folgen werden dann zu N/2 Folgen der
L&auml;nge zwei verschmolzen, wobei jede dieser Zweier-Folgen in sich
sortiert bleibt. Aus den N/2 Zweierfolgen werden durch weitere
Verschmelzungen N/4 Viererfolgen bis schlu&szlig;endlich die letzten beiden
N/2-Folgen zu einer sortierten N-Folge verschmolzen werden. Die letzten
beiden Sortierverfahren sind sicherlich recht kompliziert, aber auch die
schnellsten. Obwohl Quicksort beispielsweise im schlechtesten Fall (worst
case) genauso schlecht sein kann wie Sortieren durch Suchen, n&auml;mlich
genau dann, wenn zuf&auml;llig das gr&ouml;&szlig;te Element der Liste als
Pivotelement gew&auml;hlt wird. Trotzdem ben&ouml;tigt es im Durchschnitt
(average case) viel weniger Zeit als sein einfacher Konkurrent. Das Studium
der letzten beiden Algorithmen lege ich Ihnen auch dann ans Herz, wenn Sie
nicht vorhaben, jemals ein anderes Sortierverfahren als das
&quot;eingebaute&quot; qsort zu benutzen. Sie zeigen vorbildlich auf, wie
relativ einfach schwierige Probleme durch geniale Programmiertechniken und
Rekursion gel&ouml;st werden k&ouml;nnen. Denn wie lautet ein bekannter
Ausspruch: &quot;Iteration ist menschlich, Rekursion ist
g&ouml;ttlich!&quot;<BR>

			<BR>
			</TD>
		</TR>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=TOP ALIGN=LEFT>
				<P ALIGN=RIGHT>

					<A HREF="as-redax.html#thomas">Thomas &Ouml;llinger</A>
					&nbsp;&nbsp;&nbsp;
					<A HREF="../deutsch/0x009B.html"><IMG WIDTH=16 HEIGHT=10 SRC="../images/__german.gif" ALT="[ german ]" VSPACE=0 HSPACE=0 BORDER=1></A>
					&nbsp;&nbsp;&nbsp;
					<BR>

				</P>
				<BR><TABLE BORDER=0 CELLPADDING=8 CELLSPACING=0 ALIGN=CENTER WIDTH="90%">
				<TR VALIGN=TOP ALIGN=LEFT><TD WIDTH="50%">

<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="0x0033.html">Workshop Teil 1</A><BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="0x004D.html">Workshop Teil 2</A><BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="0x0065.html">Workshop Teil 3</A><BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="0x0079.html">Workshop Teil 4</A><BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="0x0089.html">Workshop Teil 5</A><BR>


				</TD><TD WIDTH="50%">

<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="../images_07/list_6-1.c">Listing 6-1</A> (ASCII;1KB)<BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="../images_07/list_6-2.c">Listing 6-2</A> (ASCII;1KB)<BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="../images_07/list_6-3.c">Listing 6-3</A> (ASCII;1KB)<BR>
<IMG WIDTH=10 HEIGHT=10 SRC="../images/_ball.gif" ALT="-"> <A HREF="../images_07/list_6-4.c">Listing 6-4</A> (ASCII;1KB)<BR>

				</TD></TR>
				</TABLE>
			</TD>
			<TD BGCOLOR="#BF0000" VALIGN=TOP ALIGN=CENTER> &nbsp; 
			</TD>
		</TR>
		<TR>
			<TD BGCOLOR="#FFFFFF" VALIGN=MIDDLE ALIGN=LEFT>
				<A HREF="#00"><IMG SRC="../images/_krumm_hi.gif" WIDTH=37 HEIGHT=29 BORDER=0 ALT="[Up]"></A>
				<A NAME="99"><FONT COLOR="#FFFFFF">&nbsp;</FONT></A>
			</TD>
			<TD BGCOLOR="#BF0000" VALIGN=BOTTOM ALIGN=RIGHT>
				<A HREF="0x009A.html"><IMG SRC="../images/_gerade_li.gif" WIDTH=22 HEIGHT=41 ALT="{" BORDER=0></A><A HREF="0x009C.html"><IMG SRC="../images/_gerade_re.gif" WIDTH=23 HEIGHT=41 ALT="}" BORDER=0></A>
			</TD>
		</TR>
	</TABLE>
</BODY>
</HTML>

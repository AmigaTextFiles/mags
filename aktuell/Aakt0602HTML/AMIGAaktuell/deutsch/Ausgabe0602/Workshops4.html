<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Workshops</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000AA" ALINK="#000066" VLINK="#000066">
<TABLE width="100%" border="0" cellpadding="3" cellspacing="0">
<TR>
<TD BGCOLOR="#000000">
<A HREF="Workshops3.html"><IMG SRC="../menu/links.png" BORDER="0" WIDTH="15" HEIGHT="15" ALT="&lt;&lt;"></A>
<A HREF="Workshops.html"><IMG SRC="../menu/hoch.png" BORDER="0" WIDTH="15" HEIGHT="15" ALT="Inhalt"></A>
<A HREF="Workshops5.html"><IMG SRC="../menu/rechts.png" BORDER="0" WIDTH="15" HEIGHT="15" ALT="&gt;&gt;"></A>
<FONT COLOR="#FFFFFF">
Workshops
</FONT>
</TD><TD ALIGN="RIGHT" BGCOLOR="#000000">
<A HREF="index.html" TARGET="_top"><IMG SRC="../menu/inhalt.png" BORDER="0" WIDTH="36" HEIGHT="15" ALT="Inhalt"></A>
</TD></TR>
</TABLE>
<BR>
<H2>4. Hintergrund: Das Handbuch - diesmal online (von Michael Christoph)</H2>
<P>
Wurde im letzten Teil besonderes Augenmerk auf das gedruckte Handbuch und
dessen Anforderungen gelegt, soll diesmal eine weitere Art der Anleitung
genauer unter die Lupe genommen werden: die Online-Hilfe. Dieser Teil zeigt
zwar im besonderen die Programmierumsetzung, liefert aber auch f&uuml;r jeden
Interessierten etwas.
</P>
<P>
Unter der Online-Hilfe versteht man die Hilfe, die direkt vom Programm aus
aufgerufen werden kann. Sie sollte ebenso Standard sein, wie ein normales
Handbuch (egal ob gedruckt oder digital) und auch die im letzten Teil
angesprochenen Punkte erf&uuml;llen.
</P>
<P>
Die Hilfe sollte idealerweise sofort zur Textstelle verzweigen, an der die
Informationen zum aktuellen Kontext zu finden sind. Nur dann ist diese Art
der Hilfe &uuml;berhaupt sinnvoll. Sowohl AmigaGuide als auch HTML unterst&uuml;tzen
das gezielte Anzeigen einer Passage und sollen daher nachfolgend genauer
betrachtet werden. Mittels des HTML-Datatypes ist au&szlig;erdem kein extra
Browser notwendig (auch wenn seit AmigaOS 3.5 AWeb bereits im
Betriebssystem vorhanden ist). Solange HTML nur nach seiner urspr&uuml;nglichen
Konzeption eingesetzt wird, ist dieser Datatype v&ouml;llig ausreichend.
</P>
<P>
Man kann die normale Anleitung so gestalten, dass sie direkt im Programm
auch als Hilfe eingebunden werden kann, oder man erstellt eine zus&auml;tzliche
Datei. Wichtig dabei ist nur, dass sofort der Text zum aktuellen Kontext
angezeigt wird. Diese Hilfe kann man beispielsweise grob auf die einzelnen
Fenster gliedern oder sehr fein auf die einzelnen Gadgets.
</P>
<P>
Wenden wir uns daher dem Aufbau der Online-Hilfe zu.
</P>
<P>
Im AmigaGuide-Format sollte jedes Kapitel und auch die Unterkapitel in
einem eigenen Node vorliegen. Und so wie das Inhaltsverzeichnis auf jeden
Node verweist, kann auch von jeder anderen Stelle im Text darauf verwiesen
werden. Der Node-Verweis kann noch mittels einer optionalen Zeilennummer
genauer innerhalb des Kapitels platziert werden.
</P>
<BR>
<TABLE CELLPADDING="0" CELLSPACING="0">
<TR><TD VALIGN="TOP">AmigaGuide -&nbsp;</TD><TD VALIGN="TOP">Vorteil :&nbsp;</TD><TD VALIGN="TOP">Amiga-eigenes Format, Datatype-Unterst&uuml;tzung&nbsp;</TD></TR>
<TR><TD VALIGN="TOP">&nbsp;</TD><TD VALIGN="TOP">Nachteil:&nbsp;</TD><TD VALIGN="TOP">keine direkte Bildereinbindung,&nbsp;</TD></TR>
<TR><TD VALIGN="TOP">&nbsp;</TD><TD VALIGN="TOP">&nbsp;</TD><TD VALIGN="TOP">geringe Layoutm&ouml;glichkeiten&nbsp;</TD></TR>
<TR><TD VALIGN="TOP">&nbsp;</TD><TD VALIGN="TOP">&nbsp;</TD><TD VALIGN="TOP">&nbsp;</TD></TR>
</TABLE>
<P>
Bei HTML gliedert man allgemein nur die oberen Kapitel in einzelne Dateien.
In diesem Fall ist es hilfreich, wenn zu Beginn der HTML-Datei die
einzelnen Unterkapitel aufgez&auml;hlt werden, so dass durch einen einfachen
Klick dorthin gesprungen werden kann. Nat&uuml;rlich ist das Inhaltsverzeichnis
mit allen Kapiteln zu verwenden, wobei die Unterkapitel direkt an die
entsprechenden Stellen in der HTML-Datei zeigen sollten.
</P>
<BR>
<TABLE CELLPADDING="0" CELLSPACING="0">
<TR><TD VALIGN="TOP">HTML -&nbsp;</TD><TD VALIGN="TOP">Vorteil : direkte Bilderunterst&uuml;tzung, Layoutm&ouml;glichkeiten&nbsp;</TD></TR>
<TR><TD VALIGN="TOP">&nbsp;</TD><TD VALIGN="TOP">Nachteil: extra Browser oder HTML-Datatype notwendig&nbsp;</TD></TR>
<TR><TD VALIGN="TOP">&nbsp;</TD><TD VALIGN="TOP">&nbsp;</TD></TR>
</TABLE>
<P>
Besonders wichtig ist auch eine Indexseite, auf der die wichtigsten
Begriffe rund um das Programm aufgef&uuml;hrt sind und die direkt auf die
entsprechenden Zeilen in den Beschreibungstexten verweisen.
</P>
<P>
Da es allerdings auch Konvertierungsprogramme gibt, die AmigaGuide-
Anleitungen in eine HTML-Datei umwandeln k&ouml;nnen, spricht nichts dagegen,
beide Arten von Online-Hilfe mitzuliefern. Dadurch kann der Leser
selbst entscheiden, welche Art der Hilfe er bevorzugt.
</P>
<HR>
<P>
Ein Grundger&uuml;st f&uuml;r eine AmigaGuide-Datei hat den folgenden Aufbau (bitte
einen Textanzeiger oder -editor zur Ansicht verwenden):
</P>
<TABLE><TR><TD BGCOLOR="#e0e0e0"><PRE>
@DATABASE &quot;Anleitung.guide&quot;
@INDEX &quot;INDEX&quot;

@NODE &quot;MAIN&quot; &quot;Inhaltsverzeichnis&quot;
@{&quot;Kapitel 1&quot;     LINK &quot;Kapitel1&quot;}
@{&quot;  Kapitel 1.1&quot; LINK &quot;Kapitel1_1&quot;}
@{&quot;  Kapitel 1.2&quot; LINK &quot;Kapitel1_2&quot;}
@ENDNODE

@NODE &quot;Kapitel1&quot; &quot;Kapitel 1&quot;
Einleitungstext ...
@ENDNODE

@NODE &quot;Kapitel1_1&quot; &quot;Kapitel 1.1&quot;
Text ...
@ENDNODE

@NODE &quot;Kapitel1_2&quot; &quot;Kapitel 1.2&quot;
Text ...
@ENDNODE

@NODE &quot;INDEX&quot; &quot;Index&quot;
@{&quot;Schl&uuml;sselwort&quot; LINK &quot;Verweisziel&quot;}
@ENDNODE
</PRE></TD></TR></TABLE>
<HR>
<P>
Ein Grundger&uuml;st f&uuml;r eine HTML-Datei hat den folgenden Aufbau:
</P>
<TABLE><TR><TD BGCOLOR="#e0e0e0"><PRE>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;Anleitung zu ...&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;P&gt;
&lt;H1&gt;Kapitel 1&lt;/H1&gt;
&lt;UL&gt;
  &lt;LI&gt;&lt;A HREF="#kapitel1_1"&gt;Kapitel 1.1&lt;/A&gt;&lt;/LI&gt;
  &lt;LI&gt;&lt;A HREF="#kapitel1_2"&gt;Kapitel 1.2&lt;/A&gt;&lt;/LI&gt;
&lt;/UL&gt;
Einleitungstext ...
&lt;/P&gt;

&lt;P&gt;
&lt;A NAME="kapitel1_1"&gt;&lt;H1&gt;Kapitel 1.1&lt;/H1&gt;&lt;/A&gt;
Text ...
&lt;/P&gt;

&lt;P&gt;
&lt;A NAME="kapitel1_2"&gt;&lt;H1&gt;Kapitel 1.2&lt;/H1&gt;&lt;/A&gt;
Text ...
&lt;/P&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE></TD></TR></TABLE>
<HR>
<P>
Die einfachste Art, die Anleitung anzuzeigen, ist der direkte Aufruf von
MultiView. Das nachfolgende Beispiel zeigt die vollst&auml;ndige Funktion,
die sehr flexibel ist. So wird neben MultiView auch die &auml;ltere Ausgabe
AmigaGuide gesucht, und es wird auch &uuml;berpr&uuml;ft, ob die Anleitung im
aktuellen oder im System-Hilfe-Verzeichnis vorhanden ist. Im Fehlerfall
wird ein entsprechender Text ausgegeben (z.B. mittels EasyRequest() in
einer normalen GUI-Anwendung). Ansonsten wird der gefundene Anzeiger
mittels Execute() (oder alternativ mittels SystemTagList()) gestartet.
Das Programm hat keine Kontrolle &uuml;ber die Anzeige, l&auml;uft aber parallel zum
Anzeigefenster weiter, da es mittels &quot;run&quot; als Hintergrundprozess gestartet
wird. Allerdings fehlt auch die M&ouml;glichkeit, sofort eine bestimmte Sektion
der Datei anzuzeigen. Daher eignet sich diese Art der Hilfe eher zum
Anzeigen des normalen Handbuches.
</P>
<TABLE><TR><TD BGCOLOR="#e0e0e0"><PRE>
BOOL ZeigeAnleitung(const STRPTR guide)
{
  BOOL res = FALSE;

  UBYTE kommand[80] = &quot;&quot;;
  UBYTE guidefile[50];
  BPTR lock;

  /* pr&uuml;fen, ob die Anleitung vorhanden ist */
  strcpy(guidefile,guide);
  if((lock = Lock(guidefile,SHARED_LOCK)))
  {
    UnLock(lock);
  }
  else
  {
    sprintf(guidefile,&quot;LOCALE:Help/%s&quot;,guide);
    if((lock = Lock(guidefile,SHARED_LOCK)))
    {
      UnLock(lock);
    }
    else guidefile[0]='\0';
  }

  if(guidefile[0])
  {
    /* pr&uuml;fen, ob ein Anzeigeprogramm vorhanden ist */
    if((lock = Lock(&quot;SYS:Utilities/MultiView&quot;,SHARED_LOCK)))
    {
      UnLock(lock);
      sprintf(kommand,&quot;RUN &gt;NIL: SYS:Utilities/MultiView %s&quot;,guidefile);
    }
    else if((lock = Lock(&quot;SYS:Utilities/AmigaGuide&quot;,SHARED_LOCK)))
    {
      UnLock(lock);
      sprintf(kommand,&quot;RUN &gt;NIL: SYS:Utilities/AmigaGuide %s&quot;,guidefile);
    }

    if(kommand[0])
    {
      Execute(kommand,NULL,NULL);
      res = TRUE;
    }
    else printf(&quot;Fehler\n&quot;
                &quot;Guide-Anzeiger sind nicht vorhanden;\n&quot;
                &quot;SYS:Utilities/MultiView oder\nSYS:Utilities/AmigaGuide.\n&quot;);
  }
  else printf(&quot;Fehler\n&quot;
              &quot;Anleitung '%s'\n&quot;
              &quot;ist nicht (im aktuellen Verzeichnis) vorhanden.\n&quot;,guide);

  return( res );
}
</PRE></TD></TR></TABLE>
<HR>
<P>
Das n&auml;chste Beispiel zeigt die Benutzung der amigaguide.library, wie sie
seit AmigaOS 2.x existiert. Dabei wird nur die einfache, blockierende
Anwendung vorgestellt. Das hei&szlig;t, die Hilfe muss erst geschlossen werden,
damit das Programm fortgesetzt wird. Man hat allerdings genaue Kontrolle
&uuml;ber die Anzeige. &Uuml;ber den nichtblockierenden Aufruf OpenAmigaGuideAsync()
kann das Programm ganz normal parallel zur Hilfe weiterlaufen. Es besteht
dann jederzeit die M&ouml;glichkeit, die Hilfe wieder nach vorn zu holen oder
eine andere Stelle anzuzeigen. &Uuml;ber den Eintrag nag_Node der NewAmigaGuide-
Struktur kann direkt die anzuzeigende Seite (Default Main) vorgegeben
werden.
</P>
<TABLE><TR><TD BGCOLOR="#e0e0e0"><PRE>
struct Library *AmigaGuideBase;

BOOL ZeigeAnleitung(const STRPTR guide)
{
  BOOL res = FALSE;
  struct NewAmigaGuide nag = { NULL };
  AMIGAGUIDECONTEXT handle;
  BPTR lock;

  if((AmigaGuideBase = OpenLibrary(&quot;amigaguide.library&quot;,33)))
  {
    if((lock = Lock((UBYTE*)guide,SHARED_LOCK)))
    {
      UnLock(lock);

      if((handle = OpenAmigaGuide(&amp;nag,NULL)))
      {
        /* synchrone Verarbeitung; */
        /* kehrt erst nach Beenden von AmigaGuide zur&uuml;ck */

        CloseAmigaGuide(handle);
        res = TRUE;
      }
      else printf(&quot;Anzeige durch AmigaGuide fehlgeschlagen.\n&quot;);
    }
    else printf(&quot;Guide-Datei '%s' fehlt.\n&quot;,guide);

    CloseLibrary(AmigaGuideBase);
  }
  else printf(&quot;amigaguide.library V33 fehlt.\n&quot;);

  return( res );
}
</PRE></TD></TR></TABLE>
<HR>
<P>
Mittels NewDTObject() kann jeder Amiga-Programmierer die Hilfe direkt per
Datatype in sein Programm einbinden. Dabei ist man vom Format her am
flexibelsten, da lediglich ein passender Datatype vorhanden sein muss.
Allerdings hat man auch hierbei wieder keine M&ouml;glichkeit, direkt eine
Stelle in der Anleitung anzuzeigen.
</P>
<P>
Das folgende Ger&uuml;st zeigt, wie der Datentyp ermittelt werden kann und die
Datei eingelesen wird. Die Weiterverarbeitung als Gadget wird allerdings
nicht mehr ausgef&uuml;hrt. Diese Art ist wieder nichtblockierend.
</P>
<TABLE><TR><TD BGCOLOR="#e0e0e0"><PRE>
struct Library *DataTypesBase;

BOOL ZeigeAnleitung(const STRPTR guide)
{
  BOOL res = FALSE;
  struct DataType       *dtn;
  struct DataTypeHeader *dth;
  Object                *obj;
  BPTR                   lock;

  if((DataTypesBase = OpenLibrary(&quot;datatypes.library&quot;,39)))
  {

    /* existiert die angegebene Datei &uuml;berhaupt */
    if((lock = Lock((UBYTE*)guide,SHARED_LOCK)))
    {
      /* Dateityp ermitteln */
      if((dtn = ObtainDataTypeA(DTST_FILE,(APTR)lock,NULL)))
      {
        dth = dtn-&gt;dtn_Header;

        if(dth-&gt;dth_GroupID == GID_DOCUMENT ||  /* = AmigaGuide */
           dth-&gt;dth_GroupID == GID_TEXT)        /* = HTML */
        {
          res = TRUE;
        }
        else printf(&quot;Falscher Dateityp der Anleitung.\n&quot;);

        ReleaseDataType(dtn);
      }


      if(res)
      {
        /* Datei einlesen */
        if((obj = NewDTObject((APTR) guide,
                               DTA_SourceType, DTST_FILE,
                               /* DTA_GroupID, GID_xxx, */
                               /* wenn ein bestimmter Typ gefordert wird */
                               TAG_DONE)))
        {
          /* ... Datatype-Objekt mittels Gadget zur Anzeige verwenden */

          DisposeDTObject(obj);
        }
        else printf(&quot;Kein passender Datatype zur Anzeige vorhanden.\n&quot;);
      }

      UnLock(lock);
    }
    else printf(&quot;Anleitungsdatei '%s' fehlt.\n&quot;,guide);

    CloseLibrary(DataTypesBase);
  }
  else printf(&quot;datatype.library V39 fehlt.\n&quot;);

  return( res );
}
</PRE></TD></TR></TABLE>
<HR>
<P>
Eine ganz andere Richtung soll noch kurz angesprochen werden.
</P>
<P>
Seit OS 3.0 (V39) unterst&uuml;tzen die Boopsi-Gadgets die GM_HELPTEST-Methode,
um dem Programm mitzuteilen, zu welchem Gadget der Benutzer eine Hilfe
w&uuml;nscht. Window-bezogen sind die Tags WA_HelpGroup und WA_HelpGroupWindow
daf&uuml;r zust&auml;ndig, dass eine Nachricht der Art IDCMP_GADGETHELP versandt
wird. Wie allerdings der fromme Wunsch des Benutzers nach einer Hilfe vom
Programm letztendlich umgesetzt wird, daf&uuml;r hatte Commodore keine L&ouml;sung
mehr parat. Hier drei sehr einfache M&ouml;glichkeiten:
</P>
<UL>
<LI> eine separate Zeile im Fenster reservieren, in der der Hilfetext
  angezeigt wird (z.B. mittels Text() oder besser in einem String- oder
  ReadOnly-Button-Gadget, das sich dann auch um das Clipping k&uuml;mmert)
</LI>
<BR><LI> die Screenzeile benutzen, um den Hilfetext anzuzeigen
</LI>
<BR><LI> einen EasyRequester mit dem Hilfetext anzeigen
</LI>
</UL>
<BR>
<TABLE CELLPADDING="0" CELLSPACING="0">
<TR><TD VALIGN="TOP">In allen drei F&auml;llen kann in Verbindung mit einem Timer die Anzeige&nbsp;</TD></TR>
<TR><TD VALIGN="TOP">auch zeitlich beschr&auml;nkt werden (BuildEasyRequest() + FreeSysRequest()&nbsp;</TD></TR>
<TR><TD VALIGN="TOP">im dritten Fall).&nbsp;</TD></TR>
<TR><TD VALIGN="TOP">&nbsp;</TD></TR>
</TABLE>
<P>
Diese Art eignet sich nat&uuml;rlich besonders gut, um eine Kurzhilfe zum
aktuellen Gadget oder Fenster anzuzeigen. Allerdings ist es wirklich nur
eine Kurzhilfe, da platzbedingt meist sehr wenig Raum zur Verf&uuml;gung steht.
Des weiteren muss diese Hilfe direkt im Programm eingebaut werden oder
besser in einer externen Catalog-Datei untergebracht werden.
</P>
<P>
Alle Varianten haben ihre Vor- und Nachteile. So setzt die Datatypes-
Methode voraus, dass das Programm unter OS 3.x l&auml;uft, was allerdings heute
wohl der Standard sein d&uuml;rfte. Die Execute-Methode ist zwar sehr einfach
und robust, erlaubt allerdings keine Kontrolle &uuml;ber die Anzeige und eignet
sich eher zum Anzeigen der normalen Anleitung.
</P>
<P>
Letztendlich muss der Programmierer anhand der Zielgruppe und OS-Version
absch&auml;tzen, welche L&ouml;sung die f&uuml;r seinen Fall passendste ist.
</P>
<P>
Mit diesen Worten soll die kleine dreiteilige Geschichte zum Handbuch
abgeschlossen werden.
</P>
<P><B>Michael Christoph &lt;<A HREF="mailto:michael@meicky-soft.de">michael@meicky-soft.de</A>&gt;</B></P>
<P ALIGN="RIGHT">
<A HREF="Workshops3.html"><IMG SRC="../menu/pfeil_links.png" BORDER="0" WIDTH="20" HEIGHT="20" ALT="&lt;&lt;"></A>
 <A HREF="Workshops5.html"><IMG SRC="../menu/pfeil_rechts.png" BORDER="0" WIDTH="20" HEIGHT="20" ALT="&gt;&gt;"></A>
</P>
</BODY>
</HTML>

@DATABASE "Default"
@NODE "Main" "AMIGA aktuell 03/2002 - Inhalt"
@TOC "MAIN"
A M I G A   a k t u e l l  -  Ausgabe 03/2002  (Stand: 04.03.2002)

M   (c) 2002 Carsten Schröder (E-Mail: aakt@aakt.de)

I N H A L T

G  @{"Vorwort" LINK "Vorwort"}

A  Intern
   ------
    @{"Redaktion & Mithilfe" LINK "Intern1"}
a   @{"FAQ (Häufig gestellte Fragen zu AMIGA aktuell)" LINK "Intern2"}
    @{"Aufruf" LINK "Intern3"}
k   @{"Distribution" LINK "Intern4"}
    @{"AMIGA-aktuell-Diskussions-Mailingliste" LINK "Intern5"}
t   @{"Rechtliches" LINK "Intern6"}

u  AMIGA-aktuell-Forum
   -------------------
e   @{"Die Frage des Monats - wir möchten eure Meinung erfahren" LINK "Forum1"}
    @{"Reaktion auf Guido Bruns' Leserbrief in Ausgabe 02/2002 (von Kai Weger)" LINK "Forum2"}
l   @{"Einschätzung zur Lage des Amiga (von Günter Raab)" LINK "Forum3"}

l  Workshops / Hintergrundberichte / Buchvorstellungen
   ---------------------------------------------------
    @{"Workshop: Programmierung in C++ - Teil 4 (von Thomas Richter)" LINK "Workshops1"}
    @{"Workshop: Nachbearbeitung von Scans (von Michael Christoph)" LINK "Workshops2"}
    @{"Update: So senkt ihr eure Telekom-Rechnung!" LINK "Workshops3"}

   Tests und Erfahrungsberichte
   ----------------------------
    @{"Kleine Helfer für den Amiga-Alltag (von Christian Aichinger)" LINK "Tests1"}
    @{"Kurztest: TV-Kartensoftware für Amithlon »AmiTV« (von Thomas Nosutta)" LINK "Tests2"}

   AMIGA-aktuell-Spieleteil (von Oliver Tacke und Jürgen Theiner)
   --------------------------------------------------------------
    @{"Vorwort" LINK "Spiele1"}
    @{"Aufruf" LINK "Spiele2"}
    @{"News" LINK "Spiele3"}
    @{"Hinter den Kulissen: Die Probleme beim Konvertieren von Spielen" LINK "Spiele4"}
    @{"Vorabbericht: 3D-Shooter »Quake 2«" LINK "Spiele5"}
    @{"Vorabbericht: Weltraumsimulation »Elite TNK«" LINK "Spiele6"}
    @{"Oldies but Goldies" LINK "Spiele7"}
    @{"Schlusswort" LINK "Spiele8"}

   Neues zum AmigaNG
   -----------------
    @{"Neues Executive Update von AMIGA-CEO Bill McEwen" LINK "AMIGANG1"}
    @{"Nokia wird offizieller Partner von AMIGA, Inc." LINK "AMIGANG2"}
    @{"AMIGA, Inc. stellt weitere leitende Mitarbeiter ein" LINK "AMIGANG3"}
    @{"Zusammenfassung der »AMIGA & Microsoft«-Ereignisse (von C. Schröder)" LINK "AMIGANG4"}
    @{"Kommentar zur »AMIGA & Microsoft«-Thematik (von Jürgen Theiner)" LINK "AMIGANG5"}
    @{"Neue Informationen zum AmigaONE" LINK "AMIGANG6"}

   @{"Der Zwischenruf (von Ralf Driesner)" LINK "Zwischenruf"}

   Diverse Amiga-News
   ------------------
    @{"Extreme Computing kündigt Amiga-Rechner auf x86-Basis an" LINK "Diverses1"}
    @{"»GlowIcon Collection 2« bei Schatztruhe erschienen" LINK "Diverses2"}
    @{"Neuigkeiten von Haage & Partner" LINK "Diverses3"}
    @{"Neuigkeiten von der Amiga Arena" LINK "Diverses4"}
    @{"Neuigkeiten von Airsoft Softwair" LINK "Diverses5"}
    @{"Kurzmeldungen (von Oliver Tacke)" LINK "Diverses6"}

   @{"Abschließend" LINK "Schluss"}

@ENDNODE

@NODE "Vorwort" "Vorwort"
@TOC "MAIN"

Vorwort
-------

+++ AMIGA am Messestand von Microsoft - bahnt sich eine Kooperation an? +++
AMIGA präsentiert Nokia als OEM-Partner +++ Eyetech demonstriert lauffähige
Version des AmigaONE und veröffentlicht Produktdetails +++

Willkommen damit zur neuen Ausgabe von AMIGA aktuell.

Der vergangene Monat könnte in die Geschichte des Amiga eingehen. Ohne
Übertreibung zu einer Nebensächlichkeit geworden ist die an sich
spektakuläre Meldung, dass der weltgrößte Mobiltelefonhersteller Nokia das
AmigaDE auf seinem neuen Multimediagerät "Mediaterminal" vorinstallieren
wird.
Diese und alle anderen Amiga-Neuigkeiten hat jedoch folgender Satz des
AMIGA-Mitarbeiters Gary Peake völlig überlagert: "Microsoft hat uns
gebeten, das AmigaDE und einige Entwicklerprogramme auf verschiedenen
Geräten an ihrem Stand vorzuführen."
Gemeint ist die Computermesse "Embedded Systems Show", die Mitte März in
San Francisco stattfindet. Ob sich damit eine Kooperation zwischen den
beiden Unternehmen ankündigt, werden wir wohl erst auf dieser Veranstaltung
erfahren - vielleicht an einem von Amiga-Usern belagerten Microsoft-
Stand...
Alle Informationen sowie mehrere Kommentare zu diesem Thema findet
ihr in dieser Ausgabe von AMIGA aktuell.


In eigener Sache:

* Die Leserzuschriften zu unserer Umfrage über die von euch genutzten
  Betriebssysteme werden wir erst in der nächsten Ausgabe veröffentlichen.
  Bis dahin könnt ihr noch an dieser Aktion teilnehmen. Schreibt einfach an
  aakt@aakt.de


Zu den regelmäßigen Aufrufen:

* An dieser Stelle eine Bitte: Jeder Artikelschreiber freut sich über
  Lob, aber auch über konstruktive Kritik, und wird durch sie motiviert.
  Scheut euch also bitte nicht, eure Meinung zu den verschiedenen Beiträgen
  zu äußern, entweder, indem ihr direkt an die Autoren schreibt, oder aber
  an AMIGA aktuell (aakt@aakt.de).

* Wir suchen ständig Mitarbeiter, die regelmäßig, unregelmäßig oder
  einmalig Beiträge zu AMIGA aktuell beisteuern wollen. Inhaltlich sind
  einer Mitarbeit kaum Grenzen gesetzt. Wer Interesse hat, sollte sich
  an aakt@aakt.de oder christian@aakt.de wenden.


Viel Spaß jetzt bei dieser Ausgabe,

euer

Carsten Schröder

@ENDNODE

@NODE "Intern1" "Intern"
@TOC "MAIN"

Intern
------

1. Redaktion & Mithilfe

Redaktionelle Mitarbeiter mit festem Aufgabenbereich bzw. Rubrik:

Leitender Redakteur                         Carsten Schröder <aakt@aakt.de>
Stellvertretender Chefredakteur     Christian Aichinger <christian@aakt.de>
Spieleteil                    Oliver Tacke & Jürgen Theiner <games@aakt.de>
Kurzmeldungen                                 Oliver Tacke <oliver@aakt.de>
Der Zwischenruf                         Ralf Driesner <global-dries@gmx.de>
Hauptübersetzer                  Gernod Schomberg <G.Schomberg@t-online.de>
Weitere Redaktionsmitglieder      Karl-Heinz Bader <charly-ham@t-online.de>
(siehe unten, Hinweis *)                     Markus Castro <CastroM@gmx.de>
                                 Michael Christoph <michael@meicky-soft.de>
                                     Uwe Pannecke <Uwe.Pannecke@t-online.de
Erstellung HTML-Version               Thomas Rapp <thomas-rapp@t-online.de>
Assistenz Website / Formulare   Stephan Manske <aakt@stephan.manske-net.de>

*) Die aktivsten Artikelschreiber eines Kalenderhalbjahres, die keinen
   festen Aufgabenbereich haben, werden jeweils für die nächsten sechs
   Monate in die Stammredaktion aufgenommen. Als Kriterien hierfür gelten
   Anzahl und Umfang der Artikel sowie deren Qualität. Dies ist als eine
   (nur gerechte) Belohnung für diejenigen gedacht, die besonders stark an
   AMIGA aktuell mitwirken, aber nicht die Betreuung einer kompletten
   Rubrik übernehmen möchten.


Freie Mitarbeiter dieser Ausgabe (in alphabetischer Reihenfolge):

* Günter Raab
* Kai Weger
* Thomas Nosutta
* Thomas Richter

und alle, die an dieser Stelle vergessen wurden...


Wir suchen ständig weitere Teammitglieder, die bereit sind, eine (neue oder
bestehende) AMIGA-aktuell-Rubrik oder eine andere größere Aufgabe zu
übernehmen. Auch über freie Mitarbeiter freuen wir uns.


Vielen Dank auch an alle Amiga-Entwickler und -Firmen, die uns
Informationen zu ihren Produkten sowie Testexemplare geschickt haben.

@ENDNODE

@NODE "Intern2" "Intern"
@TOC "MAIN"

2. FAQ (Häufig gestellte Fragen zu AMIGA aktuell)

Das AMIGA-aktuell-FAQ

Zusammensteller :   Christian Aichinger (christian@aakt.de)
Herausgeber     :   Carsten Schröder (aakt@aakt.de)
Copyright       :   freely distributable (Freeware)
Version         :   $VER: Version 0.0.4 deutsche Ausgabe vom 25.02.2001
Bezugsquelle    :   http://www.aakt.de


Vorbemerkung

Das AMIGA-aktuell-FAQ (FAQ = frequently asked questions = Häufig gestellte
Fragen) ist dazu da, um der Redaktion von AMIGA aktuell "den Kopf frei zu
halten" und natürlich um Deine Fragen so schnell und so einfach wie möglich
zu beantworten. Also bevor Du Fragen an Carsten Schröder oder mich stellst,
lies Dir zuerst dieses Dokument gründlich durch. Dieses Dokument enthält
zum Teil Fragen, die eigentlich noch nie gestellt wurden. Nach meiner
Meinung sind aber viele dieser "erfundenen" Fragen durchaus wert gestellt
und auch beantwortet zu werden. Bist Du der Meinung, daß in diesem FAQ
wichtige Fragen bzw. Antworten fehlen oder Du Vorschläge hast, wie man das
FAQ verbessern könnte, dann schicke bitte eine Mail an christian@aakt.de .
Das FAQ wird dann unverzüglich erweitert.


1. Allgemeine Fragen

F: Was ist AMIGA aktuell?

A: AMIGA aktuell ist ein deutsches Infotainment-Magazin, das sich
hauptsächlich mit der Computerplattform "Amiga" (http://www.amiga.com)
beschäftigt. In AMIGA aktuell werden Neuigkeiten, Workshops, Testberichte
und noch vieles andere veröffentlicht. AMIGA aktuell erscheint in einer
HTML- und AmigaGuide-Version und wird dem interessierten Leser kostenlos
zur Verfügung gestellt. Es wird weiterhin eine englischsprachige
(internationale) Version angeboten. AMIGA aktuell erscheint monatlich und
normalerweise immer in der ersten Woche des Monats. Die internationale
Ausgabe erscheint ca. drei Wochen später und ist nur im HTML-Format
erhältlich.

F: Wie bekomme ich AMIGA aktuell?

A: Es gibt mehrere Möglichkeiten, AMIGA aktuell zu beziehen. Die zwei
wichtigsten sind:

- Von der Homepage (http://www.aakt.de). Hier befindet sich die Online-
Ausgabe von AMIGA aktuell. Die aktuelle Ausgabe kann als LHA-Archiv geladen
werden. Zu finden ist dort auch ein Archiv mit älteren Ausgaben.

- Aus dem Aminet: Im Verzeichnis docs/mags befinden sich fast alle Ausgaben
von AMIGA aktuell. Auch die aktuelle Ausgabe wird so schnell wie möglich
auf den Aminet-Server geladen.

Unter der AMIGA-aktuell-Rubrik "Intern/Distribution" können weitere
Bezugsquellen, aber auch Informationen zum Abonnement gefunden werden.


2. Fragen zum Artikelschreiben

F: Ich möchte einen Artikel schreiben. Muß ich dafür HTML oder AmigaGuide
beherrschen?

A: Nein. Wenn du einen Artikel schreibst, sollte der Text im ASCII-Format
vorliegen. Die Konvertierung des Textes übernehmen fleißige Mitarbeiter von
AMIGA aktuell. Wenn Du diesen Mitarbeitern das Leben etwas leichter machen
möchtest, kannst du darauf achten, daß die Zeilenlänge nicht mehr als 75
Zeichen beträgt. Noch besser wäre es, wenn sich jeder Absatz in nur einer
Zeile befindet (also unbegrenzte Anzahl Zeichen pro Zeile und Absatz). Wenn
Du mit dem Artikel fertig bist, überprüfe bitte noch mal die
Rechtschreibung. Mach am besten vorher einen Tag "Pause" und lies Dir den
Text dann noch mal durch oder frag jemanden aus Deinem Bekannten-
/Verwandtenkreis, ob derjenige den Text noch mal überprüfen würde. Meisten
lassen sich auf diese Weise immer noch einige Fehler finden. Artikel werden
selbstverständlich auch noch mal von Carsten Schröder und/oder den
Übersetzern korrekturgelesen.

F: Muß/Kann ich meine Texte für die internationale Ausgabe in Englisch
verfassen/übersetzen?

A: Das AMIGA-aktuell-Team besteht unter anderem aus mehreren fleißigen
Übersetzern. Wenn Du Dir allerdings die Übersetzung des Textes selbst
zutraust, kannst Du das natürlich machen. Wir würden uns über die
Arbeitserleichterung jedenfalls sehr freuen. Die Übersetzung ist aber
keinesfalls Pflicht.

F: Ich möchte meinen Artikel mit einigen Grafiken veranschaulichen. In
welchem Format soll ich die Grafiken abspeichern?

A: Grafiken im High- und Truecolor-Format (15/16/24bit) müssen im JPEG-
Format vorliegen. Die Qualität sollte auf 75-80 Prozent verringert werden.
Andere Grafiken (<=8bit) müssen im PNG-Format gespeichert werden. Die
Auflösung der Grafiken sollte nicht mehr als 800x600 Pixel betragen. Die
Dateinamen der Grafiken sollten, mit Rücksicht auf englischsprachige Leser,
englische Bezeichnungen erhalten. Zum Beispiel nicht "voreinsteller.jpg"
sondern "settings.jpg" oder "preferences.jpg". Werden mehrere Screenshots
verwendet sollten diese in der entsprechenden Reihenfolge durchnummeriert
werden (z.B. ArtEffekt1.jpg, ArtEffekt2.png, etc.).

F: Gibt es zusätzliche Dinge zu beachten?

A: Ja. Werden Screenshots im Text verwendet, sollten diese nach Möglichkeit
von der englischen Version der Software gemacht werden. Außerdem
sollte, falls bekannt, eine europäische und/oder deutsche Bezugsquelle
angegeben werden.


3. Fragen zum Abonnement

F: Ist es möglich, die AMIGA-aktuell-Specials zu abonnieren ohne das
Magazin zu beziehen?

A: Nein. Die Verteilerliste für das Magazin und die Specials wird nicht
getrennt geführt. Betrachte die AMIGA-aktuell-Specials als eine Art Bonus.

F: Ich würde gerne die AmigaGuide-Version und die HTML-Version abonnieren.
Die AmigaGuide-Ausgabe landet früher in meinem Postfach aber die HTML-
Ausgabe läßt sich angenehmer bzw. auch auf meinem PC lesen. Wenn ich jetzt
beide Ausgaben abonniere, ist es möglich, die Grafiken nur einmal zu
bekommen?

A: Ja, die Grafiken werden nur einmal verschickt. Es sollte aber folgendes
beachtet werden: Wenn beide Ausgaben (HTML und AmigaGuide) abonniert
wurden, werden dir auch immer die Specials doppelt geschickt.

F: Mein E-Mail-Programm hat Probleme beim Dekodieren des AMIGA-aktuell-
Archivs. Woran liegt das?

A: Du verwendest ein älteres E-Mail-Programm, das nicht mit "base64"-
kodierten Daten klar kommt. Besorg Dir eine neuere Version oder verwende
ein anderes E-Mail-Programm. Wenn Du das nicht möchtest, kannst du im
Aminet auch sehr viele Tools finden, die diese "base64"-kodierten Daten
dekodieren können.

F: Aber warum wird kein Amiga-Format zum Kodieren des AMIGA-aktuell-Archivs
verwendet?

A: Es gibt kein Amiga-Format für diese Art der kodierten Daten (genauso
wenig wie es ein PC- oder Macintosh-Format dafür gibt). Es ist eine Frage
der Aktualität deines verwendeten E-Mail-Programms. Jedes neuere (Amiga-)
E-Mail-Programm kann E-Mails im "base64"-Format dekodieren. Wende dich bei
solchen Problemen lieber an den Autor.

F: Ich habe auf meinem PC keinen LhA-Entpacker. Gibt es die AMIGA-aktuell-
Archive auch ZIP-komprimiert?

A: Bislang nicht, da LhA das Standard-Amiga-Komprimierungsformat ist.
Allerdings gibt es auch für Windows diverse LhA-Entpacker, unter anderem
auch im Aminet.


4. Sonstige Fragen

F: Ich habe mir gerade AMIGA aktuell geladen, bekomme aber keine Grafiken
angezeigt. Was mache ich falsch?

A: AMIGA aktuell wird als AmigaGuide- und als HTML-Ausgabe veröffentlicht.
Je nachdem, um welche Version es sich handelt, sind folgende Dinge zu
beachten:

AmigaGuide-Ausgabe:

Du benötigst einen PNG- und einen JPEG-Datatype. Erst seit AmigaOS 3.5 wird
ein JPEG-Datatype mitgeliefert (aber kein Datatype für PNG-Grafiken).
Besorge dir einen Datatype aus dem Aminet (z.B. WarpPNG). Es ist außerdem
zu beachten, daß sich die Grafiken im selben Verzeichnis wie das
AmigaGuide-Dokument befinden müssen.
Besitzer des MagicPacks, das zusammen mit einem Amiga von Escom gekauft
werden konnte, können auch den JPEG-Datatype aus der "Personal Paint V6.4"-
Distribution verwenden. Dieser befindet sich auf der "Personal Paint
Datendiskette" in der Schublade "JPEG".

HTML-Ausgabe:

Moderne Amiga-Webbrowser können das PNG- und JPEG-Format bei korrekter
Installation problemlos anzeigen. Falls nicht, kann es sein, daß für die
Grafik-Anzeige auf Datatypes zurückgegriffen wird. In dem Fall gilt das
gleiche wie für die AmigaGuide-Ausgabe. Die Grafiken müssen sich außerdem
im Unterverzeichnis "img" befinden.

Als Beispiel die deutsche AMIGA-aktuell-Ausgabe 0101 (Januar 2001):
Die Grafiken müssen nach "deutsch/Ausgabe0101/img/" kopiert werden.
Für die internationale AMIGA-aktuell-Ausgabe 1200 (Dezember 2000) müssen
die Grafiken nach "international/edition1200/img/" kopiert werden.

F: Nanu, das FAQ ist ja schon zu Ende? Ich habe noch eine wichtige Frage,
die leider nicht beantwortet wurde. Wen kann ich deswegen fragen?

A: Schicke eine Mail an mich (christian@aakt.de) oder Carsten Schröder
(aakt@aakt.de).

@ENDNODE

@NODE "Intern3" "Intern"
@TOC "MAIN"

3. Aufruf

AMIGA aktuell lebt von der Beteiligung der Leser, von Euch!
Wenn Ihr einen Beitrag für uns habt, dann zögert nicht lange, sondern
schickt ihn uns bitte für eine Veröffentlichung zu! Dabei kann es sich
sowohl um aktuelle News, als auch um Messeberichte, Produkttests,
Interviews etc. handeln.
Übrigens müssen Eure Texte nicht unbedingt exklusiv für AMIGA aktuell sein.
Falls Ihr sie bereits in anderen Publikationen veröffentlicht habt, genügt
uns Eure Erlaubnis, sie innerhalb von AMIGA aktuell weiterzuverbreiten,
sofern Ihr die Rechte an den Artikeln nicht aufgegeben habt.

Natürlich sind wir auch sehr an Kritik, Anregungen, also an Eurer Meinung
zu AMIGA aktuell interessiert.


Aufruf an alle Programmierer und innovativen Amiga-Firmen:

Haben Sie Interesse, in einem der bekanntesten Amiga-Online-Magazine,
beinahe kostenlos für Ihr(e) Produkt(e) zu werben?
Dann stiften Sie für das AMIGA-aktuell-Gewinnspiel doch einen oder mehrere
Preise! Jedes Produkt wird mit dem von Ihnen gewünschten Text vorgestellt.
Als Händler haben Sie die Möglichkeit, Ihr Unternehmen besser
bekanntzumachen.

Die AMIGA-aktuell-Redaktion ist auch an Testmustern von Amiga-Produkten
aller Art interessiert.


AMIGA aktuell ist per Post ->  Carsten Schröder
                               Helmoltstraße 10
                               37081 Göttingen
                               Deutschland

oder per E-Mail ->             aakt@aakt.de
oder per Fax ->                089/2443-31176

erreichbar. Den Spieleteil betreffende Mails sind direkt an den zuständigen
Redakteur Andreas Falkenhahn (Andreas.Falkenhahn@gmx.de) zu richten.
Anregungen zum Design der AMIGA-aktuell-Homepage sollten direkt an Stephan
Manske (aakt@stephan.manske-net.de) geschickt werden, Bug-Reports zur HTML-
Version an Thomas Rapp (thomas-rapp@t-online.de).

@ENDNODE

@NODE "Intern4" "Intern"
@TOC "MAIN"

4. Distribution

Viele Wege führen zu AMIGA aktuell:

Zur Zeit sind die Diskettenmagazine

* NoCover (Herausgeber: Kilian Servais, http://www.apc-tcp.de)
* Fireball (Herausgeber: Rainer Thieke, http://fireball.webjump.com)

zur Veröffentlichung von AMIGA aktuell berechtigt.

Achtung: In einigen der Diskmags werden die in AMIGA aktuell enthaltenen
Grafiken aus Platzgründen nicht oder nur teilweise veröffentlicht.


Darüber hinaus gibt es eine Reihe weiterer Möglichkeiten, an AMIGA aktuell
zu kommen:


* Über das WWW: Auf der offiziellen AMIGA-aktuell-Website
  http://www.aakt.de lassen sich sowohl die monatlichen Ausgaben als auch
  wichtige Amiga-Meldungen abrufen.
  Auf http://www-users.rwth-aachen.de/Marko.Koscak/aakt/index.html
  erscheint kurz nach Versand der AmigaGuide-Version von AMIGA aktuell eine
  'Express-HTML-Version' unseres Magazins. Dies ist als Service für
  Abonnenten der HTML-Ausgabe gedacht, die AMIGA aktuell sofort nach
  Fertigstellung lesen möchten. Die reguläre HTML-Version erscheint in der
  Regel ein bis zwei Tage danach.


* per E-Mail-Abo: Wer AMIGA aktuell regelmäßig bei Erscheinen automatisch
  zugeschickt bekommen möchte, kann auf der AMIGA-aktuell-Website
  (http://www.aakt.de) ein kostenloses Abonnement einrichten. Anschließend
  wird AMIGA aktuell jeweils zum Anfang eines Monats Base64(Mime)-kodiert
  und LhA-gepackt zugeschickt. Außerdem gibt es bei wichtigen Ereignissen
  Sonderausgaben bzw. Newsletter.
  Eine Abbestellung ist jederzeit über unsere Website möglich.


* über das Aminet: AMIGA aktuell ist auch im Aminet (und mit entsprechender
  zeitlicher Verzögerung auf den Aminet-CDs) zu finden, und zwar im
  Verzeichnis docs/mags unter AaktMMJJHTML.lha (HTML-Ausgabe) bzw.
  AaktMMJJGuide.lha (AMIGAGuide-Ausgabe), wobei "MM" den Monat und "JJ" das
  Jahr darstellt. Seit Ausgabe 03/98 liegen die Grafiken in einem Extra-
  Archiv (AaktGFXMMJJ.lha) vor.
  Bei Eingabe von "Aakt" in einem Aminet-Suchprogramm werden alle
  verfügbaren AMIGA-aktuell-Ausgaben aufgeführt.


* über folgende Mailboxen (geordnet nach Tel.-Vorwahl):

  - DEMIGOD, Modem: 0201-8761103, ISDN: 0201-8761104

  - Focus, Brett: MAILINGLISTEN/AMIGA-AKTUELL, Modem: 0209-797600,
    Modem/ISDN (wird automatisch erkannt): 0209-797876, 0209-797789

  - Karsoft, Modem: 0345-8051181 (tägl. 22:30 bis 0:00, Fr & Sa bis 1:00)

  - TOP, Brett: Database/Filebaenke/AMIGA-Files/AMIGA-Aktuell,
    Modem: 0345/299992, ISDN: 0345/299993 (Sammelrufnummern)

  - Force, Brett: 05-SUPPORT/05-MAGS/02-AMIGA_AKTUELL, Modem: 04152-839480,
    ISDN: 04152-841358, 04152-841357 (für Hamburger User zum Ortstarif)

  - TOPSCOPE, Brett: 01-FILE-AREA/01-AMIGA/05-DOKUMENTE/MAGAZINE,
    Modem: 0421-5978718, 0421-5978731, ISDN: 0421-5978789

  - CCS-BASE, Brett: Amiga-Ecke (eigenes Menü mit den jeweils letzten fünf
    Ausgaben, ältere in der File-Area 'AMIGA aktuell'; Online-
    Teilnahmemöglichkeit an der FD-Hitparade),
    Modem/ISDN (wird automatisch erkannt): 08801-2453

  - Angel City, Brett: 300_SUPPORTWORLDAMIGA-AKTUELL/,
    Modem/ISDN (wird automatisch erkannt): 0911-698527, 0911-698551


  Achtung, Mailboxbetreiber: Habt Ihr Interesse, ein Brett für
  AMIGA aktuell einzurichten, dann meldet Euch bitte unter aakt@aakt.de bei
  uns!


* per Post-Abo: Wer AMIGA aktuell ein Jahr lang jeden Monat per Post
  zugeschickt bekommen möchte, kann, unter Angabe des Stichworts 'Abo'
  sowie von Name und Anschrift, 15 Euro auf folgendes Konto überweisen:
  Deutsche Bank 24 Göttingen, BLZ 26070024, Kontonr.: 0495812,
  Kontoinhaber: Carsten Schröder. Nach einem Jahr läuft das Abo, das sowohl
  die AMIGAGuide- als auch die HTML-Version inklusive Grafiken umfasst,
  automatisch aus, sofern es nicht verlängert wird.


* per Post: Die neueste Ausgabe kann jeweils ab Ende des Vormonats gegen
  Diskette und 1 Euro Rückporto in Briefmarken direkt bei mir angefordert
  werden. Alternativ kann statt einer Diskette auch ein um 50 Cent erhöhter
  Betrag mitgeschickt werden.


Die AMIGA-aktuell-Specials sind auch per Packet-Radio verfügbar. Peter
Huyoff spielt sie in seine Home-BBS HGWBOX in die Rubrik AMIGA@DEU ein. Von
dort aus werden sie im gesamten CB-Funk-BBS-Netz innerhalb Deutschlands
verbreitet. Eventuell angehängte Grafiken werden jedoch wegen der geringen
Datenübertragungsrate nicht berücksichtigt.

@ENDNODE

@NODE "Intern5" "Intern"
@TOC "MAIN"

5. AMIGA-aktuell-Diskussions-Mailingliste

Hiermit möchte ich alle Leserinnen und Leser herzlich dazu einladen, sich
in die AMIGA-aktuell-Mailingliste einzutragen.

Wer sich an Diskussionen rund um AMIGA und AMIGA aktuell beteiligen möchte,
schickt bitte eine E- Mail an:

aaktdiskussionen-subscribe@yahoogroups.com

Das Subject/Betreff-Feld kann leer bleiben und in der E-Mail braucht auch
kein weiterer Text stehen.

Es ist nicht möglich, in diese Liste sogenannte Attachments (angehängte
Dateien) zu schicken. Verwendet dazu bitte den extra dafür gedachten
Filebereich von yahoogroups. Es stehen allen Teilnehmern insgesamt 20 MB
Webspace zur Verfügung. Normalerweise reicht diese Größe für alle Zwecke
aus.

Die von Yahoo am Ende eines Postings angefügte Werbung hat nichts mit AMIGA
aktuell zutun. Die Redaktion von AMIGA aktuell bedient sich einem
kostenlosen und damit werbefinanzierten Internet-Dienst.

Denjenigen, die sich näher über diese Verteilerliste informieren möchten,
kann ich folgende Internet-Links ans Herz legen:

http://de.groups.yahoo.com/
http://de.groups.yahoo.com/group/aaktdiskussionen

Wer Fragen oder Probleme hat, schickt eine E-Mail vorzugsweise an mich und
nicht an Carsten Schröder.

Hier noch mal alle Adressen in Kurzform:

Abonnieren          : aaktdiskussionen-subscribe@yahoogroups.com
Abonnement kündigen : aaktdiskussionen-unsubscribe@yahoogroups.com
Nachricht absenden  : aaktdiskussionen@yahoogroups.com
Listeninhaber       : aaktdiskussionen-owner@yahoogroups.com
yahoogroups-Seite   : http://de.groups.yahoo.com/group/aaktdiskussionen

Ich wünsche allen Lesern viel Spaß beim Diskutieren!

Christian Aichinger <christian@aakt.de>

@ENDNODE

@NODE "Intern6" "Intern"
@TOC "MAIN"

6. Rechtliches

AMIGA aktuell wird von Carsten Schröder, Helmoltstraße 10, 37081 Göttingen,
Deutschland, herausgegeben. Die Zusammenstellung steht unter dem Copyright
des Herausgebers.

AMIGA aktuell darf PRIVAT frei kopiert werden, solange als Gegenleistung
(einschl. Datenträger und Porto) nicht mehr als 1,50 Euro bzw. ein
vergleichbarer Betrag in einer anderen Währung verlangt wird. Die
gewerbliche Distribution bedarf jedoch der Zustimmung des Herausgebers.

Jeder in AMIGA aktuell veröffentlichte Beitrag steht unter dem Copyright
des Autors und darf ohne dessen Genehmigung und der von AMIGA aktuell nicht
verändert oder republiziert werden.

Für den Inhalt jedes Beitrags ist allein dessen Autor rechtlich
verantwortlich. AMIGA aktuell behält sich das Recht vor, Beiträge auf
Fehler zu korrigieren, sinngemäß zu kürzen oder zu republizieren,
verpflichtet sich jedoch nicht, jeden erhaltenen Beitrag zu
veröffentlichen.
Der jeweilige Autor erklärt sich damit einverstanden, dass sein Beitrag bei
Bedarf übersetzt werden und innerhalb der englischsprachigen Ausgabe AMIGA
aktuell International erscheinen darf.

Sämtliche Anfragen sind an folgende Anschrift zu richten:

Carsten Schröder        E-Mail: aakt@aakt.de
Helmoltstraße 10        Fax: 089/2443-31176
D-37081 Göttingen

@ENDNODE

@NODE "Forum1" "Forum"
@TOC "MAIN"

AMIGA-aktuell-Forum
-------------------

In dieser Rubrik sind die - bei den meisten anderen Magazinen getrennt
geführten - Rubriken "Leserbriefe", "Kleinanzeigen", und "Problemecke"
zusammengefasst.

Wenn Ihr einen Beitrag habt, schreibt bitte an:

        Carsten Schröder
        Helmoltstraße 10
        37081 Göttingen

E-Mail: aakt@aakt.de


1. Die Frage des Monats - wir möchten eure Meinung erfahren

Jeden Monat stellen wir euch in dieser Rubrik eine Amiga-bezogene Frage
oder machen eine provokante Bemerkung (die übrigens nicht unbedingt unsere
Meinung wiedergeben muss), in der Hoffnung, dass ihr euch möglichst
zahlreich mit Kommentaren zu Wort meldet. Wir werden eure Beiträge in der
jeweils folgenden Ausgabe veröffentlichen. Schickt sie an aakt@aakt.de


Die Frage des letzten Monats lautete:

»In welcher Verfassung wird sich deiner Einschätzung nach der Amiga-
PowerPC-Markt in einem Jahr befinden?
Beschreibe beispielsweise, welche Art von Software in welcher Qualität und
Menge (verglichen mit entsprechenden Windows-Programmen) deiner Meinung
nach zu dem Zeitpunkt existiert, wie stark Standard-Hardware mit Treibern
unterstützt wird, wie groß die Anwenderzahl ist, etc.«


Jürgen Lange beschreibt seine - negativen - Erwartungen recht ausführlich:

»Vorausschickend muß ich sagen, daß ich weder ein Befürworter noch ein
Gegner einer PPC-Lösung für den Amiga bin.

Einer PPC-Lösung gebe ich trotzdem kaum eine Chance. Dafür gibt es
verschiedene Gründe:

1. PPC hat sich schon in der Vergangenheit nicht durchgesetzt. Hätten die
von Phase5 entwickelten Dual-Prozessor-Boards einen größeren Kundenkreis
gefunden, wäre auch mehr Software dafür entwickelt worden (was mehr
Verkäufe initiiert hätte). Preis und Mehrwert dieser Lösung stand in zu
großem Gegensatz. Dies könnte sich jetzt zwar ändern, da keine 68k-CPU mehr
benötigt wird. Zudem fallen die Kontext-Switches weg, was dem einen oder
anderen Programmierer eine Hemmschwelle wegnehmen könnte.

2. Es werden zu wenige PPC-Rechner gefertigt werden. Die von der bplan GmbH
genannten 1500-2000 Rechner werden keineswegs für eine Software-Schwemme
sorgen. Dafür ist die Zahl viel zu klein.

3. Das Fertigungs- und Vertriebskonzept stimmt nicht. Die Rechner von den
derzeit vorhandenen Händlern fertigstellen zu lassen, halte ich für einen
großen Fehler. Dies wird, wie bei den Phase5-Produkten, zu Problemen beim
Support führen. Die bplan GmbH selbst scheint mir für das ganze Projekt als
zu klein und zu finanzschwach.

4. Der Normal-User (ich rede jetzt nicht vom Amiga-Masochisten) erwartet
schnelle Verfügbarkeit von Bauteilen im Schadensfall.

5. Es werden Anwendungen benötigt, die auf Amiga laufen und zumindest einen
großen Teil der Funktionalität der für Windows vorhandenen Programme
ebenfalls bieten.

6. Amiga muß sich an der Konkurrenz messen lassen können! Was hilft es,
wenn der Port eines Spieles oder der Port einer Anwendung (z.B. Papyrus)
zwar auch unter PPC läuft, aber auf anderen Systemen kostengünstiger und
mit mehr Leistung zu haben ist.

Zusammenfassend sehe ich für den PPC-Amiga (oder PPC-MorphOS) keine große
Zukunft, da Hardware in zu kleinen Stückzahlen und zu zu hohem Preis zur
Verfügung stehen wird, daß sie einen Softwareschub initiieren könnte, der
das Gesamtsystem überlebensfähig macht.

Alle Argumente gegen einen schnellen Emulator auf x86-Basis oder gar ein
x86-AmigaOS gelten, von ein paar Freaks abgesehen, auch für die Zukunft
eines PPC-Amiga. Besagte Freaks werden sich den PPC-Amiga kaufen, koste es,
was es wolle. Aber ob das eine Basis ist?«


Stefan Kleinheinrich ist ebenfalls pessimistisch:

»Software: Etwa 50% der jetzt angekündigten Programme werden tatsächlich
erscheinen, wobei der ein oder andere Hersteller sich nicht auf PPC-only
beschränken wird (eine 68k-Variante für Amithlon/Classic-User ist relativ
leicht verdientes Geld).

Treiber: So lange es AmigaOS 4 gegen MorphOS und alle gegen Amithlon geht,
sehe ich schwarz.
Im Moment dürfte Amithlon schon wegen der teilweisen Nutzung von Linux-
Treibern hier die Nase vorn haben. Auch denke ich, dass die Treiber für
HighWay/SubWay/Amithlon eher fertig sind als die von MorphOS oder AmigaOS
4, so dass auch hier früher mit der Anpassung an einzelne Geräte begonnen
werden kann.

Userzahl: Im großen und ganzen gleichbleibend, nur leider auf drei Systeme
zersplittert.«



Nun zur aktuellen Frage des Monats:

»Wie beurteilst du die Annäherung von AMIGA, Inc. und Microsoft
prinzipiell?«


Schickt eure Beiträge bitte an aakt@aakt.de

@ENDNODE

@NODE "Forum2" "Forum"
@TOC "MAIN"

2. Reaktion auf Guido Bruns' Leserbrief in Ausgabe 02/2002 (von Kai Weger)

Ich sehe es genauso wir Guido Bruns. Wer soll sich denn die teure PPC-
Hardware kaufen??

Ich habe einen Amiga 1200 und zwei PCs (d.h. noch, einen davon bekommen
meine Eltern). Für ca. 500 EUR kann man sich schon einen guten x86er-PC
(ohne Monitor) zusammenbauen. Hab ich vor ein paar Wochen getan.
Damit kann ein PPC-System nicht mithalten. Ich meine, 1000 EUR für den
kleinsten Pegasos ist zwar an sich nicht zu teuer, nur daß der 350er-G3
einfach zu wenig Leistung hat (immer mit x86er zu einem ähnlichen Preis
verglichen).
So gern ich neue Amiga-Hardware sehen würde - meiner Meinung nach ist es
genau der falsche Weg. Wirklich Geld verdienen kann eine Firma doch nur im
Massenmarkt oder in einer elitären Nische. Und für den Massenmarkt werden
die kommenden Systeme zu teuer, für eine elitäre Nische hat man zu wenig
Software (was man allerdings ändern kann). Zudem ist diese Nische schon vom
Mac besetzt...

Zudem denke ich nicht, daß die x86er-Kompatibilität Linux geschadet hat. Im
Gegenteil, so kann ein Nutzer Linux "mal eben" ausprobieren, ohne sich
einen anderen Rechner zu kaufen. Ein PPC-OS ist für die meisten Nutzer doch
sozusagen die Katze im Sack!

Kai Weger <kweger@htwm.de>

@ENDNODE

@NODE "Forum3" "Forum"
@TOC "MAIN"

3. Einschätzung zur Lage des Amiga (von Günter Raab)

Eines ist wohl klar, der Amiga wird nie wieder zum marktbeherrschenden
Computer werden. Zu lange ist er schon von der internationalen Bildfläche
verschwunden. Die ehemaligen Amiganer, die auf einen PC umstiegen, sind
aber, so glaube ich, in einer Art Warteposition. Kommt was Neues, das
wirklich den gewaltigen Rückstand zumindest aufholt, werden sie
zurückkommen.
Mit Rückstand meine ich nicht nur die Hardware, auch die Software muss
endlich auf den neuesten Stand gebracht werden!

So gibt es noch immer keine Möglichkeit, Daten mit dem PC oder MAC 1:1
auszutauschen. AmigaWriter kann zwar bedingt Word-Dokumente laden, beim
Speichern ist aber Ebbe. Bei den Tabellenkalkulationen ist es da nicht viel
besser, wenigstens kann auch in ein Fremdformat umgewandelt werden. Nur bei
Grafikdaten gibt es keine Schwierigkeiten. Komisch, vor Jahren schrieb
ähnliche Zeilen der Redakteur einer längst eingestellten Zeitschrift namens
Amiga Spezial...

Dann der seltsame Zustand bei den Web-Browsern. Da gibt es ganze DREI
Stück, aber keiner davon ist auf dem letzten Stand in puncto Javacript!!
Unzählige JavaScript-Fehler beim Surfen nerven langsam schon. Ein Office-
Paket, das in der Lage ist, Daten aus den unterschiedlichen Anwendungen
ohne Probleme auszutauschen, fehlt ebenfalls seit jeher. Die Final-xxx-
Serie, mit der ein Austausch nur über AREXX möglich ist, wurde ja schon
lange eingestellt.

Bei der Hardware arbeiten alle übrig gebliebenen Firmen gegeneinander,
anstatt einen gemeinsamen Nenner zu finden. Pervers! PCI gut und schön,
aber da fehlt noch sehr viel, um weitere Käufer zu finden (Prozessor, DDR-
RAM).

Zusammenfassend meine ich, dass derzeit ein buntes Durcheinander herrscht,
so daß die User nun verunsichert sind, was sie nun eigentlich wirklich
kaufen sollen.

Daher kann für 2002 nur eines gelten: Bis allerhöchstens Ende des 2.
Quartals ist was Neues, Zeitgemäßes zu kaufen, oder von den restlichen etwa
20.000 Amiganern bleiben wohl keine 1000 mehr übrig. Auch ich (43) habe die
leeren Versprechungen endgültig satt. Ein MAC (PeeZee - nein danke) ist
zwar kein Amiga, aber noch am ehesten als (seufz!) Ersatz des besten
Computersystems zu sehen.

Denn irgendwann wird auch der beste Amiga seinen Geist aufgeben. Derzeit
stehen die Zeichen eher auf Amiga-Emulation anstatt AmigaOne. Das ist eher
mit dem Untergang des Amiga zu vergleichen...

Günter Raab <guenter.raab@utanet.at>

@ENDNODE

@NODE "Workshops1" "Workshops"
@TOC "MAIN"

Workshops / Hintergrundberichte / Buchvorstellungen
---------------------------------------------------

1. Workshop: Programmierung in C++ - Teil 4 (von Thomas Richter)

[Achtung: In diesem Artikel kommen mehrere "Backslashes" vor, die jedoch
von (einigen?) AmigaGuide-Anzeigern nicht dargestellt werden. Daher bietet
es sich an, dieses Guide in einen Texteditor einzuladen oder die HTML-
Version von AMIGA aktuell zu verwenden, die in Kürze auf http://www.aakt.de
abrufbar ist; Anm. d. Red.]


Nachdem wir im letzten Kurs Objekte eingeführt haben, die auch wirklich etwas
auf dem Bildschirm anstellen, werden wir dieses Mal die Kenntnisse der
Objektorientierung weiter ausbauen: Genauer gesagt, diesmal geht es um Vererbung
von Eigenschaften, virtuellen Klassen und Zugriffsberechtigungen auf Member
der Objekte; ferner machen wir einen Schlenker in das wichtige Kapitel des
Programmdesigns, und wir werden uns mit einer Basisstruktur auseinandersetzen,
der linearen Liste.


Der Erzählung erster Teil: Das Design

Unter dem Programmdesign versteht man die Philosophie, die dem Aufbau des
Programmes zugrunde liegt. Im Hobbybereich werden Programme oft "ohne Design",
man sagt auch "ad hoc", geschrieben, so auch das Programm der letzten Folge.
Dies führt oft dazu, dass der Quellcode nach einigen Programmversionen recht
vermurkst aussieht, so dass es schwer ist, ihn zu erweitern und zu pflegen,
und dass man früher oder später über die eigenen Fehler stolpert. Ein
kommerzielles Programm muss man oft über viele Programmversionen pflegen, und
darum sollte man sich schon vorher überlegen, wie man seine Programmidee
umsetzt. C++ ist eine Programmiersprache, die Autoren in dieser
konzeptionellen Arbeit unterstützt - ganz im Gegensatz zu anderen Sprachen wie
etwa BASIC, in denen man nur zu leicht Spaghetticode produziert. Der
Programmfluss ist dann ähnlich leicht zu verfolgen wie das italienische
Nudelprodukt auf einem Teller, und entsprechend schwer zu entheddern.

Schauen wir uns unter diesem Gesichtspunkt einmal den Code vom dritten Teil
an: Wir haben einerseits eine Klasse für Fenster, die die Zeichenfläche des
geplanten Zeichenprogrammes bildet. Das Fenster selbst weiß aber nicht, welche
Objekte in ihm leben. Dann gibt es zwei Objekte, von denen das eine ein Punkt-
und das andere ein Linienobjekt ist. Ein Punkt hat zwei Koordinaten, eine
Zeichenfläche, sprich, "das Fenster", und eine Farbe. Eine Linie hat auch eine
Zeichenfläche, und zwei Punkte, von denen wiederum jeder eine Zeichenfläche
und eine Farbe hat. Hier gibt's einiges doppelt! Ferner, welche Farbe hat
denn nun eine Linie, die des Anfangs- oder die des Endpunktes?

Wie man schon sieht - hier stimmt was nicht!

Formulieren wir also, was wir genau brauchen, und überlegen wir uns dann, wie
man das am besten umsetzt. Kurz gesagt: Machen wir ein Design!

1) Ein Fenster sollte darüber informiert sein, welche Objekte in ihm sind.
2) Ein grafisches Objekt sollte irgendwie zeichenbar sein. Wie das genau
   geschieht, darf dem Fenster eigentlich egal sein.
3) Ein grafisches Objekt sollte eine Farbe haben.
4) Es muss Möglichkeiten geben, die Koordinaten von Objekten anzugeben.
   Dazu brauchen wir ein Objekt, dass Koordinaten vermittelt. Wir hatten
   im dritten Teil dazu einfach nur die "Punkt"-Klasse verwendet, aber
   eigentlich stimmt hier was nicht: Das grafische Objekt eines einzelnen
   Punktes hat zwar Koordinaten und kann auch gemalt werden, aber wir
   bräuchten eigentlich für die Linie nur die Koordinaten, und würden
   diese Koordinatenpaare dann mit zusätzlichen Eigenschaften ausrüsten,
   etwa einer Farbe. Ein "zeichenbarer Punkt", sagen wir ein Pixel,
   besteht dann auch aus einem Koordinatenpaar, und einer Farbe.

Diese "Designziele" werden wir im folgenden umsetzen: Für Punkt 1) brauchen
wir pro Fenster ein "Inhaltsverzeichnis" aller Objekte darin. Wir werden
hierzu sogenannte "einfach verkettete Listen" verwenden, damit der Leser
auch ein wenig von den Grundlagen der Informatik mitnimmt. Die Objekte
werden auf einer solchen Liste aufgereiht wie Perlen auf einer Kette.

Weiterhin benötigen wir noch ein neues Konzept von C++, nämlich die so genannte
"Vererbung" oder "Inheritance". Man kann nämlich auf der Grundlage von
bereits definierten Klassen weitere, neue Klassen aufbauen, oder wie man auch
sagt, "neue Klassen ableiten". Diesen neuen Klassen werden dann die Methoden
und Member der "Basisklasse" "vererbt". In unserem Falle könnten wir
beispielsweise wie folgt vorgehen: Ein grafisches Objekt hat 1) eine
Zeichenfläche, 2) eine Farbe und 3) eine Methode, sich zu zeichnen:

class GraphikObjekt {
        RastPort        *rp;
        int              farbe;
public:
        GraphikObjekt(RastPort *port,int f = 1)
        : rp(port), farbe(f)
        { }
        //
        void Zeichne(void)
        {
                // Da wir nicht wissen, welches Objekt das
                // hier ist, können wir natürlich auch nichts
                // zeichnen....
                cout<<"Dieses Objekt ist nicht zeichenbar.\n";
        }
}

"RastPort" ist wie im dritten Teil erläutert die Zeichenfläche, die vom OS
für alle möglichen Grafikoperationen benötigt wird; es ist das Interface der
Grafikbibliothek des AmigaOS, das Zeichenoperationen ermöglicht. Wir bekommen
immer nur Zeiger darauf, deshalb das Sternchen vor dem "rp". "farbe" ist der
Farbstift des jeweiligen Objektes. Der Konstruktor des Objektes muss natürlich
die Zeichenfläche und den Farbstift übergeben bekommen, wobei wir hier mit
"int f = 1" dem Aufrufer erlauben, Objekte auch ohne Farbstift zu definieren
und als Vorgabe dann "Farbe eins" anzunehmen.

Die Methode "Zeichne" ist noch etwas sonderbar: Sie tut - nichts. Kann sie
natürlich nicht, denn mit der Klasse "Graphikobjekt" ist ja noch nicht mal
klar, welche Sorte von grafischem Objekt wir überhaupt haben wollen. Also
warum schreiben wir sie dann? Das wird erst ein Stückchen später klar, also
noch etwas Geduld, bitte...

Kommen wir zum zweiten Objekt, einem Punkt. Im Gegensatz zum dritten Teil soll
diesmal klar unterschieden werden zwischen einem Koordinatenpaar als solchem

struct Punkt {
        int x,y;
        //
        Punkt(int x0,int y0)
        : x(x0), y(y0)
        { }
};

und einem farbigen Pixel, das sich an der Stelle eines solchen
Koordinatenpaares befindet. Kümmern wir uns zunächst um den Punkt: Er ist hier
als "Struktur" und nicht als "Klasse" definiert. Der einzige Unterschied
zwischen beiden ist der, dass man auf die Member einer Struktur ohne weiteres
"von außen", also nicht nur von Methoden der Klasse aus, darauf zugreifen kann.
Alternativ hätte man auch:

class Punkt {
public:
        int x,y;
        //
        Punkt(int x0,int y0)
        : x(x0), y(y0)
        { }
};

schreiben können, um "x" und "y" öffentlich zu machen.

Die Philosophie - das Design - ist hier die folgende: In C++ sollte man immer
dann Strukturen statt Klassen verwenden, wenn die jeweiligen Objekte nur Daten
sammeln und nicht genügend Eigenleben haben, um eine eigene Klasse zu
rechtfertigen. Das ist natürlich keine klare Definition und bleibt der Willkür
des Programmierers überlassen, aber im obigen Fall des Koordiantenpaares "Punkt"
sehe ich die Struktur "Punkt" nur als eine Zusammenfassung zweier Zahlen,
und nicht als ein "Ding mit Eigenleben" an. Aus diesem Grunde finde ich die
obere Möglichkeit, explizit hier "struct" statt "class" zu verwenden, als
diejenige an, die meiner Intention näher liegt. Ob "struct" oder "class" ist
damit eine Frage des Designs und keine Frage, die innerhalb der C++ Syntax
beantwortet werden kann. Wir werden noch viele solche "Designentscheidungen" in
dieser Folge kennenlernen.


Familienangelegenheiten: Vererbung von Eigenschaften.

Ebenso wie der Familiennachwuchs die Augen der Großmutter oder die Ohren des
Onkels hat, bekommen Klassen auch die Methoden und Member ihrer Basisklasse
vererbt. Wir bauen nun auf den beiden obigen Klassen "Punkt" und
"GraphikObjekt" ein "Pixel" auf: Dazu "leiten wir die Pixelklasse vom
Graphikobjekt ab".

class Pixel : public GraphikObjekt {
        struct Punkt    position;       // Ort des Pixels
        //
public:
        // Konstruktor des Objektes: Zeichenfläche, Farbe,
        // Position.
        Pixel(RastPort *port, int f, int x, int y)
        : GraphikObjekt(port,f), position(x,y)
        { }
        //
        // Noch ein Konstruktor: Dieser bekommt die
        // Position als Referenz übergeben
        Pixel(RastPort *port, int farbe, Punkt &pos)
        : GraphikObjekt(port, farbe), position(pos)
        { }
        //
        // Mach' 'nen Punkt!
        void Zeichne(void)
        {
                // Farbe holen und setzen: Dies ist
                // eine Betriebssystemfunktion
                SetAPen(rp,farbe);
                WritePixel(rp,position.x,position.y);
        }
};

Dazu natürlich einige Erläuterungen (Vorsicht, das kompiliert noch nicht!):

class Pixel : public GraphikObjekt {

Mittels des "public GraphikObjekt" hinter dem Doppelpunkt sagen wir, dass wir
"Pixel" von der Klasse "GraphikObjekt" ableiten. "public" beschreibt die Art
der Ableitung, es gibt noch "private" und "protected". Wir werden im Folgenden
aber nur "public" verwenden, ich möchte auf diese Details hier auch zunächst
nicht eingehen. Damit ist jedes Objekt vom Typ "Pixel" automatisch auch ein
Objekt vom Typ "GraphikObjekt" und hat als solches automatisch eine
Zeichenfläche, bzw. einen Zeiger auf eine solche, sowie eine Farbe. Diese
Member treten, wie man sieht, in der Definition der Punktklasse gar nicht mehr
explizit auf, sondern stammen vom Elternteil "GraphikObjekt".

Ferner bringt das Pixel noch ein weiteres Member von sich aus mit, nämlich
seine Position - das ist ein Objekt vom Typ "Punkt", wie oben definiert. An
dieser Stelle darf man sich fragen, warum wir nicht auch "Pixel" vom "Punkt"
abgeleitet haben. Auch dies wäre möglich gewesen:

class Pixel : public GraphikObjekt, public Punkt {

nebst einigen kleineren zusätzlichen Änderungen, die jetzt nicht sonderlich
relevant sind. Die Pixelklasse hätte dann (wie ja in der Biologie eher
typisch) zwei Elternteile statt einem. C++ erlaubt dies - man nennt dieses
vornehm auch "multiple inheritance", also "mehrfache Vererbung". Ob man nun
die obere oder die untere Lösung bevorzugt, ist erneut eine Frage des Designs.
In der oben verwendeten Definition "hat ein Pixel ein Zahlenpaar", in der
unteren "ist ein Pixel auch ein Zahlenpaar". Von meinem Empfinden her erscheint
mir die Position eines Pixels eine Eigenschaft ähnlich seiner Farbe, wo
hingegen ein Pixel nicht selbst ein Koordinatenpaar "ist". Man darf durchaus
anderer Meinung sein, sollte aber darauf achten, dass das Design so natürlich
und intuitiv wie möglich ist - man will ja seine Programme später auch noch
verstehen.

Weiter im Text: Die Pixelklasse hat zwei Konstruktoren bekommen, eine, bei der
die Position mittels zweier Zahlen, und noch eine, bei der die Position mittels
der Punktstruktur angegeben wird. Je nachdem welche Parameter man bei der
Erzeugung von Pixelobjekten übergibt, wird entweder der eine oder der andere
Konstruktor verwendet. Und wieder ein Fachausdruck für Angeber, der genau
das meint: "C++ unterstützt Polymorphie", d.h. gleichnamige Methoden werden
auch aufgrund unterschiedlicher Argumente auseinandergehalten. Für den zweiten
Fall übergeben wir die Koordinaten als "Referenz" - das wurde das letzte Mal
erläutert.

Schauen wir uns den ersten Konstruktor einmal genauer an:

        // Konstruktor des Objektes: Zeichenfläche, Farbe,
        // Position.
        Pixel(RastPort *port, int f, int x, int y)
        : GraphikObjekt(port,f), position(x,y)
        { }

hinter dem Doppelpunkt stehen diesmal nicht nur die Namen von Membern, sondern
auch ein Typenname: "GraphikObjekt" ist kein Member von "Punkt", sondern der
Typ des Elternteils. Diese Basisklasse ist eben nicht als "Member" Teil des
Pixels, sondern das Pixel bekommt die Member von "GraphikObjekt" per
Vererbung.

Trotz alledem muss zur Konstruktion der abgeleiteten Klasse "Pixel" die
Basisklasse auch konstruiert werden, und dies geschieht in C++ über die Angabe
des Typennamens der Basisklasse. Das Member "position" wird hingegen klassisch
über seinen Konstruktor zusammengebaut.

Beim zweiten Konstruktor sieht das ganz genauso aus:

        // Noch ein Konstruktor: Dieser bekommt die
        // Position als Referenz übergeben
        Pixel(RastPort *port, int farbe, Punkt &pos)
        : GraphikObjekt(port, farbe), position(pos)
        { }

Man entsinne sich nur daran, dass ein Objekt automatisch immer einen Copy-
Konstruktor mitbekommt, der hier mittels "position(pos)" bemüht wird. Er
braucht nicht - aber kann - explizit definiert werden. Dies hatten wir im
zweiten Teil dieses Kurses gesehen.


Letztendlich sollen Punkte auch gezeichnet werden:

        // Mach' 'nen Punkt!
        void Zeichne(void)
        {
                // Farbe holen und setzen: Dies ist
                // eine Betriebssystemfunktion
                SetAPen(rp,farbe);
                WritePixel(rp,position.x,position.y);
        }

Dies setzt mittels der Betriebssystemroutine "SetAPen()"  den Farbstift
innerhalb der Zeichenfläche "rp" auf "farbe" und zeichnet dann mittels einer
zweiten OS-Funktion "WritePixel()" das Pixel an der gewünschten Position. Man
beachte, dass wir hier auf die Member "rp" und "farbe" einfach so zugreifen
können, obwohl sie im Pixel selbst gar nicht definiert wurden - das sind die
Eigenschaften, die von der Basisklasse vererbt wurden!



Kleine Probleme mit dem Nachwuchs: Das Zusammenbauen

Wir basteln jetzt aus den oben erstellten Klassen ein erstes kleines Programm
zusammen, das zunächst nur ein einzelnes Pixel auf den Schirm zaubert. Linien
malen wir gleich darauf.

#include <iostream.h>

extern "C" {
#include <intuition/intuition.h>
#include <graphics/rastport.h>
#include <proto/intuition.h>
#include <proto/graphics.h>
#include <proto/exec.h>
}

class Fenster {
        Window *window;         // Das Intuition-Fenster davon
        int breite,hoehe;       // Dimensionen
public:
        Fenster(int b,int h)
        : window(NULL), breite(b), hoehe(h)
        {
                window = OpenWindowTags(NULL,
                                WA_GimmeZeroZero,TRUE, // Ursprung ist im Zeichenbereich
                                WA_SmartRefresh,TRUE,  // Automatisch wiederherstellen wenn verdeckt
                                WA_InnerWidth,b,
                                WA_InnerHeight,h,
                                WA_CloseGadget,TRUE,   // Fenster hat Schließknopf
                                WA_DragBar,TRUE,       // Fenster kann verschoben werden
                                WA_DepthGadget,TRUE,   // Fenster kann nach vorne/hinten gebracht werden
                                WA_IDCMP,IDCMP_CLOSEWINDOW,
                                TAG_DONE);
        }
        //
        // Der Destruktor löscht auch wieder das Fenster davon, falls offen.
        ~Fenster(void)
        {
                if (window) {
                        CloseWindow(window);
                }
        }
        //
        // Liefere die Zeichenfläche des Fensters. Dies nennt sich RastPort
        RastPort *RastPort_Hiervon(void) const
        {
                return window->RPort;
        }
        //
        // Warte, bis der Benutzer das Close-Gadget drückt.
        void WarteAufSchliessen(void) const
        {
                struct Message *msg;

                msg = WaitPort(window->UserPort);
                msg = GetMsg(window->UserPort);
                ReplyMsg(msg);
        }
};

class GraphikObjekt {
        RastPort        *rp;
        int              farbe;
public:
        GraphikObjekt(RastPort *port,int f = 1)
        : rp(port), farbe(f)
        { }
        //
        void Zeichne(void)
        {
                // Da wir nicht wissen, welches Objekt das
                // hier ist, können wir natürlich auch nichts
                // zeichnen....
                cout<<"Dieses Objekt ist nicht zeichenbar.\n";
        }
};

struct Punkt {
        int x,y;
        //
        Punkt(int x0,int y0)
        : x(x0), y(y0)
        { }
};

class Pixel : public GraphikObjekt {
        struct Punkt    position;       // Ort des Pixels
        //
public:
        // Konstruktor des Objektes: Zeichenfläche, Farbe,
        // Position.
        Pixel(RastPort *port, int f, int x, int y)
        : GraphikObjekt(port,f), position(x,y)
        { }
        //
        // Noch ein Konstruktor: Dieser bekommt die
        // Position als Referenz übergeben
        Pixel(RastPort *port, int farbe, Punkt &pos)
        : GraphikObjekt(port, farbe), position(pos)
        { }
        //
        // Mach' 'nen Punkt!
        void Zeichne(void)
        {
                // Farbe holen und setzen: Dies ist
                // eine Betriebssystemfunktion
                SetAPen(rp,farbe);
                WritePixel(rp,position.x,position.y);
        }
};


int main(int argc, char **argv)
{
Fenster f(200,200);             // baue ein Fenster der Größe 200x200
Pixel p(f.RastPort_Hiervon(),1,50,50);

        p.Zeichne();
        f.WarteAufSchliessen();

        return 0;
}

Die Fensterklasse habe ich dabei unverändert vom letzen Teil übernommen, und
das Hauptprogramm ist leicht abgewandelt.

Nur, etwas stimmt noch nicht: Bei Versuch, das Programm zu kompilieren, gibt
es folgende und ähnliche Fehlermeldungen:

Error: No access to member "rp" of class "GraphikObjekt".

Warum das? Die Klasse "Pixel" versucht auf das Member "rp" von
"GraphikObjekt" zurückzugreifen, aber darf dies offenbar nicht. Das liegt
daran, dass "rp" ein privates Member von "GraphikObjekt" ist, wie dies bei
Klassen immer voreingestellt ist.

Eine Möglichkeit, dies zu beheben wäre etwa die, "rp" innerhalb von Graphik-
Objekt als "public" zu deklarieren; leider könnte dann auch jeder andere von
außen einsehen. Eine andere Möglichkeit wäre, wie im dritten Teil gesehen,
Zugriffsfunktionen auf die Member zu schreiben.

In diesem Falle gibt es aber eine bessere Methode: Es gibt neben "public" und
"private" noch eine dritte Zugriffsberechtigung namens "protected", die die
entsprechenden Member nur für abgeleitete Klassen, aber nicht von außerhalb
zugreifbar macht. Folgendes ist zu modifizieren:


class GraphikObjekt {
protected:
        RastPort        *rp;
        int              farbe;
public:
        ....

Das so modifizierte Programm kompiliert und läuft einwandfrei.


Vielleicht ist aber doch noch einiges beklagenswert: Wir haben nämlich für das
Pixel eine Farbe angeben müssen, obwohl dies beim GraphikObjekt noch optional
war. Man würde meinen, die offensichtliche Lösung dieses Problems wäre das
Ändern der Konstruktoren des Pixels wie folgt:

        Pixel(RastPort *port, int f = 1, int x, int y)
        : GraphikObjekt(port,f), position(x,y)
        { }

aber leider widerspricht das der Syntax von C++: Optionale Argumente müssen
immer am Ende der Argumentenliste stehen. Es ergeben sich wiederum mehrere
Möglichkeiten zur Lösung dieses Problems:

1) Wir sortieren die Argumentenliste um:

        Pixel(RastPort *port, int x, int y, int f = 1)
        : GraphikObjekt(port,f), position(x,y)
        { }

womit dann C++ ausgetrickst würde, wir aber überall sonst im Programm auch
darauf achten müssten, bei der Konstruktion des Punktes die Argumente ebenso
zu vertauschen - ansonsten würde aus Versehen die y-Position des Punktes nun
als Farbe missverstanden werden. Ferner haben wir das Problem, dass die
voreingestellte Farbe ja eigentlich die Privatangelegenheit des GraphikObjektes
sein sollte, und eben nicht die des Pixels. Klarer Fall von schlechtem Design
also!

2) Wir fügen einige Konstruktoren hinzu, die keine Farbe benötigen:

        Pixel(RastPort *port, int x, int y)
        : GraphikObjekt(port), position(x,y)
        { }

Da nun GraphikObjekt ebenso ohne Farbe konstruiert werden kann, entfällt das
Argument "f" damit komplett.

Ein weiterer Punkt ist am Pixel noch auszusetzen: Warum setzen wir die Farbe
innerhalb der Zeichenfläche, des RastPorts, eigentlich in der "Pixel" Klasse,
wo es doch schon Aufgabe der Basisklasse "GraphikObjekt" ist, die Farbe und
die Zeichenfläche aufzuheben?

Auch das lässt sich ändern: Das "GraphikObjekt" bekommt eine neue Methode,
mittels der seine Farbe im RastPort ausgewählt wird. Da nur abgeleitete
Objekte über diese Methode verfügen müssen, wenn sie sich selbst zeichnen,
wollen wir sie gar nicht erst öffentlich machen:

class GraphikObjekt {
protected:
        RastPort        *rp;
        int              farbe;
        //
        // Wähle unsere Farbe im RastPort
        void SetzeFarbe(void) const
        {
                SetAPen(rp,farbe);
        }
        //
        ...

und dementsprechend ändert sich im "Punkt"-Objekt die "Zeichne"-Methode:

        // Mach' 'nen Punkt!
        void Zeichne(void)
        {
                SetzeFarbe();   // Bitte die Basisklasse
                WritePixel(rp,position.x,position.y);
        }

An dieser Stelle erkennt man, denke ich, eine grundlegende Designvorschrift:
Das "interne" Wissen einer Klasse sollte so wenig wie möglich nach außen
dringen. Stattdessen sollte eine Klasse über Methoden verfügen, die die
notwendige Funktionalität nach außen tragen. Oder noch anders ausgedrückt,
eine Klasse sollte sich dadurch definieren, was sie kann - und nicht dadurch,
aus welchen Komponenten sie besteht.

Warum dies? Nun, knapp gesagt, "was man nicht dokumentiert hat, kann man
ändern". Bei kleineren Programmen, von Einzelpersonen geschrieben, ist dieser
Punkt vielleicht nicht sonderlich relevant, aber sobald Programme etwas größer
werden und auch gepflegt - sprich: ergänzt, korrigiert, gewartet - werden
müssen, wird man früher oder später Teile der Programmablaufes ändern müssen.
Solcherlei Änderungen lassen sich leichter durchführen, wenn sich Programmteile
so wenig wie möglich auf die internen Abläufe anderer, eventuell zu ändernder
Programmteile verlassen müssen. Bei einem korrekten Design sollte man also so
wenig Information aus dem Innenleben einer Klasse nach außen dringen lassen;
ein weiteres Schlagwort für Angeber: "Information Hiding"

Teile des AmigaOS sind leider ohne diese Designvorschrift entwickelt worden
und hängen teilweise deswegen so sehr von der zugrunde liegenden Hardware ab,
dass eine Änderung im Nachhinein sehr schwierig ist. Dies betrifft etwa den
Aufbau des gesamten Grafiksystems, der schwer an diesen Fehlentscheidungen
krankt und der die Integration von Grafikkarten zu einem Hack-Abenteuer
macht. "Hack" deswegen, weil man sich zwangsläufig auf interne Abläufe
verlassen muss, die mit der eigentlich zu erreichenden Funktionalität nicht
viel zu tun haben.


Punkt, Punkt, Komma, Strich:    Der Ausbau des Programmes

Nachdem wir im letzten Teil auch ein Linienobjekt eingeführt hatten, soll das
in dieser Folge natürlich nicht fehlen. Im Gegensatz zum letzen Mal wird eine
Linie jetzt durch ein "GraphikObjekt" sowie zwei Punkte definiert - und nicht
zwei Pixel. Die Linie hat damit die Farbe des "GraphikObjektes", sowie einen
Anfangs- und einen Endpunkt.

Sehr viel mehr gibt es zur Linienklasse nicht zu sagen. Damit diesmal auch
noch etwas neues passiert, habe ich eine weitere Klasse eingefügt, die
Ellipse. Sie hat eine Farbe, vermittelt durch das GraphikObjekt, dann einen
Mittelpunkt und zwei Radien. Die Klasse ist zunächst so angelegt, dass man
immer beide Radien angeben muss - eventuell findet es der Leser ja reizvoll,
die Ellipsenklasse etwas auszubauen und Konstruktoren einzufügen, die nur
einen Radius benötigen und somit auch einfach Kreise zeichnen können. Oder,
alternativ, vielleicht könnte man auch eine Kreisklasse durch Ableiten
von der Ellipsenklasse erzeugen?

#include <iostream.h>

extern "C" {
#include <intuition/intuition.h>
#include <graphics/rastport.h>
#include <proto/intuition.h>
#include <proto/graphics.h>
#include <proto/exec.h>
}

class Fenster {
        Window *window;                         // Das Intuition-Fenster davon
        int breite,hoehe;       // Dimensionen
public:
        Fenster(int b,int h)
        :       window(NULL), breite(b), hoehe(h)
        {
                window = OpenWindowTags(NULL,
                        WA_GimmeZeroZero,TRUE, // Ursprung ist im Zeichenbereich
                        WA_SmartRefresh,TRUE,  // Automatisch wiederherstellen wenn verdeckt
                        WA_InnerWidth,b,
                        WA_InnerHeight,h,
                        WA_CloseGadget,TRUE,   // Fenster hat Schließknopf
                        WA_DragBar,TRUE,       // Fenster kann verschoben werden
                        WA_DepthGadget,TRUE,   // Fenster kann nach vorne/hinten gebracht werden
                        WA_IDCMP,IDCMP_CLOSEWINDOW,
                        TAG_DONE);
        }
        //
        // Der Destruktor löscht auch wieder das Fenster davon, falls offen.
        ~Fenster(void)
        {
                if (window) {
                        CloseWindow(window);
                }
        }
        //
        // Liefere die Zeichenfläche des Fensters. Dies nennt sich RastPort
        RastPort *RastPort_Hiervon(void) const
        {
                return window->RPort;
        }
        //
        // Warte, bis der Benutzer das Close-Gadget drückt.
        void WarteAufSchliessen(void) const
        {
                struct Message *msg;

                msg = WaitPort(window->UserPort);
                msg = GetMsg(window->UserPort);
                ReplyMsg(msg);
        }
};

class GraphikObjekt {
protected:
        RastPort        *rp;
        int              farbe;
        //
        // Wähle unsere Farbe im RastPort
        void SetzeFarbe(void) const
        {
                SetAPen(rp,farbe);
        }
        //
public:
        GraphikObjekt(RastPort *port,int f = 1)
        : rp(port), farbe(f)
        { }
        //
        void Zeichne(void)
        {
                // Da wir nicht wissen, welches Objekt das
                // hier ist, können wir natürlich auch nichts
                // zeichnen....
                cout<<"Dieses Objekt ist nicht zeichenbar.\n";
        }
};

struct Punkt {
        int x,y;
        //
        Punkt(int x0,int y0)
        : x(x0), y(y0)
        { }
};

class Pixel : public GraphikObjekt {
        struct Punkt    position;       // Ort des Pixels
        //
public:
        // Konstruktor des Objektes: Zeichenfläche, Farbe,
        // Position.
        Pixel(RastPort *port, int f, int x, int y)
        : GraphikObjekt(port,f), position(x,y)
        { }
        //
        // Noch ein Konstruktor: Dieser bekommt die
        // Position als Referenz übergeben
        Pixel(RastPort *port, int farbe, Punkt &pos)
        : GraphikObjekt(port, farbe), position(pos)
        { }
        //
        // Ein "farbloser" Konstruktor
        Pixel(RastPort *port, int x, int y)
        : GraphikObjekt(port), position(x,y)
        { }
        //
        // und noch mal das gleiche, jedoch mit einer
        // Punktstruktur
        Pixel(RastPort *port, Punkt &pos)
        : GraphikObjekt(port), position(pos)
        { }
        //
        //
        // Mach' 'nen Punkt!
        void Zeichne(void)
        {
                SetzeFarbe();
                WritePixel(rp,position.x,position.y);
        }
};

//
// von Punkten zu Linien:
//
class Linie : public GraphikObjekt {
        struct Punkt    anfang,ende;    // wo beginnt und wo endet die Linie?
        //
public:
        // Konstruktor des Objektes: Zeichenfläche, Farbe,
        // Start/Endpunkte
        Linie(RastPort *port, int f, int x0, int y0, int x1, int y1)
        : GraphikObjekt(port,f), anfang(x0,y0), ende(x1,y1)
        { }
        //
        // Noch ein Konstruktor: Dieser bekommt die
        // Positionen als Referenzen übergeben
        Linie(RastPort *port, int farbe, Punkt &von, Punkt &bis)
        : GraphikObjekt(port, farbe), anfang(von), ende(bis)
        { }
        //
        // Ein "farbloser" Konstruktor
        Linie(RastPort *port, int x0, int y0, int x1, int y1)
        : GraphikObjekt(port), anfang(x0,y0), ende(x1,y1)
        { }
        //
        // und noch mal das gleiche, jedoch mit einer
        // Punktstruktur
        Linie(RastPort *port, Punkt &von, Punkt &bis)
        : GraphikObjekt(port), anfang(von), ende(bis)
        { }
        //
        //
        // Mach' 'nen Strich
        void Zeichne(void)
        {
                SetzeFarbe();
                Move(rp,anfang.x,anfang.y);
                Draw(rp,ende.x,ende.y);
        }
};

//
// von Linien zu Ellipsen:
//
class Ellipse : public GraphikObjekt {
        struct Punkt    mittelpunkt;    // wo ist die Ellipse zentriert?
        int                             radiusx,radiusy; // Radien in x- und y-Richtung
        //
public:
        // Konstruktor des Objektes: Zeichenfläche, Farbe,
        // Mittelpunkt, Radien
        Ellipse(RastPort *port, int f, int x, int y, int rx, int ry)
        : GraphikObjekt(port,f), mittelpunkt(x,y),
          radiusx(rx), radiusy(ry)
        { }
        //
        // Noch ein Konstruktor: Dieser bekommt die
        // Position als Referenz übergeben
        Ellipse(RastPort *port, int farbe, Punkt &zentrum, int rx, int ry)
        : GraphikObjekt(port, farbe), mittelpunkt(zentrum),
          radiusx(rx), radiusy(ry)
        { }
        //
        // Ein "farbloser" Konstruktor
        Ellipse(RastPort *port, int x, int y, int rx, int ry)
        : GraphikObjekt(port), mittelpunkt(x,y),
          radiusx(rx), radiusy(ry)
        { }
        //
        // und noch mal das gleiche, jedoch mit einer
        // Punktstruktur
        Ellipse(RastPort *port, Punkt &zentrum, int rx, int ry)
        : GraphikObjekt(port), mittelpunkt(zentrum),
          radiusx(rx), radiusy(ry)
        { }
        //
        //
        // Mach' 'nen Kreis
        void Zeichne(void)
        {
                SetzeFarbe();
                DrawEllipse(rp,mittelpunkt.x,mittelpunkt.y,radiusx,radiusy);
        }
};


int main(int argc, char **argv)
{
Fenster f(200,200);             // baue ein Fenster der Größe 200x200
Pixel p(f.RastPort_Hiervon(),1,50,50);
Linie l(f.RastPort_Hiervon(),Punkt(30,40),Punkt(50,70));
Ellipse e(f.RastPort_Hiervon(),70,70,20,50);

                p.Zeichne();
                l.Zeichne();
                e.Zeichne();

                f.WarteAufSchliessen();

      return 0;
}


Die Zeile

DrawEllipse(rp,mittelpunkt.x,mittelpunkt.y,radiusx,radiusy);

ist nun der OS-Aufruf zum Zeichnen einer Ellipse - er macht die eigentliche
Arbeit für uns. In der Zeile

Linie l(f.RastPort_Hiervon(),Punkt(30,40),Punkt(50,70));

habe ich einmal das Objekt "l" vom Typ "Linie" nicht durch Angabe der
Koordinaten konstruiert, sondern - weil ja bekanntlich Abwechslung das Leben
bereichert - durch die Konstruktion zweier temporärer "Punkt"-Objekte, die
durch Angaben ihrer Koordinaten erzeugt werden. Mit anderen Worten, diese
Zeile benutzt den Konstruktor

        Linie(RastPort *port, Punkt &von, Punkt &bis)
        : GraphikObjekt(port), anfang(von), ende(bis)
        { }

der Linienklasse.


Von Knoten und listigen Listen: Die Verknüpfung von Objekten

Nachdem wir nun zunächst einige grundlegende grafische Objekte erzeugt haben,
sollen diese nun so verwaltet werden, dass das Fenster immer weiß, welche
Objekte sich in ihm befinden. Hierzu werden wir die im letzten Teil
eingeführten Pointer verwenden, um eine sogenannte "einfach verkettete Liste"
zu bilden. Eine solche "Liste" kann man sich ähnlich wie eine "Schnitzeljagd"
vorstellen: Jedes Objekt bekommt einen Pointer - vorzustellen als ein kleines
Pfeilchen - mit, das auf das jeweils nächste Objekt verweist.

Da wir lauter grafische Objekte hintereinander aufreihen wollen, bringt man
diesen Pointer am besten im "GraphikObjekt" unter:

class GraphikObjekt {
        // Der Zeiger auf den Nachfolger dieses Graphikobjektes
        GraphikObjekt    *nachfolger;
        //
protected:
        RastPort        *rp;
        int              farbe;

Die von GraphikObjekt abgeleiteten Klassen braucht es wirklich nicht zu
interessieren, was der Nachfolger eines GraphikObjektes ist, insofern
lassen wir diesen Member einmal "private", und nicht "protected".

Ferner müssen wir bei einer Schnitzeljagd auch wissen, wo diese anfangen
soll. Nun denn, da die Fensterklasse ja wissen soll, welche Objekte sich in
ihr befinden, bringen wir dort am einfachsten einen Pointer auf das erste
GraphikObjekt unter. Dies ist der Startpunkt der Schnitzeljagd - oder genauer,
ein Pfeilchen auf das erste Objekt.


class Fenster {
        Window *window;         // Das Intuition-Fenster davon
        int breite,hoehe;       // Dimensionen
        //
        // Hier beginnt die Liste aller grafischen Objekte dieses Fensters
        GraphikObjekt *erstesobjekt;
        //

und zu guter Letzt braucht eine Schnitzeljagd auch ein Ziel - man muss ja
wissen, wann man das letzte Element dieser Liste erreicht hat und man keine
weiteren Objekte erwarten darf.

Hierzu gibt es einen ganz speziellen Pointerwert, den eine Pointervariable
haben darf - und das ist 0. In diesem einen Ausnahmefall darf also eine Zahl
einem Zeiger zugewiesen werden - dies geht aber nur für die Zahl 0 und sonst
keine andere. Üblicherweise wird mit dem C++-Präprozessor - diesen Teil haben
wir noch nicht genauer besprochen - ein Makro definiert, welches NULL heißt,
aber auch nur die Zahl 0 repräsentiert. Dies geschieht schon automatisch in
den C++-#include-Dateien. Im Grunde genommen ist es dann egal, ob man 0 oder
NULL schreibt, aber letzteres gibt dem Experten klar zu erkennen, dass man
eigentlich einen besonderen Pointer, und nicht die Zahl 0 meint. C++ macht
für die Null keine Unterschiede.

Damit die Pfeilchen niemanden in die Irre weisen können, und dies geschieht in
C++ bei fehlerhaften Programmen nur zu leicht, gehört es zu einem defensiven
Programmierstil, alle solche Zeiger bei der Erzeugung von Objekten lieber auf
NULL zu setzen. Dies habe ich stillschweigend beim Konstruktor der
Fensterklasse schon mit dem "window"-Zeiger gemacht. Mittels "if (window)" kann
man dann abfragen, ob der Pointer irgendwohin zeigt - dann ist die Bedingung
wahr - oder ob es der NULL-Pointer ist - dann ist die Bedingung falsch. Die
Zeilen

        if (window) {
                CloseWindow(window);
        }

im Destruktor der Fensterklasse rufen also nur dann die Betriebssystemroutine
"CloseWindow()" auf, falls der window-Zeiger auch wirklich "wohin", nämlich
auf eine Window-Struktur zeigt.

Initialisieren wir also die beiden neuen Zeiger in der Fenster- und der
GraphikObjekt-Klasse auf NULL:

public:
        Fenster(int b,int h)
        : window(NULL), breite(b), hoehe(h), erstesobjekt(NULL)
        {

ist der neue Konstruktor des Fensters und

public:
        GraphikObjekt(RastPort *port,int f = 1)
        : nachfolger(NULL), rp(port), farbe(f)
        { }

der des GraphikObjekt. Der Grund, warum ich einmal den Pointer am Ende, und
einmal am Anfang der Member initialisiere, ist folgender: Nach C++ Richtlinien
muss ein Compiler sowieso die nach dem ":" stehenden Initialisierungen
in der Reihenfolge der Member innerhalb der Klasse umsortieren - die Gründe
hierfür kann ich im Augenblick noch nicht klarmachen. Ein guter Compiler
sollte eine Warnmeldung erzeugen, wenn die Reihenfolge der Initialisierungen
nicht mit der wirklichen Ausführungsreihenfolge übereinstimmt, weil der
Programmierer ja eventuell etwas Anderes im Sinn gehabt haben könnte.
Schreiben wir also die Initialisierungen gleich in der Reihenfolge auf, in der
die Member-Variablen in der Klasse auftreten! Diese seltsame Regel gilt
natürlich nur für die Initialisierungsliste nach dem Doppelpunkt, nicht für
eventuellen Programmcode in den geschweiften Klammern!

Wenn wir nun versuchen, den wie oben dargestellt modifizierten Programmcode zu
kompilieren, gibt es zunächst ein Problem:

Error: Declaration expected.

meldet der Compiler in der Zeile

        // Hier beginnt die Liste aller grafischen Objekte...
        GraphikObjekt *erstesobjekt;

Diese Fehlermeldung ist leider recht unverständlich, und es bedarf einigen
Nachdenkens, was damit gemeint sein könnte.

Das Problem hier ist das folgende: Zu dem Zeitpunkt, zu dem der Compiler
diese Zeile bearbeitet, ist die "GraphikObjekt"-Klasse noch gar nicht
definiert, also können wir auch keine Zeiger auf diese Klasse deklarieren.
Würden wir nun einfach die GraphikObjekt-Klasse im Text nach vorne schieben,
so wäre dieses Problem gelöst. Gar nicht zu selten braucht man allerdings
im hinteren Element einen weiteren Zeiger auf die erste Klasse - in unserem
Fall tritt das zum Glück nicht auf - und dann wäre mit einer einfachen
Verschiebung niemandem geholfen. C++ hat für diesen Fall aber eine Lösung
parat: Man kann dem Compiler schon mal vor der Definition der Fensterklasse
einen Hinweis geben, dass man später eine Klasse "GraphikObjekt" einführen
wird. Das ist solange erlaubt, wie man nur Zeiger auf diese bislang
undefinierte Klasse verwendet. Dies sieht im Quellcode dann so aus:

//
// Vorwärtsdeklaration der GraphikObjekt-Klasse
class GraphikObjekt;

class Fenster {
        ...

Hinter dem Semikolon ist dann erst mal Schluss - für den Compiler ein
Hinweis auf "mehr über diese Klasse weiter unten". Klar, dass man mit einer
so deklarierten Klasse nicht sehr viel anderes anfangen kann, als gerade mal
Pfeilchen - sprich Pointer - auf solche Objekte aufzustellen.

Der so modifizierte Quellcode kompiliert erst mal, aber verwendet die Zeiger
natürlich noch nicht - das müssen wir schon selbst tun. Eine der wichtigsten
elementaren Operationen für Listen ist das Einfügen eines Elementes in eine
Liste: Ist "F" das Fensterobjekt und "g,h" die GraphikObjekte dieses Fensters,
so könnte eine Konstellation vor dem Einfügen eines Objektes etwa so
veranschaulicht werden:

        F --> g --> h

Dies bedeutet, "erstesobjekt" des Fensters zeigt auf das Objekt g,
"nachfolger" von g zeigt auf h, und "nachfolger" von "h" bleibt leer -
also ist NULL. Wollen wir nun ein Element "i" einfügen, so macht man dies am
einfachsten so, indem man zunächst den Nachfolger von "i" auf das bislang
erste Listenelement "g" zeigen lässt:

              i
              |
              V
        F --> g --> h

und dann in einem zweiten Schritt den "erstesobjekt"-Zeiger des Fensters auf
"i" umbiegt. Damit macht die Liste zwar grafisch einen Schlenker, aber alle
Elemente sind wieder hübsch aufgereiht:

          _  i
          /| |
         /   V
        F    g --> h

Dieses Einfügen eines Elementes geschieht in einer Liste, die der Fensterklasse
gehört, und sollte dementsprechend auch dort als Methode aufgenommen werden:

        // Einfügen eines GraphikObjekt in das Fenster
        void ReiheEin(GraphikObjekt *obj)
        {
                // nachfolger dieses Objektes auf das
                // erste Objekt setzen:
                obj->nachfolger = erstesobjekt;
                // das erste Objekt ist dann dieses hier
                erstesobjekt    = obj;
        }

Diese Methode funktioniert sogar dann - der Leser möge einmal scharf nachdenken -
wenn die Liste am Anfang leer ist, also "erstesobjekt" noch auf NULL steht. Zur
Erinnerung: "->" bedeutet "folge dem Pfeil, dann werte das Member rechts vom
Pfeil aus". "obj->nachfolger" ist das gleiche wie "(*obj).nachfolger", siehe den
letzten Teil.

Nur leider gibt's wieder zwei Probleme: Erstens, GraphikObjekt ist an dieser
Stelle nicht definiert, sondern nur über eine Vorwärtsreferenz deklariert, der
Compiler kann also noch gar nicht wissen, dass es eine Member "nachfolger"
eines GraphikObjekt gibt. Zweitens ist der auch noch "privat", also darf die
Fensterklasse nicht darauf zugreifen - sollte sie aber können!

Das erste Problem ist leicht gelöst: Wir verschieben die Definition dieser
Methode nach unten:

        // Einfügen eines GraphikObjekt in das Fenster
        void ReiheEin(GraphikObjekt *obj);

In der Klasse selbst gibt es also wieder nur eine Vorwärtsreferenz auf die
noch zu definierten Methode, und direkt über "main" fügen wir die noch
fehlende Definition ein:

// Einfügen eines GraphikObjekt in das Fenster
void Fenster::ReiheEin(GraphikObjekt *obj)
{
        // nachfolger dieses Objektes auf das
        // erste Objekt setzen:
        obj->nachfolger = erstesobjekt;
        // das erste Objekt ist dann dieses hier
        erstesobjekt    = obj;
}

Das "Fenster::" besagt: Hier kommt eine Methode der Klasse "Fenster". Ohne
den "::"-Operator, der auch "Scope-Operator" heißt, würde der Compiler dies
als eine globale Funktion interpretieren, die nichts mit dem Fensterobjekt
gemein hat.


Fehlt noch die Lösung des zweiten Problems: Wie erlaubt man den Zugriff auf
das "nachfolger"-Member der GraphikObjekt-Klasse vom Fenster aus? Eine
Möglichkeit wäre wieder, eine Zugriffsfunktion zu bauen, doch diese würde auch
allen anderen Objekten einen Zugriff auf diese eigentlich zum Fenster gehörende
Liste gestatten. Darum möchte ich Zugriff auf dieses Member exklusiv für die
ReiheEin-Methode des Fensters gestatten; dies erklärt man dem C++ Compiler
mittels:

class GraphikObjekt {
        friend void Fenster::ReiheEin(GraphikObjekt *);
        //
        // Der Zeiger auf den Nachfolger dieses Graphikobjektes
        GraphikObjekt    *nachfolger;

womit diese eine Funktion mit dem "GraphikObjekt" befreundet wird.

Nach diesen Ausbauarbeiten können wir problemlos die Linien, Punkte, und
Ellipsenobjekte in das Fenster einfügen: In "main" sieht das dann so aus:

        f.ReiheEin(&p);
        f.ReiheEin(&l);
        f.ReiheEin(&e);

Man entsinne sich, "&" liefert einen Pointer auf das dahinterstehende Objekt.

Das gesamte Programm sieht damit wie folgt aus:

#include <iostream.h>

extern "C" {
#include <intuition/intuition.h>
#include <graphics/rastport.h>
#include <proto/intuition.h>
#include <proto/graphics.h>
#include <proto/exec.h>
}


//
// Vorwärtsdeklaration der GraphikObjekt-Klasse
class GraphikObjekt;

class Fenster {
        Window *window;         // Das Intuition-Fenster davon
        int breite,hoehe;       // Dimensionen
        //
        // Hier beginnt die Liste aller grafischen Objekte dieses Fensters
        GraphikObjekt *erstesobjekt;
        //
public:
        Fenster(int b,int h)
        :       window(NULL), breite(b), hoehe(h), erstesobjekt(NULL)
        {
                window = OpenWindowTags(NULL,
                        WA_GimmeZeroZero,TRUE,  // Ursprung ist im Zeichenbereich
                        WA_SmartRefresh,TRUE,   // Automatisch wiederherstellen wenn verdeckt
                        WA_InnerWidth,b,
                        WA_InnerHeight,h,
                        WA_CloseGadget,TRUE,    // Fenster hat Schließknopf
                        WA_DragBar,TRUE,        // Fenster kann verschoben werden
                        WA_DepthGadget,TRUE,    // Fenster kann nach vorne/hinten gebracht werden
                        WA_IDCMP,IDCMP_CLOSEWINDOW,
                        TAG_DONE);
        }
        //
        // Der Destruktor löscht auch wieder das Fenster davon, falls offen.
        ~Fenster(void)
        {
                if (window) {
                        CloseWindow(window);
                }
        }
        //
        // Liefere die Zeichenfläche des Fensters. Dies nennt sich RastPort
        RastPort *RastPort_Hiervon(void) const
        {
                return window->RPort;
        }
        //
        // Warte, bis der Benutzer das Close-Gadget drückt.
        void WarteAufSchliessen(void) const
        {
                struct Message *msg;

                msg = WaitPort(window->UserPort);
                msg = GetMsg(window->UserPort);
                ReplyMsg(msg);
        }
        //
        // Einfügen eines GraphikObjekt in das Fenster
           void ReiheEin(GraphikObjekt *obj);
};

class GraphikObjekt {
        friend void Fenster::ReiheEin(GraphikObjekt *);
        //
        // Der Zeiger auf den Nachfolger dieses Graphikobjektes
        GraphikObjekt    *nachfolger;
        //
protected:
        RastPort        *rp;
        int              farbe;
        //
        // Wähle unsere Farbe im RastPort
        void SetzeFarbe(void) const
        {
                SetAPen(rp,farbe);
        }
        //
public:
        GraphikObjekt(RastPort *port,int f = 1)
        : nachfolger(NULL), rp(port), farbe(f)
        { }
        //
        void Zeichne(void)
        {
                // Da wir nicht wissen, welches Objekt das
                // hier ist, können wir natürlich auch nichts
                // zeichnen....
                cout<<"Dieses Objekt ist nicht zeichenbar.\n";
        }
};

struct Punkt {
        int x,y;
        //
        Punkt(int x0,int y0)
        : x(x0), y(y0)
        { }
};

class Pixel : public GraphikObjekt {
        struct Punkt    position;       // Ort des Pixels
        //
public:
        // Konstruktor des Objektes: Zeichenfläche, Farbe,
        // Position.
        Pixel(RastPort *port, int f, int x, int y)
        : GraphikObjekt(port,f), position(x,y)
        { }
        //
        // Noch ein Konstruktor: Dieser bekommt die
        // Position als Referenz übergeben
        Pixel(RastPort *port, int farbe, Punkt &pos)
        : GraphikObjekt(port, farbe), position(pos)
        { }
        //
        // Ein "farbloser" Konstruktor
        Pixel(RastPort *port, int x, int y)
        : GraphikObjekt(port), position(x,y)
        { }
        //
        // und noch mal das gleiche, jedoch mit einer
        // Punktstruktur
        Pixel(RastPort *port, Punkt &pos)
        : GraphikObjekt(port), position(pos)
        { }
        //
        //
        // Mach' 'nen Punkt!
        void Zeichne(void)
        {
                SetzeFarbe();
                WritePixel(rp,position.x,position.y);
        }
};

//
// von Punkten zu Linien:
//
class Linie : public GraphikObjekt {
        struct Punkt    anfang,ende;    // wo beginnt und wo endet die Linie?
        //
public:
        // Konstruktor des Objektes: Zeichenfläche, Farbe,
        // Start/Endpunkte
        Linie(RastPort *port, int f, int x0, int y0, int x1, int y1)
        : GraphikObjekt(port,f), anfang(x0,y0), ende(x1,y1)
        { }
        //
        // Noch ein Konstruktor: Dieser bekommt die
        // Positionen als Referenzen übergeben
        Linie(RastPort *port, int farbe, Punkt &von, Punkt &bis)
        : GraphikObjekt(port, farbe), anfang(von), ende(bis)
        { }
        //
        // Ein "farbloser" Konstruktor
        Linie(RastPort *port, int x0, int y0, int x1, int y1)
        : GraphikObjekt(port), anfang(x0,y0), ende(x1,y1)
        { }
        //
        // und noch mal das gleiche, jedoch mit einer
        // Punktstruktur
        Linie(RastPort *port, Punkt &von, Punkt &bis)
        : GraphikObjekt(port), anfang(von), ende(bis)
        { }
        //
        //
        // Mach' 'nen Strich
        void Zeichne(void)
        {
                SetzeFarbe();
                Move(rp,anfang.x,anfang.y);
                Draw(rp,ende.x,ende.y);
        }
};

//
// von Linien zu Ellipsen:
//
class Ellipse : public GraphikObjekt {
        struct Punkt    mittelpunkt;    // wo ist die Ellipse zentriert?
        int                             radiusx,radiusy; // Radien in x- und y-Richtung
        //
public:
        // Konstruktor des Objektes: Zeichenfläche, Farbe,
        // Mittelpunkt, Radien
        Ellipse(RastPort *port, int f, int x, int y, int rx, int ry)
        : GraphikObjekt(port,f), mittelpunkt(x,y),
          radiusx(rx), radiusy(ry)
        { }
        //
        // Noch ein Konstruktor: Dieser bekommt die
        // Position als Referenz übergeben
        Ellipse(RastPort *port, int farbe, Punkt &zentrum, int rx, int ry)
        : GraphikObjekt(port, farbe), mittelpunkt(zentrum),
          radiusx(rx), radiusy(ry)
        { }
        //
        // Ein "farbloser" Konstruktor
        Ellipse(RastPort *port, int x, int y, int rx, int ry)
        : GraphikObjekt(port), mittelpunkt(x,y),
          radiusx(rx), radiusy(ry)
        { }
        //
        // und noch mal das gleiche, jedoch mit einer
        // Punktstruktur
        Ellipse(RastPort *port, Punkt &zentrum, int rx, int ry)
        : GraphikObjekt(port), mittelpunkt(zentrum),
          radiusx(rx), radiusy(ry)
        { }
        //
        //
        // Mach' 'nen Kreis
        void Zeichne(void)
        {
                SetzeFarbe();
                DrawEllipse(rp,mittelpunkt.x,mittelpunkt.y,radiusx,radiusy);
        }
};

// Einfügen eines GraphikObjekt in das Fenster
void Fenster::ReiheEin(GraphikObjekt *obj)
{
        // nachfolger dieses Objektes auf das
        // erste Objekt setzen:
        obj->nachfolger = erstesobjekt;
        // das erste Objekt ist dann dieses hier
        erstesobjekt    = obj;
}

int main(int argc, char **argv)
{
Fenster f(200,200);             // baue ein Fenster der Größe 200x200
Pixel p(f.RastPort_Hiervon(),1,50,50);
Linie l(f.RastPort_Hiervon(),Punkt(30,40),Punkt(50,70));
Ellipse e(f.RastPort_Hiervon(),70,70,20,50);

                f.ReiheEin(&p);
                f.ReiheEin(&l);
                f.ReiheEin(&e);

                p.Zeichne();
                l.Zeichne();
                e.Zeichne();

                f.WarteAufSchliessen();

      return 0;
}



Virtuelle Methoden, abstrakte Klassen und reale Probleme

Das Anlegen einer linearen Liste mag ja eine interessante Programmieraufgabe
sein, aber nur zum Selbstzweck ist diese Übung doch etwas zu aufwendig. Die
Liste soll jetzt also auch praktisch verwendet werden:

Da wir nun jedes der zu zeichnenden Objekte in das Fensterobjekt eingehängt
haben - es ist ja Teil seiner Objektliste geworden - müssen wir eigentlich die
Objekte nicht mehr alle einzeln zeichnen. Stattdessen können wir das dem
Fensterobjekt selbst überlassen, da es ja weiß, welche Objekte in ihm
stecken. Insofern sollen die drei Zeilen

                p.Zeichne();
                l.Zeichne();
                e.Zeichne();

in main() entfallen, und stattdessen durch einen Aufruf einer noch zu
schreibenden Methode

                f.ZeichneObjekte();

ersetzt werden, wobei diese Methode des Fensters eben alle in dem Fenster
verwalteten Objekte auf den Schirm zaubern soll. Fügen wir also in der
Fensterklasse noch folgende Deklaration ein:

class Fenster {
        ...
        // Einfügen eines GraphikObjekt in das Fenster
        void ReiheEin(GraphikObjekt *obj);
        //
        // Zeichne alle Objekte des Fensters
        void ZeichneObjekte(void);
};

Da wir innerhalb von ZeichneObjekte() sicherlich auf die GraphikObjekt-Klasse
zurückgreifen müssen - diese Klasse beschreibt ja die zu zeichnenden Objekte -
können wir die Methode ZeichneObjekte() nicht direkt im Rumpf der Fensterklasse
definieren. Dieses Problem hatten wir oben bei "ReiheEin()" bereits schon
einmal. Stattdessen fügen wir die Definition von ZeichneObjekte() direkt über
der Definition von main() ein:

// Malen aller Objekte des Fensters
void Fenster::ZeichneObjekte(void)
{
GraphikObjekt *objekt;

        //
        // hole das erste Element der Liste
        objekt = erstesobjekt;
        // wiederhole das Folgende solange, wie
        // wir das Ende der Liste noch nicht
        // erreicht haben.
        while(objekt) {
                // Zeichne dieses Objekt
                objekt->Zeichne();
                // hole das nächste Objekt
                // dieser Liste
                objekt = objekt->nachfolger;
        }
        // das war's.
}

Was geschieht hier? Zunächst deklarieren wir einen Zeiger auf ein
GraphikObjekt. Dieser Zeiger wird dann initialisiert mit dem Zeiger auf das
erste Element der Objektliste, die wir im Fenster im Member "erstesobjekt"
aufheben. Sieht diese Liste wie folgt aus:

        F-->i-->h-->g

wobei "F" das Fensterobjekt und damit "erstesobjekt" auf "i" zeigt, so ist
nach diesem Schritt "objekt" ein Zeiger auf "i". Wir gehen dann in die
folgende while()-Liste hinein: Sie führt die Anweisungen im Schleifenrumpf
solange aus, wie die Bedingung in den Klammern hinter dem
while()-Schlüsselwort erfüllt ist, also - man vergleiche noch mal mit oben -
solange "objekt" nicht der NULL-Zeiger ist. Ist er in diesem Beispiel nicht,
denn "objekt" zeigt ja auf "i". Innerhalb der Schleife wird dann "i"
gezeichnet: "i->Zeichne()", wobei man sich nochmals über die Bedeutung des
"->" Pfeilchens klar sein sollte. In der Zeile darunter

"objekt = objekt->nachfolger"

wird der Objektzeiger umgesetzt, nämlich auf das Objekt, auf den der
Nachfolgerzeiger des bisherigen Objektes zeigt. Zeigt also "objekt" wie in
unserem Beispiel zunächst auf "i", so zeigt es danach auf "h". Die Schleife
kehrt zur Abfrage zurück: h ist nicht NULL - also weiter! Danach wird "h"
gezeichnet, und der Zeiger weitergeschaltet, und zwar auf "g". "g" ist nicht
NULL, also wird die Schleife nochmals ausgeführt: g zeichnen, danach
weiterschalten. Der Nachfolger von "g" ist niemand - sein Nachfolgerzeiger
steht auf NULL. Also wird jetzt "objekt" auf NULL gesetzt, und die Schleife
wird abgebrochen. Damit sind ja nun auch alle Objekte gezeichnet.

Es bleibt noch eine offensichtliche Schwierigkeit: Wir müssen der Methode
"ZeichneObjekte" ja noch den Zugriff auf das private Member "nachfolger"
von GraphikObjekt ermöglichen! Das ist leicht erledigt:

class GraphikObjekt {
        friend void Fenster::ReiheEin(GraphikObjekt *);
        friend void Fenster::ZeichneObjekte(void);
        //
        ...
};

Ändern wir nun main() wie besprochen ab und kompilieren den Code:

int main(int argc, char **argv)
{
Fenster f(200,200);             // baue ein Fenster der Größe 200x200
Pixel p(f.RastPort_Hiervon(),1,50,50);
Linie l(f.RastPort_Hiervon(),Punkt(30,40),Punkt(50,70));
Ellipse e(f.RastPort_Hiervon(),70,70,20,50);

                f.ReiheEin(&p);
                f.ReiheEin(&l);
                f.ReiheEin(&e);

                f.ZeichneObjekte();
                f.WarteAufSchliessen();

      return 0;
}

Wird dieses Programm gestartet, so wird man allerdings enttäuscht:

Zunächst erscheint ein leeres Fenster, ganz ohne Objekte. Schließt man das
Fenster, erscheint ein Konsolenfenster, in dem nur dreimal der Text:
"Dieses Objekt ist nicht zeichenbar." steht. Na nu, belügt uns der Compiler?
Die Objekte Punkt, Linie und Ellipse sind doch zeichenbar? Wo kommt also der
Text her? Nun, eine kleine Suche im Quelltext zeigt folgendes:

class GraphikObjekt {
        ...
        void Zeichne(void)
        {
                // Da wir nicht wissen, welches Objekt das
                // hier ist, können wir natürlich auch nichts
                // zeichnen....
                cout<<"Dieses Objekt ist nicht zeichenbar.\n";
        }
}

Der Code hat also die Methode "Zeichne" des GraphikObjekt aufgerufen, und
nicht die der Punkte, Linien oder Ellipsen. Das liegt nun daran, dass
innerhalb von Fenster::ZeichneObjekte() wir objekt->Zeichne() aufrufen,
und "objekt" ist ein Zeiger auf ein GraphikObjekt. Dass es sich hierbei
"in Wirklichkeit" um einen Punkt, eine Linie und eine Ellipse handelt, weiß
der Compiler zum Zeitpunkt des Kompilierens nicht! Und genau *hier* ist das
Problem!
Die Bindung der Methode "Zeichne" an ein Objekt - also die Feststellung, zu
welchem Objekt denn nun "Zeichne" gehört, findet zur Kompilationszeit statt!
Und das ist falsch - stattdessen wollen wir erreichen, dass dasjenige
"Zeichne" aufgerufen wird, das wirklich zu dem jeweiligen Objekt gehört.
Die Bindung muss, wie man sagt, zur Laufzeit aufgelöst werden.

Man kann genau das dem C++-Compiler mitteilen, indem man vor die
entsprechende Methode der Basisklasse das Schlüsselwort "virtual" setzt. Dies
ist ein Hinweis für den Compiler, einen Aufruf dieser Methode erst zur
Laufzeit aufzulösen. Ändern wir also

class GraphikObjekt {
        ...
        virtual void Zeichne(void)
        {
                // Da wir nicht wissen, welches Objekt das
                // hier ist, können wir natürlich auch nichts
                // zeichnen....
                cout<<"Dieses Objekt ist nicht zeichenbar.\n";
        }
}

Konsequenterweise sollte man nun auch alle Zeichne-Methoden der vom
GraphikObjekt abgeleiteten Klassen als "virtuell" deklarieren, aber dies ist
nicht notwendig: Das macht der Compiler von selbst.

Kompiliert und startet man dieses Programm, so erhält man wieder den
gewünschten Effekt: Ein modernes Kunstwerk, bestehend aus einer Linie, einem
Punkt und einem Kreis in einem Fenster.

An dieser Stelle wieder eine Designfrage: Brauchen wir eigentlich eine
Zeichne-Methode des GraphikObjekt?
Eigentlich nicht, denn dieses Objekt dient ja quasi nur als "Container" für
dafür abgeleitete Klassen und "existiert nie wirklich", sondern nur in der
Form eines seiner Kinder. Es gibt nun in C++ eine Möglichkeit, genau diesen
Willen auszudrücken, nämlich eine Klasse nur als eine reine Interface-
Spezifikation zu verstehen, die man erst ableiten muss, um konkret damit
arbeiten zu können. Dies geschieht durch folgende Änderung:

class GraphikObjekt {
        ..
        virtual void Zeichne(void) = 0;
        //
}

Das "=0;" sagt dem Compiler: Diese Methode ist gar nicht da! Versucht man jetzt
etwa ein GraphikObjekt in main mit dem Konstruktur

GraphikObjekt g(f.RastPort_Hiervon(),1);

zu erstellen, so meldet der Compiler einen Fehler:

Error: Class "GraphikObjekt" is abstract (pure virtual function "Zeichne").

Die Klasse "GraphikObjekt" ist als sie selbst gar nicht mehr erzeugbar, da
die Methode Zeichne() gar nicht da ist! Solche Methoden nennt man "pure
virtual", also "rein virtuell", aus verständlichen Gründen, und derartige
Klassen heißen "abstrakt".

Das ganze Programm sieht damit so aus:

extern "C" {
#include <intuition/intuition.h>
#include <graphics/rastport.h>
#include <proto/intuition.h>
#include <proto/graphics.h>
#include <proto/exec.h>
}


//
// Vorwärtsdeklaration der GraphikObjekt-Klasse
class GraphikObjekt;

class Fenster {
        Window *window;                         // Das Intuition-Fenster davon
        int breite,hoehe;       // Dimensionen
        //
        // Hier beginnt die Liste aller grafischen Objekte dieses Fensters
        GraphikObjekt *erstesobjekt;
        //
public:
        Fenster(int b,int h)
        :       window(NULL), breite(b), hoehe(h), erstesobjekt(NULL)
        {
                window = OpenWindowTags(NULL,
                                WA_GimmeZeroZero,TRUE, // Ursprung ist im Zeichenbereich
                                WA_SmartRefresh,TRUE,  // Automatisch wiederherstellen wenn verdeckt
                                WA_InnerWidth,b,
                                WA_InnerHeight,h,
                                WA_CloseGadget,TRUE,   // Fenster hat Schließknopf
                                WA_DragBar,TRUE,       // Fenster kann verschoben werden
                                WA_DepthGadget,TRUE,   // Fenster kann nach vorne/hinten gebracht werden
                                WA_IDCMP,IDCMP_CLOSEWINDOW,
                                TAG_DONE);
        }
        //
        // Der Destruktor löscht auch wieder das Fenster davon, falls offen.
        ~Fenster(void)
        {
                if (window) {
                        CloseWindow(window);
                }
        }
        //
        // Liefere die Zeichenfläche des Fensters. Dies nennt sich RastPort
        RastPort *RastPort_Hiervon(void) const
        {
                return window->RPort;
        }
        //
        // Warte, bis der Benutzer das Close-Gadget drückt.
                void WarteAufSchliessen(void) const
        {
                struct Message *msg;

                msg = WaitPort(window->UserPort);
                msg = GetMsg(window->UserPort);
                ReplyMsg(msg);
        }
        //
        // Einfügen eines GraphikObjekt in das Fenster
        void ReiheEin(GraphikObjekt *obj);
        //
        // Zeichne alle Objekte des Fensters
        void ZeichneObjekte(void);
};

class GraphikObjekt {
        friend void Fenster::ReiheEin(GraphikObjekt *);
        friend void Fenster::ZeichneObjekte(void);
        //
        // Der Zeiger auf den Nachfolger dieses Graphikobjektes
        GraphikObjekt    *nachfolger;
        //
protected:
        RastPort        *rp;
        int              farbe;
        //
        // Wähle unsere Farbe im RastPort
        void SetzeFarbe(void) const
        {
                SetAPen(rp,farbe);
        }
        //
public:
        GraphikObjekt(RastPort *port,int f = 1)
        : nachfolger(NULL), rp(port), farbe(f)
        { }
        //
        virtual void Zeichne(void) = 0;
        //
};

struct Punkt {
        int x,y;
        //
        Punkt(int x0,int y0)
        : x(x0), y(y0)
        { }
};

class Pixel : public GraphikObjekt {
        struct Punkt    position;       // Ort des Pixels
        //
public:
        // Konstruktor des Objektes: Zeichenfläche, Farbe,
        // Position.
        Pixel(RastPort *port, int f, int x, int y)
        : GraphikObjekt(port,f), position(x,y)
        { }
        //
        // Noch ein Konstruktor: Dieser bekommt die
        // Position als Referenz übergeben
        Pixel(RastPort *port, int farbe, Punkt &pos)
        : GraphikObjekt(port, farbe), position(pos)
        { }
        //
        // Ein "farbloser" Konstruktor
        Pixel(RastPort *port, int x, int y)
        : GraphikObjekt(port), position(x,y)
        { }
        //
        // und noch mal das gleiche, jedoch mit einer
        // Punktstruktur
        Pixel(RastPort *port, Punkt &pos)
        : GraphikObjekt(port), position(pos)
        { }
        //
        //
        // Mach' 'nen Punkt!
        void Zeichne(void)
        {
                SetzeFarbe();
                WritePixel(rp,position.x,position.y);
        }
};

//
// von Punkten zu Linien:
//
class Linie : public GraphikObjekt {
        struct Punkt    anfang,ende;    // wo beginnt und wo endet die Linie?
        //
public:
        // Konstruktor des Objektes: Zeichenfläche, Farbe,
        // Start/Endpunkte
        Linie(RastPort *port, int f, int x0, int y0, int x1, int y1)
        : GraphikObjekt(port,f), anfang(x0,y0), ende(x1,y1)
        { }
        //
        // Noch ein Konstruktor: Dieser bekommt die
        // Positionen als Referenzen übergeben
        Linie(RastPort *port, int farbe, Punkt &von, Punkt &bis)
        : GraphikObjekt(port, farbe), anfang(von), ende(bis)
        { }
        //
        // Ein "farbloser" Konstruktor
        Linie(RastPort *port, int x0, int y0, int x1, int y1)
        : GraphikObjekt(port), anfang(x0,y0), ende(x1,y1)
        { }
        //
        // und noch mal das gleiche, jedoch mit einer
        // Punktstruktur
        Linie(RastPort *port, Punkt &von, Punkt &bis)
        : GraphikObjekt(port), anfang(von), ende(bis)
        { }
        //
        //
        // Mach' 'nen Strich
        void Zeichne(void)
        {
                SetzeFarbe();
                Move(rp,anfang.x,anfang.y);
                Draw(rp,ende.x,ende.y);
        }
};

//
// von Linien zu Ellipsen:
//
class Ellipse : public GraphikObjekt {
        struct Punkt    mittelpunkt;    // wo ist die Ellipse zentriert?
        int                             radiusx,radiusy; // Radien in x- und y-Richtung
        //
public:
        // Konstruktor des Objektes: Zeichenfläche, Farbe,
        // Mittelpunkt, Radien
        Ellipse(RastPort *port, int f, int x, int y, int rx, int ry)
        : GraphikObjekt(port,f), mittelpunkt(x,y),
          radiusx(rx), radiusy(ry)
        { }
        //
        // Noch ein Konstruktor: Dieser bekommt die
        // Position als Referenz übergeben
        Ellipse(RastPort *port, int farbe, Punkt &zentrum, int rx, int ry)
        : GraphikObjekt(port, farbe), mittelpunkt(zentrum),
          radiusx(rx), radiusy(ry)
        { }
        //
        // Ein "farbloser" Konstruktor
        Ellipse(RastPort *port, int x, int y, int rx, int ry)
        : GraphikObjekt(port), mittelpunkt(x,y),
          radiusx(rx), radiusy(ry)
        { }
        //
        // und noch mal das gleiche, jedoch mit einer
        // Punktstruktur
        Ellipse(RastPort *port, Punkt &zentrum, int rx, int ry)
        : GraphikObjekt(port), mittelpunkt(zentrum),
          radiusx(rx), radiusy(ry)
        { }
        //
        //
        // Mach' 'nen Kreis
        void Zeichne(void)
        {
                SetzeFarbe();
                DrawEllipse(rp,mittelpunkt.x,mittelpunkt.y,radiusx,radiusy);
        }
};

// Einfügen eines GraphikObjekt in das Fenster
void Fenster::ReiheEin(GraphikObjekt *obj)
{
        // nachfolger dieses Objektes auf das
        // erste Objekt setzen:
        obj->nachfolger = erstesobjekt;
        // das erste Objekt ist dann dieses hier
        erstesobjekt    = obj;
}

// Malen aller Objekte des Fensters
void Fenster::ZeichneObjekte(void)
{
GraphikObjekt *objekt;

        //
        // hole das erste Element der Liste
        objekt = erstesobjekt;
        // wiederhole das folgende solange wie
        // wir das Ende der Liste noch nicht
        // erreicht haben.
        while(objekt) {
                // Zeichne dieses Objekt
                objekt->Zeichne();
                // hole das nächste Objekt
                // dieser Liste
                objekt = objekt->nachfolger;
        }
        // das war's.
}

int main(int argc, char **argv)
{
Fenster f(200,200);             // baue ein Fenster der Größe 200x200
Pixel p(f.RastPort_Hiervon(),1,50,50);
Linie l(f.RastPort_Hiervon(),Punkt(30,40),Punkt(50,70));
Ellipse e(f.RastPort_Hiervon(),70,70,20,50);

                f.ReiheEin(&p);
                f.ReiheEin(&l);
                f.ReiheEin(&e);

                f.ZeichneObjekte();

                f.WarteAufSchliessen();

      return 0;
}

Halten wir also fest: Mittels des Schlüsselwortes "virtual" erfolgt die
Bindung einer Methode an ein Objekt zur Laufzeit, und nicht zur Compilerzeit.
Dass dies durchaus etwas Unterschiedliches sein kann, haben wir oben gesehen:
Mit "virtual" ruft man diejenige Methode auf, die "wirklich zu dem einzelnen
Objekt" gehört, ohne "virtual" diejenige, die zur Klasse gehört, die der
Compiler zur Compilezeit feststellen kann.

Warum macht man also nicht gleich alles "virtual", denn damit werden doch
offenbar Methoden "gleich richtig" an die wirklichen Objekte gebunden, und
nicht an das, was der Compiler für richtig hält"?

Auf diese Frage gibt es zwei Anworten: Erstens, eventuell will man genau das
nicht. In bestimmten Anwendungen kann es durchaus sinnvoll sein, eine bestimmte
Methode nur zur Compilezeit an das Objekt zu binden. Die zweite Antwort ist
eine rein praktische: "virtuelle" Bindungen sind langsamer. Ein Funktionsaufruf
einer "virtuellen" Methode dauert - abhängig vom Compiler - ein klein wenig
länger. Virtuelle Methoden sind auch schlechter optimierbar. Für normale
Anwendungen mag dies unwesentlich sein, für bestimmte zeitkritische Probleme
aber sollte man dann auf "virtual" verzichten.

Ein Blick über den Tellerrand: In der mit C++ verwandten Sprache "Java"
sind Methoden immer virtuell, es sei denn man deklariert sie als "final".
Abstrakte Klassen heißen dort auch "interfaces", was eine etwas treffendere
Namengebung ist.


Ausblicke:

Dies war eine ganze Menge Holz für diesen Kurs: Wir haben uns mit
Designproblemen beschäftigt, mit linearen Listen und mit virtuellen Methoden
vererbter Klassen. Der Leser ist natürlich herzlich dazu aufgefordert, das
bisherige Programm etwas aufzubohren und zu ergänzen.

Demnächst auf diesem Kanal: Wir werden uns weiterhin mit einigen Design-
Problemchen beschäftigen, insbesondere mit Konstruktoren und Destruktoren
abgeleiteter und abstrakter Klassen, mit dynamischer Speicherverwaltung
und, letztendlich, mit einem klarer strukturiertem Programmaufbau, mit der
Einteilung eines Programmes in Module. Inhaltlich werden wir uns mehr mit
dem Nachrichtensystem von Intuition auseinandersetzen, um mit dem Programm
auch etwas Praktisches anfangen zu können.

Thomas Richter <thor@math.TU-Berlin.DE>

@ENDNODE

@NODE "Workshops2" "Workshops"
@TOC "MAIN"

2. Workshop: Nachbearbeitung von Scans (von Michael Christoph)

Wer Bilder in den Computer einscannt, wird das Ergebnis meist
nachbearbeiten müssen, damit eine vernünftige Grafik dabei herauskommt.
Dazu existiert auf dem Amiga eine durchaus ansehnliche Anzahl an
Grafikprogrammen:

  ArtEffect, Haage & Partner
  fxPaint, Innovative Software
  ImageFX, Nova Design
  Perfect Paint, Halvadjian Georges
  Photogenics, Idruna Software

Anhand der "ArtEffect Plugin Collection CD" bzw. deren Filter und Effekte
soll hier die exemplarische Vorgehensweise beschrieben werden.


* Das Ausgangsmaterial ist schlecht

Als Ausgangsmaterial und Beispiel dient uns eine Grafik von Buffy, die dem
Kalender "Buffy the vampire slayer" (ISBN 0-7683-4484-0) entnommen wurde.
Dabei fällt nämlich auch sofort negativ ein Raster- bzw. Moiremuster über
der gescannten Grafik auf. Grund dafür ist die Art des Druckes.
Unterschieden wird zwischen Rasterdruck und Ditherdruck. Beim Rasterdruck
werden die Farben aus unterschiedlich großen Druckpunkten gebildet, wobei
die Farben in voneinander abweichenden Winkeln aufgebracht werden. Beim
Ditherverfahren hingegen werden nur kleine Farbpunkt verwendet. Für
intensive/dunklere Farben werden viele Bildpunkte nebeneinander gedruckt.
Dabei kommt allerdings kein regelmäßiges Raster zum Einsatz, sondern
unregelmäßige Abstände.

Der Scanner tastet die Vorlage zeilenweise ab, wobei die Zeile aus vielen
nebeneinander liegenden Bildpunkten besteht. Beim Rasterdruck führt dies
dann zu einem mehr oder weniger stark sichtbarem Raster. Soviel zur
eigentlichen Technik im kurzen.


* Mögliche Lösungen

Es gibt nun verschiedene Arten, wie diese Störungen beseitigt werden
können.

1. Von Hand ausbessern

Die aufwändigste Möglichkeit, die mit jedem Programm möglich ist, ist die
manuelle Nachbearbeitung von Hand. Diese kann mit der Lupe pixelgenau
geschehen oder grob mit einem größeren Pinsel und geringer Deckungskraft.
Da diese Vorgehensweise recht zeitaufwändig ist und viel Konzentration und
Fingerspitzengefühl erfordert, wird sie wohl nur selten zum Einsatz kommen.

2. Weichzeichnen

Wesentlich eleganter ist da schon der Effekt "Weichzeichnen" (zu finden im
Menü "Filter/Weichzeichner/Weichzeichnen"). Dieser vermischt teilweise die
einzelnen Bildpunkte und erzeugt dadurch feinere Übergänge. Dadurch
verlieren die Störungspunkte an Deckkraft und vermischen sich besser mit
ihrer Umgebung.
Ein entscheidender Nachteil ist allerdings, daß das komplette Bild
hierdurch leicht unscharf wird. Mehrmaliges Ausführen oder stärkere
Konzentration führen zu immer unschärferen Grafiken. Während dies bei
Grafiken nicht so schnell auffällt, ist es für Textpassagen überhaupt nicht
geeignet, da die Kantenschärfe der Buchstaben verlorengeht und somit die
Lesbarkeit reduziert und erschwert wird.

3. SmartBlur

Dieser Effekt (aus dem Menü "Filter/Weichzeichner/SmartBlur"), der mit der
Collection-CD installiert wurde, ist eine ideale Lösung für unser Problem.
Er beseitigt die störenden Stellen, ohne daß darunter die Schärfe des
Bildes zu stark leiden würde. Er ist daher auch zum Nachbearbeiten von
Textpassagen geeignet. Natürlich kann auch dieser Effekt keine Wunder
bewirken. Am besten ist immer noch eine möglichst sauber eingescannte
Grafik.


* Scanauflösung

Je nachdem, wofür die Grafik weiterverwendet werden soll, ist sie in
unterschiedlichen Auflösungen zu scannen. Durchschnittliche Werte sind:

   75 dpi: Webgrafiken
  150 dpi: normale und zu druckende Grafiken
  300 dpi: Fotos

Dabei sollte grundsätzlich in 24 Bit Farbtiefe gescannt werden. Bei Bedarf
kann die Grafik später im Malprogramm reduziert werden.

Man kann aber auch in höheren Auflösungen scannen, das Material
nachbearbeiten und erst dann auf eine geringere Auflösung reduzieren. Auch
hierdurch lassen sich Störungen verringern.


* Die Vorgehensweise im Einzelnen

- Zuerst wird das gewünschte Bild über den Menüpunkt "Projekt/Öffnen"
  geladen
- Ggf. über "Editieren/Beschneiden" oder "Editieren/Bildgröße" das Bild
  vorbereiten
- Sollen nicht alle Bereiche bearbeitet werden, können diese ausmaskiert
  werden. Dazu das Maskenwerkzeug in der Toolbar auswählen und den zu
  schützenden Bereich mit gedrückter linker Maustaste aufziehen. GGf. mit
  gehaltener ALT-Taste weitere Bereiche hinzunehmen oder mit gehaltener
  linker Amiga-Taste Bereich entfernen.
- Aus dem Menü "Filter/Weichzeichner" das SmartBlur-Einsteller-Fenster
  öffnen

Über "Edges" wird bestimmt, wie starke Kontraste behandelt werden.
"Hard" sorgt dafür, daß Bildteile mit starken Kontrasten als Kante
betrachtet werden und somit auch nicht verändert werden.
"Soft" rechnet je nach Edgethreshold-Einstellung mehr Unschärfe in die
gerade behandelten Bildteile ein. Mit Hilfe dieser Einstellung lassen sich
Störungen aus beinahe gleichfarbigen Flächen einfach entfernen.
Je weniger Kontrast im Bildteil, desto stärker die Unschärfe, die
eingerechnet wird.

Je kleiner der "Radius", desto weniger umliegende Pixel werden untersucht.
Kleinere Radien führen zu besseren Ergebnissen. Je kleiner der Wert bei
"Edgethreshold", desto unschärfer wird das Ergebnis.

- Über "Projekt/Speichern als" die nachbearbeitete Grafik unter einem
  neuen Namen und dem gewünschten Dateiformat auf Festplatte sichern.

Für Grafiken eignet sich am besten das JPEG-Format, das durch
unterschiedliche Komprimierungsraten die spätere Dateigröße bestimmt. Je
kleiner der Qualitätswert (bzw. je größer die Komprimierung), desto
schlechter wird das Ergebnis. Bis zu einem gewissen Grad ermöglicht es aber
auch das JPEG-Format, die anzuzeigende Grafik leicht zu glätten.
Wird die Grafik nur zwischengespeichert, um sie später noch weiter zu
bearbeiten, eignet sich PNG oder IFF besser, da diese verlustfrei speichern
und so die Originalqualität erhalten bleibt.


* Muster

Die nachfolgenden Grafiken sollten auf einem eigenen Bildschirm im
Echtfarbmodus betrachtet werden, damit die Ergebnisse deutlich sichtbar
werden.

Die Buffy-Grafik mit Weichzeichnen- und SmartBlur-Effekt
  @{"Grafik anzeigen" LINK "buffy_weich_blur.jpg/MAIN"}

Ein Text mit dem Weichzeichnen-, Schärfen- und SmartBlur-Effekt
  @{"Grafik anzeigen" LINK "bericht_text.jpg/MAIN"}

ArtEffect-Programm und Plugin Collection CD
  @{"Grafik anzeigen" LINK "arteffect_prgundcd.jpg/MAIN"}

Für Fans das komplette Kalenderblatt
  @{"Grafik anzeigen" LINK "buffy_aug2001.jpg/MAIN"}


* Noch mehr Informationen

Grundlagen zu den Scannertypen, zum Scannen selbst und Tipps zur
Nachbearbeitung finden sich auch im aktuellen Amiga Magazin 03/2002 und
04/2002 bzw. können online auf meinen Webseiten unter
http://www.meicky-soft.de/amiga-magazin/amindex.html gelesen werden (der
zweite Teil aus der Aprilausgabe steht ab etwa Mitte März bereit).

Michael Christoph <michael@meicky-soft.de>

@ENDNODE

@NODE "Workshops3" "Workshops"
@TOC "MAIN"

3. Update: So senkt ihr eure Telekom-Rechnung!

Weniger spektakulär als einen Monat zuvor präsentierte sich der
Telekommunikationsmarkt im Februar - allerdings sind die Preise dennoch
gesunken.

Hier nun die aktuelle Tariftabelle:

Günstigster Call-by-Call-Anbieter (ohne Anmeldung, Mindestumsatz, etc.):

Wann:    |        Wohin:  Festnetz -> Festnetz    Festnetz -> Mobilfunknetz
===========================================================================
tägl. 0-24 Uhr   Telestunt (0190076), 1,8 ct  Telebillig (0190029), 15,5 ct

Ortsgespräche können rund um die Uhr über Telestunt (0190076) für 1,8
ct./min. geführt werden, wobei der Anbieter bis 21 Uhr günstiger ist als
die Deutsche Telekom und in der übrigen Zeit eine verbraucherfreundlichere
Taktung bietet.

(Alle Angaben ohne Gewähr)


Die Tabelle sollte im Wesentlichen selbsterklärend sein, trotzdem einige
Anmerkungen:

* Angegeben ist jeweils der für 1 Verbindungsminute fällig werdende Betrag.

* 'Werktags' bedeutet montags bis freitags mit Ausnahme von Feiertagen.

* Auf http://www.muc.de/~hm/telefon-tarife/tarifzonen.html könnt ihr
  übrigens eure Ortsnetzabgrenzung in Erfahrung bringen. Denn sonst könnte
  es passieren, dass ihr "fälschlicherweise" mal nicht den günstigsten
  Anbieter benutzt.

* Bei Auslandsgesprächen läßt sich dagegen teilweise drastisch sparen,
  jedoch hat fast jedes Land einen anderen günstigsten Anbieter, so dass
  sich hier keine pauschale Aussage machen lässt. Allerdings gibt es im
  Internet Sites, auf denen sich der jeweils günstigste Tarif berechnen
  lässt. Mein Favorit: http://www.teltarif.de

* Alle in der Tabelle oben aufgeführten Anbieter rechnen im Minutentakt ab.
  Anbieter, die in einem - wie wir meinen unfairen - Mehr-Minuten-Takt
  abrechnen oder eine pauschale Verbindungsgebühr erheben, werden nicht
  berücksichtigt.

* Auf wenige Tage befristete Sonderaktionen werden nicht berücksichtigt.


Für weitere Informationen zu diesem Thema siehe AMIGA aktuell 8/98.

@ENDNODE

@NODE "Tests1" "Testberichte"
@TOC "MAIN"

Tests und Erfahrungsberichte
----------------------------

1. Kleine Helfer für den Amiga-Alltag (von Christian Aichinger)

Willkommen zu den "Kleinen Helfern" im März. Bin ich eigentlich der
Einzige, dem aufgefallen ist, daß die Aminet-Uploads immer weniger und
unregelmäßiger ausfallen? Ich hoffe doch, daß sich diese Situation in den
nächsten Monaten wieder bessert. Nichtsdestotrotz gibt es diesmal Reviews
über die Utilities PC2Am und PS3Mrec.

Viel Spaß beim Lesen!


PC2Am:

Wenn man sich mal so die Preise und Verfügbarkeit von Netzwerkkarten für
Amiga-Rechner anschaut, wird es so manchem Anwender, der seinen Amiga mit
einem PC vernetzen möchte oder muß, ganz kalt und heiß. Abgesehen davon,
ist wohl die komplizierte Konfiguration von Samba und TCP/IP nichts für
jedermann. Dasselbe dürfte sich auch Michal Kara, der Autor von PC2AM,
gedacht haben und hat daraufhin begonnen, ein Softwaresystem zu
programmieren, um Amiga-Rechner auf einfachste Weise und mit Hilfe der
seriellen oder parallelen Schnittstelle mit dem PC zu verbandeln.

Es wird also nichts weiter als ein serielles oder paralleles Nullmodemkabel
benötigt, das bei jedem PC-Händler für ca. 10 EUR zu bekommen ist.
Technisch ambitionierte und besonders sparsame Anwender dürfen sich sogar
am Zusammenbau eines eigenen parallelen Kabels versuchen. Die genaue
Pinbelegung wird in der englischsprachigen AmigaGuide-Anleitung
beschrieben. Der Amiga benötigt desweiteren mindestens Kickstart 2.0. Auf
dem PC wird ein MS-DOS 6.0 kompatibles Betriebssystem benötigt.

Was macht PC2Am nun eigentlich? PC2Am ist eine Art
Gerätetreiber/Dateisystem, das den PC unter AmigaOS wie eine eigene
Festplatte einbindet. Der Amiga fungiert hier sozusagen als Master und der
PC als Slave (also so, wie sich das auch gehört ;-)). PC-Laufwerke wie A:,
C: und E: werden unter AmigaOS als Unterverzeichnisse des PC-Laufwerks
dargestellt.

@{"Screenshot" LINK "pc2am1.png/MAIN"} (ab OS 3.0; PNG-Datatype muss installiert sein)

Die Installation und Konfiguration der benötigten Dateien und Treiber
erfolgt für jeden Rechner getrennt. Die etwas umfangreichere Installation
und Konfiguration auf der Amiga-Seite wird komplett durch ein sehr
komfortables Installerscript geregelt. Der Anwender muß nur angeben, ob
beide Rechner über die parallele oder die serielle Schnittstelle
miteinander verbunden sind, alle anderen Optionen sind auf Standardwerte
eingestellt, die nur in den seltensten Fällen geändert werden müssen.

Falls ein serielles Nullmodemkabel verwendet wird, muß zusätzlich noch der
Treiber und die entsprechende Unit für die Schnittstelle oder
Schnittstellenkarte ausgewählt werden. Auf einem Amiga, an dem nur die
originale Schnittstelle zur Verfügung steht, muß das serial.device
ausgewählt werden. Falls eine MultifaceCard 3 verwendet wird, handelt es
sich dabei um das duart.device und bei einer Silversurfer um das
silversurfer.device oder hypercom1.device. Näheres zu den Gerätetreibern
einer Schnittstellenkarte kann der (hoffentlich) beiliegenden Anleitung
entnommen werden.

Bei Verwendung der parallelen Schnittstelle hat man leider keine weiteren
Optionen, denn es wird nur der serienmäßig eingebaute Parallelport des
Amigas unterstützt. So kommt man leider nicht in den Genuß, auf die höhere
und zuverlässigere parallele Schnittstelle einer Hypercom oder MFC3
zurückzugreifen.

Falls zu einem späteren Zeitpunkt die Verbindung zwischen Amiga und PC
geändert werden soll (z.B. von seriell auf parallel oder umgedreht), kann
sich der Anwender einfach wieder dem Installerscript "ConfigPC" bedienen.
Es wird also zu keinem Zeitpunkt vom Anwender erwartet, daß er "per Hand"
den DOS-Driver-Eintrag ändern muß.

Die Installation auf dem PC erfolgt ähnlich unkompliziert. In der PC2AM-
Distribution befindet sich ein Unterverzeichnis namens "PutToPC", in dem
sich sämtliche auf der PC-Seite benötigte Dateien befinden. Dieses
Verzeichnis muß einfach auf eine PC-formatierte Diskette und danach auf die
Festplatte des PCs kopiert werden. Die Konfiguration erfolgt mit dem DOS-
Programm "PC2AMCFG.EXE", das sich in dieser Schublade befindet.

Dieses Programm erkundigt sich beim Anwender, ob es sich um eine serielle
oder parallele Verbindung handelt. Im Fall einer seriellen Verbindung muß
zusätzlich der Port (möglich sind COM1 bis COM4), die Baud-Rate (diese muß
mit der auf der Amiga-Seite gewählten Geschwindigkeit übereinstimmen) und
ein Interrupt (PC2AM selektiert automatisch den Default-Interrupt)
angegeben werden. Falls eine parallele Verbindung besteht, muß noch der
parallele Port (LPT1 oder LPT2) und die Art des verwendeten Kabels (siehe
oben) angegeben werden.

@{"Screenshot" LINK "pc2am2.png/MAIN"} (ab OS 3.0; PNG-Datatype muss installiert sein)

Nachdem die Konfiguration auch auf dem PC erledigt wurde, kann es losgehen.
Zuerst muß das Client-Programm auf dem PC gestartet werden. PC2Am liefert
dazu mehrere Versionen mit. PC2AMDEB.EXE ist eine Debug-Version, die im
normalen Betrieb nicht zum Einsatz kommen sollte. Die Version PC2AMRES.EXE
wird resident unter MS-DOS eingebunden - die aktuelle Konsole wird also für
weitere Eingaben nicht blockiert. Allerdings sollte der Anwender davon
absehen, dieses Programm unter irgendeiner Windows-Version zu verwenden.
Dieses Programm ist nur korrekt funktionsfähig, wenn es unter einer echten
DOS-Umgebung gestartet wird.
Im Normalfall sollte das Programm PC2AMIGA.EXE Verwendung finden. Dieses
kann sowohl unter MS-DOS als auch jeglicher Windows-Version (dann
allerdings in einer DOS-Box) verwendet werden. Kommt eine Windows-9x-
Version zum Einsatz, werden auf der Amiga-Seite auch lange Dateinamen zur
Verfügung gestellt. Unter Windows 3.x muß unbedingt darauf geachtet werden,
daß das Fenster der DOS-Box in jedem Fall aktiviert bleibt. Falls nicht,
kann es zu erheblichen Störungen und Fehlern bei der Datenübertragung
kommen. Unter Windows 9x ist dies nicht mehr der Fall, allerdings sollte in
den Programmeigenschaften von PC2AMIGA die Leerlaufaktivität auf "Hoch"
eingestellt werden.

Nachdem nun der Client auf dem PC läuft, kann auf der Amiga-Seite das PC-
Laufwerk angemeldet werden. Dazu wird entweder der DOS-Driver "PC" doppelt
angeklickt oder in einer Shell das Kommando "mount pc:" eingegeben. Nach
einer kurzen Wartezeit wird ein neues Laufwerk "PC" auf der Workbench
dargestellt und der Datenaustausch kann erfolgen. Mit dem Commodity
"PC2Amiga", das automatisch nach der Anmeldung in das Amiga-System
eingebunden wird, kann sich der Anwender über den Verlauf und etwaige
Übertragungsfehler auf dem laufenden halten.

@{"Screenshot" LINK "pc2am3.png/MAIN"} (ab OS 3.0; PNG-Datatype muss installiert sein)

Die Übertragungsgeschwindigkeit hängt von den verwendeten Rechner-
Konfigurationen und der Vernetzungsart ab. Die Verbindung über die serielle
Schnittstelle ist naturgemäß um einiges langsamer als die über die
parallele. Nähere Auskünfte über die Übertragungsgeschwindigkeiten von
Amiga zum PC und umgekehrt können mit dem Amiga-Shell-Programm "PC2AmSpeed"
ermittelt werden, das der PC2Am-Distribution beiliegt.

Desweiteren möchte ich noch darauf hinweisen, daß auf der Homepage eine
etwas aktuellere Version (V3.09c) von PC2Am zum Download bereitsteht. Falls
es also mit der Version 3.08 aus dem Aminet Probleme und Übertragungsfehler
geben sollte, kann der Anwender auch mit dieser Version sein Glück
versuchen.

Autor: Michal Kara
Aminet: comm/misc/PC2Am308.lha
Programmversion: 3.08
Homepage: http://k332.feld.cvut.cz/~lemming/
Lizenz: Freeware


PS3Mrec:

Wer hatte noch nie den Wunsch, die Protracker-Module aus der "guten alten
Zeit" endlich anstatt nur über Paula auch mal auf dem CD- oder MP3-Player
abzuspielen? Die erste Frage, die man sich nun stellt, ist, wie man denn
ein Tracker-Modul in ein für das Brennerprogramm oder den MP3-Encoder
akzeptables Format bringen kann. Meistens müssen die Ausgangsdaten
wenigstens als WAV- oder AIFF-Datei vorliegen, dazu auch noch mit einer
Frequenz von 44.1 KHz und unter 16 Bit Sampleauflösung läuft im
Allgemeinen sowieso nichts. Wenn man dann auch noch das Pech hat, daß die
Audiospuren des Moduls so unglücklich arrangiert wurden, daß vielleicht die
Basedrums und Hihats die ganze Zeit auf der linken Kopfhörerseite zu hören
sind, die Synthies und Pianos dafür auf der rechten Seite, kann man von
einem "Musikgenuß" sowieso nicht reden.

Die Lösung für diese Probleme ist das kleine Shell-Programm PS3Mrec.
Ursprünglich als Konverter für ScreamTracker-Module (S3M) konzipiert, kann
dieses Programm auch Protracker, Digibooster, Fasttracker (I und II) und
Multitracker-Module in 8SVX-, AIFF- und WAVE-Samples konvertieren, die dann
z.B. mit einem Sample-Editor weiterverarbeitet oder direkt an einen MP3-
Encoder oder ein Brennerprogramm übergeben werden können.

Die Voraussetzungen für den Betrieb an den verwendeten Amiga sind einfach
gesagt jede Menge freier Speicherplatz auf der Festplatte. Eine Minute
eines Samples in CD-Qualität (d.h. 16 Bit, 44100 Hz, Stereo) benötigen ca.
10 MB Festplattenspeicher. Das Programm soll laut Anleitung sogar ab
Kickstart 1.1 funktionieren, was ich aber nicht ausprobiert habe. XPK-
komprimierte Module kann PS3Mrec selbständig wieder entpacken, sofern das
XPK-System auf dem Rechner installiert wurde. Die Anforderungen sind
moderat - es werden etwa 2 bis 3 MB freies RAM benötigt.

Die Installation beschränkt sich auf das Entpacken des Archivs. Das
Programm PS3Mrec muß danach nur noch an einen beliebigen Platz auf der
Festplatte kopiert werden. Die recht knappe, englische Anleitung beschreibt
die Benutzung und alle Parameter recht ausführlich.

Interessant sind die verschiedenen Render-Modi von PS3Mrec. So kann z.B.
der Surround-Effekt eines Moduls wesentlich beeinflußt werden. Sollten
etwa, wie oben erwähnt, die Audiospuren eines Moduls sehr ungünstig
arrangiert worden sein, kann man mittels eines Surround-Rendering-Modus und
dem PAN-Parameter dafür sorgen, daß die unterschiedlichen Spuren bis zu
einem gewissen Grad ineinander gemixt werden, so daß später auf dem
Kopfhörer oder der Stereoanlage davon nichts mehr zu hören ist. Außerdem
kann der Lautstärke-Pegel eines Moduls zusätzlich erhöht werden, damit
leise Passagen oder Bässe besser herausgestellt werden. Die Ausgabefrequenz
kann beliebig geändert werden. So sind Frequenzen von 5 bis 60 KHz für das
resultierende Sample möglich. Während der Konvertierung wird in der Shell
das aktuelle Modulpattern, die verbleibende Abspielzeit des Moduls und der
belegte Speicherplatz ausgegeben. Abgebrochen werden kann die Konvertierung
jederzeit mit Ctrl+C.

@{"Screenshot" LINK "ps3mrec.png/MAIN"} (ab OS 3.0; PNG-Datatype muss installiert sein)

Autor: K-P Koljonen
Aminet: music/misc/ps3mrec.lha
Programmversion: 2.1
Homepage:
Lizenz: Freeware


Das war's für diesen Monat. Wer Fehler findet, Vorschläge hat oder Kritik
loswerden möchte, schickt mir eine Mail.

Christian Aichinger <christian@aakt.de>

@ENDNODE

@NODE "Tests2" "Testberichte"
@TOC "MAIN"

2. Kurztest: TV-Kartensoftware für Amithlon »AmiTV« (von Thomas Nosutta)

Ein kleiner Schritt für Michael, aber ein großer für die Amithlon-User:
Michael Ulbrich (amithlon@shopnfun.de) hat ein Programm für TV-Karten
geschrieben.

"AmiTV" ist ein simples Programm, mit dem man TV auf dem Amiga schauen
kann. Es ist noch beta, aber kostenlos unter
http://www.shopnfun.de/amithlon/tvcard/index.html erhältlich und besitzt
eine nur einfache, aber praktische GUI mit Schalter für Sender, Suchlauf,
Zweikanalton und Eingang.
Wenn es die TV-Karte zulässt, kann man TV, Video, Spielekonsole und DVD-
Player über "AmiTV" nutzen. Unterstützt werden momentan folgende Modelle:
WinTV PCI FM, WinTV go, MiroPCI TV und die Medion9550 (Aldi).

Das Programm besitzt keinen Installer - einfach das Programm in ein
Verzeichnis entpacken und die Fonts nach Fonts: kopieren, das war's. Das
Programm erkennt die TV-Karte selbständig. Dann die Sender suchen und die
Senderliste editieren (Beispiellisten sind der Software beigelegt). Das
Programm kann alternativ auch eingeschränkt über die Tastatur gesteuert
werden. Leider unterstützt es (noch) keine Fernbedienung. Das TV-Bild kann
auf Zweidrittel des Screens vergrößert werden, aber eine Vollbildfunktion
wäre praktischer.

@{"Screenshot" LINK "amitv.jpg/MAIN"} (ab OS 3.0; JFIF/JPEG-Datatype muss installiert sein)

Dem Archiv beigelegt ist das Programm "Amithlon-Radio v0.8" mit dem man,
vorausgesetzt, die Karte unterstützt es, Radio hören kann. Auch diese
Software besitzt nur eine einfache praktische GUI mit Schalter für
Suchlauf, Stationen, Lautstärke und ist im Betastadium. Deswegen erscheint
die Displayanzeige momentan nur auf 8-Bit-Screens.

Wünschenswert für die Zukunft wäre, dass "AmiTV" Unterstützung für
Fernbedienungen und beide Programme eine Aufnahmefunktion erhalten.

Übrigens: Der Autor der Software, Michael Ulbrich, führt seit etlichen
Jahren einen Amiga Shop in Berlin (http://www.shopnfun.de) und ist
bekennender Amithlon-User :-).

Thomas "Gojira" Nosutta  <nosutta@web.de>

@ENDNODE

@NODE "Spiele1" "Spieleteil"
@TOC "MAIN"

AMIGA-aktuell-Spieleteil (von Oliver Tacke und Jürgen Theiner)
--------------------------------------------------------------

1. Vorwort

---------------------------------------------------------------------------
Tanz mit dem Teufel
---------------------------------------------------------------------------

Was für ein Monat: lauter Ankündigungen rund um den Amiga! Die
erstaunlichste möchte ich hier auch kurz aufgreifen. Aber wirklich nur
kurz, denn darüber zerbrechen sich schon genug Leute den Kopf. Die Rede ist
natürlich von AMIGAs Teilnahme an der Embedded Systems Show am Stand von
Microsoft.

Pfui, was machen die denn da? Die Verräter! Microsoft wird die ausnehmen,
...moment... Schalten wir mal einen Gang zurück. Erstens wissen wir
(bisher) gar nicht, OB es da überhaupt mehr Verbindungen gibt als das bloße
Unterausstellerdasein, obwohl das zu vermuten ist. Zweitens gestehe ich den
Jungs von AMIGA, Inc. so viel Grips zu, dass sie wohl wissen, mit wem sie
es zu tun haben.

Ich mag Microsoft und besonders deren Geschäftsmethoden auch nicht und
gehöre wohl zu den wenigen merkwürdigen Leuten, die keinen PC (übrigens
auch keinen Mac, und der C64 zählt wohl nicht wirklich) neben dem Amiga
stehen haben, aber wenn AMIGA, Inc. durch die Gates-Company Publicity
bekommt und dadurch auch noch Geld in die vermutlich nicht allzu prall
gefüllten Kassen spülen kann, habe ich kein Problem damit. Nur ausnutzen
lassen dürfen sie sich halt nicht, und eine bestätigte(!)
Kooperation...hmpf, wirtschaftlich sicherlich vorteilhaft, wenn man sich
nicht über den Tisch ziehen lässt, aber ideell natürlich unterhalb der
Gürtellinie.

Was das im Spieleteil zu suchen hat? Ist doch ganz klar: AMIGA, Inc. kann
auf der Messe, besonders als Unteraussteller von Microsoft, sicherlich
Firmen für das AmigaDE interessieren, die vorher noch nie davon gehört
haben. Das erhöht die Wahrscheinlichkeit, dass mehr Software dafür
produziert wird. Na, und Spiele sind auch Software!

Jaaa, da gibt's natürlich noch zig Sachen zu erörtern: AmigaDE sei nur für
PDAs, PDA-Firmen machen keine Desktop-Sachen, AmigaDE gibt's (noch) nicht
fürs AmigaOS, und was weiß ich noch alles, aber ich habe oben gesagt:
kurz... Und außerdem schreibe ich sonst in drei Wochen noch! Das überlasse
ich lieber den fleißigen Kommentareschreibern in den Foren.

Aber bevor jetzt alle ihre Tastatur ölen: Schaut doch mal in den aktuellen
Spieleteil, denn dort gibt's auch ein paar interessante Sachen zu
entdecken.

Oliver Tacke <oliver@aakt.de>

@ENDNODE

@NODE "Spiele2" "Spieleteil"
@TOC "MAIN"

2. Aufruf

Liebe Leser,

Der AMIGA-aktuell-Spieleteil lebt von Eurer Mithilfe, deshalb bitte ich
Euch, mir mitzuteilen, wenn Ihr News zu Spielen habt. Ich bin immer offen
für News, Tips oder was auch immer, Hauptsache es hat mit Amiga und Spielen
zu tun. Kritik ist auch immer willkommen, sagt mir ruhig, wenn Euch
irgendetwas nicht gefällt. Denn auch ich bin nicht perfekt. Also - immer
her mit Anregungen!


Liebe Programmierer und Softwarefirmen,

jetzt, da es in Deutschland nur noch wenige geeignete Publikation gibt, die
über Amiga-Spiele berichten, ist es um so wichtiger, jede verbliebene
Möglichkeit zu nutzen, um die treuen Amiga-Fans mit News, Previews und
Tests zu versorgen. Ich denke, AMIGA aktuell ist eine sehr gute dieser
Möglichkeiten. Mit seinen extrem vielen Verbreitungswegen hat es sicherlich
einige Tausend potentielle Leser. Es liegt an Ihnen, ob Sie mich bei meiner
Arbeit unterstützen und Ihre Spiele bekannt werden. Bitte schicken Sie mir
News zu Ihren Spielen, aber auch Demoversionen. Auch über das eine oder
andere Testmuster Ihrer Spiele würde ich mich freuen. Dies würde natürlich
mit einem ausführlichen Test des Spiels gewürdigt.

@ENDNODE

@NODE "Spiele3" "Spieleteil"
@TOC "MAIN"

3. News

"Tales of Tamar"

Ich selbst kann es kaum noch abwarten, bis das Strategiespiel Tales of
Tamar endlich zu haben ist. Für Betatester gibt es mittlerweile wieder eine
neue Betaversion, die die Versionsnummer 0.41R2 trägt. Zum Glück lässt sich
daraus nicht auf den Grad der Fertigstellung schließen, sonst würde das ja
noch ein paar Jahre dauern.

In der Tat ist es laut Aussagen des Programmierers so, dass nur noch einige
Städte, Armeen und Siedler implementiert werden müssen, und dann wäre das
Basisset auch schon komplett. Ein Erscheinen innerhalb der nächsten sechs
Monate ist nicht auszuschließen. Hoffen wir das beste!

[1] http://www.tamar.net



"ScummVM"

ScummVM ist zwar selbst kein Spiel, dafür aber ein Interpreter für die von
Lucasfilm Games (heute LucasArts) geschaffene Skriptsprache, auf der die
legendären Adventure-Klassier "Maniac Mansion", "Zak McKracken", usw.
beruhen. Ihr kennt sie ja alle.

Mittels ScummVM ist es nun möglich, auch die Titel zu spielen, die gar
nicht mehr auf dem Amiga veröffentlicht wurden - das PC-Original
vorausgesetzt natürlich. Das funktioniert mit den aktuellsten Versionen des
Programms bereits ziemlich gut, zwar noch nicht für alle Spiele, aber "Day
Of The Tentacle" z.B. läuft bis auf kleine Grafikfehler einwandfrei.

In diesem Monat sind aktualisierte Versionen für MorphOS und WarpUP
erschienen, eine AGA-Version gibt es jedoch auch. Alles zu finden auf der
zugehörigen Website [1].

[1] http://www.sebelinteractive.de/scummvm/



"BrainTeaser"

Kaliko (LastInLine) kündigt drei neue Spiele für das AmigaDE an, die im
Zeitraum zwischen März und Juni erscheinen sollen.

Da wäre "BrainTeaser", das zusammen mit den Machern des Amiga-Adventures
"Sixth Sense Investigations" entsteht. Es handelt sich dabei um ein
Puzzlespiel, bei dem es darum geht, mehrere Blöcke mit gleichem Aussehen
zusammenzubringen, damit diese verschwinden. Hört sich so ähnlich an wie
Tetris, soll aber ganz anders sein. Bilder gibt es leider noch nicht dazu.

Von den anderen beiden Spielen sind nur die Titel bekannt: "Kaliko
Minigolf" und "Pirate's Puzzle". Was könnte das bloß sein...

[1] http://www.kaliko.com



"Frontier: Elite II"

Passend zum Elite-TNK-Artikel in dieser Ausgabe wurde auch für den Amiga
die Shareware-Version des Weltraumhandelsspiels veröffentlicht [1]. Sie
kostet gerade einmal fünf britische Pfund.

[1] http://www.eliteclub.co.uk



"Valentinsgrüße von clickBOOM"

Im sogenannten S-File [1] hat die gute Sofia von clickBOOM nach langer
Sendepause ein neues Amiga Spiel angekündigt, an dem gearbeitet werde. Was
genau das sein soll, darüber schweigt sie sich allerdings aus.

[1] http://clickboom.com/s-files/16.shtml



"The Feeble Files ist da"

Das Adventure "The Feeble Files" rund um den schrulligen grünen
Außerirdischen ist fertiggestellt worden, und die Vorbesteller sollten ihr
Päckchen bereits erhalten haben.

[1] http://www.epic-interactive.com



"Payback"

Das Gangsterspiel, das als Eigenentwicklung für den Amiga eine nette
Abwechslung zu den PC-Konvertierungen bietet, ist bei den AGC Awards 2001
die Nummer 1 vor Earth 2140 und Shogo geworden [1] und liegt auch bei Amiga
Flame's "Best Game of 2001" [2] ganz vorne.

Außerdem hat Programmierer James Daniels einen Statusbericht zur Portierung
auf das AmigaDE abgegeben und auch erste, beeindruckende Screenshots
veröffentlicht [3]. Er hofft, das Spiel in zwei Monaten fertig zu haben.

Für das klassische AmigaOS gibt es auch noch etwas, nämlich zwei brandneue
und drei verbesserte Maps [4].

[1] http://agcweb.online.fr/
[2] http://www.amigaflame.demon.co.uk/amitop01.htm
[3] http://www.apex-designs.net/payback_intent_report.html
[4] http://www.apex-designs.net/payback_maps.html



"Update für Freespace: The Great War"

Für alle Weltraumpiloten, die Hyperions "Freespace" spielen, gibt es ein
Update [1], das diverse neue Explosions-Soundeffekte enthält, die
Steuerung verbessert und Voodoo3-Besitzern ein wenig Arbeit beim
Konfigurieren abnimmt.

[1] http://www.hyperion-entertainment.com



"Website zu AlienNations online"

Freunde von Aufbaustrategiespielen dürfen sich freuen: Zu AlienNations, das
für MorphOS und PPC-angetriebene Amigas programmiert wird, ist die
offizielle Website [1] online gegangen. Viel ist dort allerdings noch nicht
zu finden.

[1] http://www.titan-computer.com/ami/aliennations/

Oliver Tacke <oliver@aakt.de> - schickt mir eure News!

@ENDNODE

@NODE "Spiele4" "Spieleteil"
@TOC "MAIN"

4. Hinter den Kulissen: Die Probleme beim Konvertieren von Spielen

Mittlerweile macht es ja fast keinen Spaß mehr, Spiele von Hyperion zu
testen, ich möchte doch auch mal wieder was Negatives schreiben. ;-)

Nein, Spaß beiseite. Nach dem dritten Topspiel in Folge dachte ich mir, daß
es mal Zeit wird, einen Blick hinter die Kulissen zu werfen und habe
deshalb Steffen Häuser von Hyperion gefragt, ob er uns nicht ein paar
Zeilen über die Schwierigkeit beim Konvertieren von PC-Spielen schreiben
kann. Lest hier, weshalb es schon mal etwas dauern kann, bis das neue Spiel
der Belgier erscheint und auch angekündigte Releasetermine manchmal nach
hinten verschoben werden:


"Beim Umsetzen von Spielen auf den Amiga gibt es folgende Faktoren zu
berücksichtigen:

1. Assembler-Code

Eine Menge Spiele enthalten massiv x86-Assembler-Code, oft schlecht
dokumentiert (oder unter Verwendung des Intel-Floatingpoint-Stacks, was
einerseits schwer verständlicher Code und zum anderen schwer umzusetzen
ist). Spiele mit 200 KB Assembler-Sourcen sind keine Seltenheit. Da muss
man mindestens 4 Wochen einplanen, allein für das. Oft arbeitet man allein
an einer einzigen Assembler-Funktion eine ganze Woche. Und bis man dann
alle Grafikfehler aus von ASM nach C portierten Texturemappern draußen hat
- das dauert meist. Glücklicherweise wird die Verwendung von ASM immer
weniger. Oder es wird zumindest nur optional verwendet.

2. Endian-Probleme

Wenn man Daten byte- oder wordweise aus Dateien (oder einer TCP/IP-
Übertragung) liest, so verhalten sich x86 und PPC entgegengesetzt (0x1234
auf PPC ist 0x4321 auf x86). Man muss daher alle entsprechenden Routinen
korrigieren. Das kann so "versteckt" sein, dass mit einer int-Leseroutine
ein int in ein "Short" gelesen wird. Auf x86 kriegt man zufällig die
"interessante Hälfte", auf PPC leider die "uninteressante" - sprich 'ne 0.
So was ist oft sehr schwer zu finden. Und der Bug tritt leider meist erst
bei VERWENDUNG der Daten auf, also viel später und an anderer Stelle im
Code. Bei Freespace musste ich vor allem eine Menge Arbeit in den Netzwerk-
Code bzgl. Endian-Konvertierung stecken. Aber auch der Modellcode war
nicht völlig "Endian-Clean". Die Endian-Probleme verursachen bei
den meisten Spielen den größten Aufwand.

3. Speicherbedarf

Die meisten PC-Spiele gehen von der Verfügbarkeit virtuellen Speichers aus,
selbst wenn auf der Packung "min. 32 MB RAM" steht. Auf dem Amiga muss man
dann alle möglichen Speicherbedarfreduzierungsmaßnahmen vornehmen (kann bis
zu 4 Wochen Zeit brauchen).

4. Windows-APIs

Oft werden Windows-APIs verwendet, die oft schwer lesbarer Code sind. Aber
in der Zwischenzeit kennen wir uns auch damit sehr gut aus, so dass das
kein so großes Problem mehr ist. Eine Direct3D->OpenGL Portierung kann
dennoch heftige Überraschungen und viel Arbeit mit sich bringen. Das kann
im "worst case" in die MONATE gehen, nicht nur Wochen... OpenGL/MiniGL und
Direct3D sind halt in manchen Punkten ziemlich anders. Immerhin hat MiniGL
auf dem Amiga wenigstens - wie Direct3D - Direktzugriff auf den
Videospeicher. OpenGL auf Linux oder Mac hat nicht mal das, da kann es dann
noch kniffliger werden, unter Umständen.

5. Detailarbeit

Im Unterschied zu einem Freewareport, wo man ein paar Sachen "for future
update" offen lässt, nimmt ein kommerzieller Port doch ganz andere
Dimensionen an, was Bugfreiheit, Installationsskripte, GUI usw. angeht.
Das ist eine Menge Arbeit. Und dann findet doch noch jemand einen kleinen
Bug, und der muss gefixed werden. Und beim Erstellen der Master-CD muss
alles stimmen. So ein Glasmaster kostet immerhin seine 300 Euro, da ist
kein Spielraum für Fehler ("Oops, nun hab ich ein File vergessen" - das
darf einfach nicht passieren, aber deshalb wird die Master-CD vor dem
Verschicken an den Publisher von uns auch lieber noch zweimal, dreimal
geprüft, dass auch wirklich alles stimmt)."


Habt ihr auch einmal mitgerechnet? Da kommen ja selbst ohne große
Schwierigkeiten locker ein halbes Jahr zusammen. Wenn man dann noch die
Lizenzverhandlungen und die Betatests mit den anschließenden Korrekturen
dazurechnet, ist zumindest mir klar, weshalb zwischen den Spielen soviel
Zeit liegt. Und ich hoffe, euch geht auf, daß man das nur auf Dauer so
weitermachen kann, wenn es sich auch finanziell lohnt, sprich, die
Absatzzahlen stimmen! Also noch einmal: Softwarepiraterie tötet den
Amiga!!!

Aber nun Schluß mit der Schwarzmalerei: Was ist von Hyperion denn in
Zukunft noch so zu erwarten?


"Was von uns noch alles zu erwarten ist? Nun, zunächst mal Quake 2. Wir
haben aber auch noch einen anderen Titel im Auge, dessen Chancen aber von
den Verkaufszahlen von Freespace abhängen. Sollte das klappen, wird es
natürlich auch noch weitere Spiele geben.  Aber Quake 2 und dieser andere
Titel - puh, Steffen, machst du es spannend - wären - vorausgesetzt es haut
mit den Verkaufszahlen hin - in nicht allzu ferner Zukunft (sprich auf
jeden Fall noch in der ersten Jahreshälfte - Quake 2 natürlich schon weit
früher) machbar.
Und natürlich gibt es OS 4 (dazu später mehr)."


So, nun sind wir doch alle etwas schlauer und sehen hoffentlich ein, daß es
auch einmal eine Verzögerung beim Release geben kann, wenn man die von
Hyperion gewohnte Qualität haben möchte. Natürlich fällt das schwer, aber
"Geduld ist eine Tugend".

Jürgen Theiner <Juergen.Theiner@t-online.de>

@ENDNODE

@NODE "Spiele5" "Spieleteil"
@TOC "MAIN"

5. Vorabbericht: 3D-Shooter »Quake 2«

Seit kurzem ist der Quellcode des beliebten First-Person-Shooters Quake 2
(hey, Jugendschutz und Kanzlei Gravenreuth: Ich hab's ausgeschrieben!)
erhältlich und die Amiga-Zocker lechzen danach, seitdem ein paar der Jungs
von Hyperion in ihrer Freizeit daran arbeiten. Grund genug also, ein paar
Zeilen darüber zu verlieren. Steffen Häuser war so freundlich, mir
Informationen und auch neue Screenshots zu liefern, die kaum ein Mensch je
zuvor gesehen hat.

"Obwohl Quake 2 'nur' ein OpenSource-Port ist, legen wir dieselben
Maßstäbe an wie an unsere anderen Spiele. Insbesondere bedeutet dies, dass
wir ein 'richtiges' Betatesting durchführen. Es bedeutet außerdem, dass
Dinge wie eine grafische Oberfläche zum Starten und ein Installations-
Skript selbstverständlich sind.

Die Idee hinter dem Installationsskript ist dabei, dass der User
aufgefordert wird, eine Quake 2 CD für Windows oder Macintosh einzulegen,
und das Skript übernimmt dann die komplette Installation, so dass der User
nichts 'von Hand' machen muss (wie bei anderen OpenSource-Ports in der
Vergangenheit, wo man die Datenfiles von der PC CD von Hand umkopieren
musste). Insbesondere werden hierbei auch die PAK-Files ausgepackt, damit
das Spielen auch auf FFS schnell geht."

@{"Screenshot" LINK "quake2-1.jpg/MAIN"} (ab OS 3.0; JFIF/JPEG-Datatype muss installiert sein)

Um es noch einmal klarzustellen: es wird zwingend eine Original-PC-Version
des Spiels benötigt. Da sie aber im Handel kaum noch zu finden sein dürfte,
wird an einer Lösung gearbeitet, so dass alle interessierten Gamer das
Prachtstück noch erwerben können. Genauere Aussagen waren leider noch nicht
aus Steffen herauszuholen, dafür aber noch ein bisschen was zur Technik:

"Quake 2 besitzt einen Software-Renderer (in 8 Bit, weshalb er wesentlich
schneller als etwa der Software-Renderer von Heretic II, welcher in 16 Bit
war, ist) und einen Warp3D/MiniGL-Renderer (in 16 Bit). Sound-Support
erfolgt wahlweise über AHI oder über Paula. An Inputgeräten werden
unterstützt: Tastatur, Maus (inkl. Mausrad), CD32-Pad, PSX-Port, PC-Analog-
Joystick (per Spezialadapter, wie bei Freespace)."

Zocker mit PPC unter der Haube sollten diesen wenigstens mit 150 MHz
getaktet haben und den Rechner mindestens mit 64 MB RAM ausrüsten. Einige
MODs (andere Spielversionen, die nur auf dem Spiel basieren, teilweise aber
extrem anders sind - so etwas wie Counterstrike für Halflife) benötigen
allerdings noch ein wenig extra Speicher. Für die 603e-PPCs ist außerdem
eine 3D-Grafikkarte wärmstens zu empfehlen, die 604er kommen, je nach
Anspruch, auch ohne aus.

Großvater 68k-Amiga guckt leider in die Röhre, denn das Spiel ist selbst
auf einem 50 MHz 060 zu langsam, um spielbar zu sein. Anders hingegen sieht
es für AmigaXL-Benutzer aus, wenn ihr PC mit etwa 1 GHz getaktet ist. Dort
läuft die 68k-Version dann flott. Ein Bug im Emulator verhindert allerdings
bisher das Spielen der MODs, aber der könnte bald beseitigt sein. Auf
Amithlon hingegen ist selbiges Problem dafür verantwortlich, dass das Spiel
bisher gar nicht läuft. Der Autor von Amithlon hat aber die nötigen
Informationen erhalten, um den Fehler auszumerzen.

Für echte Amigas gilt, dass Quake 2 langsamer ist als die WarpOS-Version
seines Vorgängers, jedoch schneller als Heretic II. Das "Feeling" ist mit
Quake 1 zu vergleichen, aber besonders, wenn eine Menge Lichteffekte ins
Spiel kommen, erinnert die Geschwindigkeit eher an Heretic II. Leuten ohne
3D-Hardware sei aber gesagt, dass der Software-Renderer deutlich schneller
ist als in Heretic II, so dass Quake 2 dann wesentlich angenehmer spielbar
ist.

@{"Screenshot" LINK "quake2-2.jpg/MAIN"} (ab OS 3.0; JFIF/JPEG-Datatype muss installiert sein)

Damit keine Langeweile aufkommt, gibt's haufenweise MODs. Schau'n wir doch
mal, was Steffen dazu zu sagen hat.

"Die 'MOD-Szene' für Quake 2 war schon immer eine der größten. Ein 'MOD'
ist eine Spielvariante, die das Spiel teilweise radikal ändert. Wir haben
über 50(!) verschiedene MODs auf den Amiga umgesetzt. Die 'Highlights':

The Weapons Factory
Devastation Quake 2
ActionQuake
Battle of the Sexes
Annihilation Quake 2
Headhunters
ThreeWave CTF
HolyWars
Catch the Chicken

Im Grunde sind die meisten der 'wichtigen' MODs portiert (und mit einigen
MOD-Teams sind wir noch in Verhandlung betreffs des MOD-Sourcecodes). Nur
einige wenige MOD-Teams haben eine Zusammenarbeit mit 'jemandem, den sie
nicht kennen' rundheraus abgelehnt."

So. Das soll's dann auch gewesen sein. Bleibt zu hoffen, dass das Spiel
bald fertig ist, denn bisher haben die Jungs von Hyperion noch nie
enttäuscht. Es wäre übrigens prima, wenn ihr ihnen eine kleine Anerkennung
in Form von E-Mails zukommen lassen könntet. Immerhin basteln sie uns in
ihrer Freizeit ein wirkliches Hammerspiel!

Oliver Tacke <oliver@aakt.de>
...vielen Dank an Steffen Häuser für die Informationen und die Screenshot!

@ENDNODE

@NODE "Spiele6" "Spieleteil"
@TOC "MAIN"

6. Vorabbericht: Weltraumsimulation »Elite TNK«

---------------------------------------------------------------------------
Back to the *real* roots...
---------------------------------------------------------------------------

Die aktuelle PC-Fassung von Elite TNK wurde von C.J. Pinder aus den
Assembler-Sourcen für die Acorn-BBC-Micro-Urversion per Re-Engineering in C
entwickelt. Er verwendete dazu die Allegro-Bibliothek, die für die
verschiedensten Betriebssysteme in mehr oder weniger weit entwickelten
Fassungen vorliegt. Daraus ergab sich die Hoffnung, eine Umsetzung der
Allegro-Bibliothek auch für Amiga zu erhalten, was sich im weiteren Verlauf
als nicht besonders sinnvolles Unterfangen herausstellte. Dazu später mehr.

Die momentan in der Entwicklung befindliche Fassung von Elite TNK für Amiga
wird von Michael Asse und Wolfgang Hosemann verwirklicht. Michael Asse
dürfte einigen durch seinen Aufruf bezüglich FFE (Final Frontier Elite)
und der dazugehörigen Website bekannt sein, wie vor einiger Zeit auf
amiga-news.de zu lesen war. Wolfgang Hosemann hat bisher hauptsächlich
Supportaufgaben wahrgenommen. Für beide ist es das erste größere Projekt
in Sachen Portierung, daher auch der relativ große Zeitrahmen, den sich
beide für die Ausführung gesteckt haben.

@{"Screenshot" LINK "elitetnk1.png/MAIN"} (ab OS 3.0; PNG-Datatype muss installiert sein)

Ein Problem ist zur Zeit der Status der Quelltexte der PC-Version. Obwohl
frei zugänglich, sind die Quelltexte nicht Open Source, sondern unterliegen
dem Copyright von C.J. Pinder und der Veröffentlichungserlaubnis einer der
beiden Autoren der Originalversion. Daher ist auch noch nicht sicher, in
welcher Form die Quelltexte der Amiga-Version öffentlich zugänglich gemacht
werden können, und ob der Autor der PC-Fassung seine Zustimmung dazu gibt.
Die entsprechende Erlaubnis für das ausführbare Programm liegt bereits vor,
also sollten die Quelltexte dann später auch kein Hindernis finden.

Als nächstes "Hindernis" stellte sich Allegro heraus: Laut Aussage eines
der Entwickler ist die Allegro-Bibliothek zwar portierbar, aber von den
Konzepten her schwer mit dem AmigaOS zu vereinbaren (Stichwort: Input
Polling). Man hat sich daher dazu entschlossen, eine reine AmigaOS-Version
zu erstellen, was, laut den Entwicklern, auch erstaunlich leicht fallen
soll, da der Aufbau von Elite TNK nicht besonders eng an Allegro gebunden
sei.

Dadurch sollen auch Features eingebaut werden können, die die PC-Version
nicht bietet. Das wären z.B. Systemfreundlichkeit (verhältnismäßig geringe
CPU-Last durch Verwendung von Wait() statt Polling, exakteres,
CPU-unabhängiges Timing), die Erkennung von mehreren Tastendrucken
gleichzeitig etc.

@{"Screenshot" LINK "elitetnk2.png/MAIN"} (ab OS 3.0; PNG-Datatype muss installiert sein)

Kommen wir nun zu den "inneren Werten" des Spiels:

Man kann sich vorstellen, dass ein Spiel aus dem Jahre 1984 von der Grafik
her alles andere als auf der Höhe der Zeit ist. Der Autor der PC-Fassung
dieses Remakes hat sich lange Gedanken darüber gemacht, ob er das Programm
mit 3D-Grafik vom Feinsten ausstatten soll oder nicht. Er hat es *nicht*
getan, und das war auch gut so ;).

Die Grafik des Spiels wird entweder in Form von ausgefüllter Vektorgrafik
(Solid Model) dargestellt, oder als Linien-Vektorgrafik (Hidden Line). Das
Ganze kann bis zu 256 Farben haben und wird auf der PC-Version in der
Auflösung des Acorn-BBC-Originals dargestellt (512 x 512 Pixel). Die
Amiga-Version wird hier etwas mehr Auswahl zur Verfügung stellen und
zusätzlich einen Modus in halbierter Auflösung anbieten, um auch den etwas
schwachbrüstigen Rechnern zu diesem Spielvergnügen zu verhelfen. Zusätzlich
zur Auflösung kann man natürlich auch die Art der Darstellung (Hidden
Line/Solid Model) frei wählen, wobei für eine Maschine, die gerade die
Mindestvoraussetzungen erfüllt, Hidden Line in halbierter Auflösung wohl
das Maß der Dinge sein wird.

@{"Screenshot" LINK "elitetnk3.png/MAIN"} (ab OS 3.0; PNG-Datatype muss installiert sein)

Angepeilt ist als Mindestvoraussetzung ein Amiga mit OCS-Chipsatz und 68030
CPU sowie Kickstart 3.1. Grafikkarte und eine schnellere CPU wären natürlich
von Vorteil, wobei hier zusätzlich die rtgmaster.library installiert sein
sollte. Eine PPC-Version für das kommende Amiga OS 4.0 ist ebenfalls
geplant.

Soundunterstützung wird es sowohl für Paula als auch für AHI geben, man hat
hier die freie Wahl. Zum Sound ist zu sagen, dass auch dieser nicht das
Nonplusultra der Technik ist. Größtenteils wurde der Original-Sound
gesampled und in der PC-Version sind diverse bekannte Melodien als MIDI-
Sound verfügbar. Die Amiga-Version wird hier den MOD-Weg gehen, da die
vorhandenen Software-MIDI-Systeme doch arg strapaziös für die CPU sind,
wenn sie ordentliche Klangqualität bieten sollen.

@{"Screenshot" LINK "elitetnk4.png/MAIN"} (ab OS 3.0; PNG-Datatype muss installiert sein)

Die Steuerung erfolgt mittels Tastatur oder wahlweise Joystick.
Besonderheiten sind hier wohl eher nicht zu erwarten.

Ein abschließendes Wort noch zur "altbackenen" Grafik: Es tut dem
Spielvergnügen wahrlich keinen Abbruch, dass hier keine Textur-Orgie
veranstaltet wird. Die "alte" Grafik lässt im Gegenteil noch einen
zusätzlichen Reiz aufkommen: Nostalgische Gefühle. Für einen
Retro-Klassiker nach meiner Meinung das wirklich Wichtige. Es sollte sich
spielen wie früher und es sollte aussehen wie früher.

@{"Screenshot" LINK "elitetnk5.png/MAIN"} (ab OS 3.0; PNG-Datatype muss installiert sein)

Wenn alles glatt geht, dann läuft der Betatest bereits Mitte März an. Es
kann also gar nicht mehr soooo lange dauern, bis man wieder durchs
All gondelt.

Oliver Tacke <oliver@aakt.de>
...vielen Dank an Wolfgang Hosemann für die ausführlichen Informationen

@ENDNODE

@NODE "Spiele7" "Spieleteil"
@TOC "MAIN"

7. Oldies but Goldies

---------------------------------------------------------------------------
Elite
---------------------------------------------------------------------------

Wer von den Lesern hatte einen C64 oder Acorn BBC Micro oder TI99
oder...und erinnert sich noch: 1984 (respektive 1985) kam ein Spiel auf den
Markt, das eine Revolution im Bereich der Vektorgrafik darstellte: Elite.

Geschrieben von David Braben und Ian Bell, stellte dieses Programm nicht
nur eine Sensation im Homecomputer-Grafikbereich dar, es war auch eine
programmiertechnische Meisterleistung. In einem unglaublich kleinen
Hauptprogramm war ein Spiel versteckt, dessen Spielspaß und -Tiefe
Millionen Homecomputer-User nächtelang an den Bildschirm fesselte.

Dabei ist die Geschichte des Spiels recht schnell erzählt:

Der Spieler übernimmt die Rolle eines kleinen Handelskapitäns, der,
ausgestattet mit einem ziemlich kleinen Frachtschiff, sein Glück in einem
wirklich entlegenen Winkel der Galaxis sucht. Die umliegenden Sonnensysteme
sind allesamt nicht besonders aufregend, wenn man von einer Tatsache
absieht: Jeder der Sterne in diesem Teil der Galaxis hat aus ungeklärtem
Grund jeweils nur einen Planeten!

Das ficht unseren tapferen Handelskapitän aber nicht an, diese
Merkwürdigkeit macht ihm das Leben sogar ein wenig einfacher, da er sich
nur von einem Planeten je Sonnensystem die Besonderheiten merken muss.

Sinn des Ganzen ist nämlich, wie könnte es anders sein, eine möglichst
steile Karriere als Raumschiffkapitän zu machen. Die intergalaktische
Raumfahrtorganisation führt über jeden Raumfahrer Buch und stuft ihn, je
nach vollbrachten Leistungen und Missetaten, in verschiedene Ränge ein,
deren höchster "Elite" ist. Doch bis dahin ist es ein weiter und
gefährlicher Weg, denn man ist nicht allein unterwegs im Universum. Da sind
die harten, aber fairen Konkurrenten, es gibt Piraten (und natürlich auch
Polizei!) und man hat in Gerüchten gehört, dass die gefürchteten Thargoiden
nach langer Zeit wieder ihr Unwesen in dieser Galaxis treiben sollen.

Tja, da steht man nun, mit seinem kleinen, aber feinen Raumschiff, und
dürstet nach Taten. Schnell erkennt man, dass das eigene Schiff eher
spärlich ausgestattet ist und das es noch viel Zubehör dafür zu kaufen
gibt. Dumm nur, dass man so wenig Geld hat. Es muss noch einiges an Credits
dazukommen, damit man sich allen Komfort für das Schiff leisten kann.

Diese zusätzlichen Credits lassen sich aber auf verhältnismäßig einfachem
Weg beschaffen: Man wird zum fliegenden Händler (im wahrsten Sinne des
Wortes!). Auf jedem Stützpunkt, der um einen Planeten kreist, kann man die
verschiedensten Dinge kaufen und auch verkaufen. Was liegt also näher, als
irgendwo in der Umgebung billig einzukaufen und woanders teuer zu
verkaufen? Mit ein wenig Glück findet man eine äußerst lukrative
Handelsroute, und schon bald hat man genug Credits, um sich gleich ein ganz
neues Schiff zu kaufen!

Doch damit nicht genug: Hin und wieder trifft man einen Reisenden, der
einem einen "dringenden" Auftrag zur Erfüllung anträgt, natürlich nur gegen
ein entsprechendes Salär, versteht sich ;). So ein Auftrag eignet sich
vorzüglich dafür, neben Geld auch noch Rangpunkte zu scheffeln, denn meist
sind diese Aufträge alles andere als ungefährlich.

Doch wer weiß? Vielleicht liegt einem ein Leben als Pirat doch besser. Kein
Problem, ist halt nur ein wenig gefährlicher, schließlich ist die hiesige
Polizei nicht auf Fahrrädern unterwegs und die Piloten sind keine blutigen
Anfänger...

Soweit ein kleiner Ausschnitt aus der Hintergrundgeschichte zu Elite.
Dieser Ausschnitt zeigt bereits, welche unglaubliche Spieltiefe sich
dahinter verbirgt. An erster Stelle steht hier wohl das Handelssystem von
Elite. Man handelt hier mit den üblichen und bekannten Waren, wie
Nahrungsmittel, Computer, Waffen aller Art, Edelsteinen etc. etc. Diese
kauft man in einem System ein (billig, versteht sich!) und verkauft sie
woanders wieder (muss ich noch was sagen? ;).

@{"Screenshot" LINK "elite.png/MAIN"} (ab OS 3.0; PNG-Datatype muss installiert sein)

Die alten Kämpen werden jetzt schon wieder in Erinnerung schwelgen: Die
geradezu gigantische Lose-Blatt-Sammlung mit Preislisten für Elite... es
macht nämlich durchaus Sinn, sich die Preise der einzelnen Waren in den
einzelnen Systemen zu merken. Die Preise schwanken zwar leicht, aber es
gibt auch Schwankungen anderer, größerer Art: Jedes Sonnensystem hat
nämlich seine Eigenheiten, die bei der Fauna anfangen und bei der
Regierungsform noch nicht aufhören. Jeder dieser Faktoren hat einen
Einfluss auf die Preise bestimmter Güter. So sind zum Beispiel Waffen in
Systemen sehr gefragt, deren Regierungsform die Anarchie ist (ja, klingt
merkwürdig, ist aber so im Spiel beschrieben ;). Systeme, die
hochindustrialisiert sind, haben natürlicherweise erhöhten Bedarf an
natürlichen Ressourcen wie Früchte, Felle und so weiter. Hier ergeben sich
viele Möglichkeiten, das dicke Geld zu verdienen.

Hier kommt übrigens eine weitere programmtechnische Besonderheit von Elite
ins Spiel: Es bietet eine unglaubliche Anzahl von Planeten, verteilt über
mehrere Galaxien, die alle unterschiedliche Merkmale haben. Es gibt also
reichlich zu handeln!

Die nächste Möglichkeit, Geld zu verdienen, ist eher spärlich gesät: Ab und
an wird man nach der Landung in einer Station von einem Reisenden oder
einem Regierungsbeauftragten angesprochen, der einem einen Auftrag
anbietet. Es handelt sich dabei um die verschiedensten Missionen.
Angefangen von einem einfachen Termingütertransport über die Suche nach
einem bestimmten Gegenstand bis zum gefährlichen Geheimauftrag ist alles
dabei. Nach Erfüllung des Auftrages bekommt man den vereinbarten Lohn und,
je nach dem ob der Auftrag mit Raumkämpfen verbunden war oder nicht, kann
auch noch eine höhere Rangeinstufung dazu kommen.

Zu guter Letzt gibt es noch die Möglichkeit, sich als Pirat zu versuchen.
Auch hier kann man gut Geld verdienen, indem man unvorsichtige Händler im
Raumkampf besiegt und die verwertbaren Überreste des Raumschiffs
einsammelt. Mit ein bisschen Glück ist eine Rettungskapsel mit dem
unglücklichen Raumfahrer darin unter den Trümmern. Sklaven sind auf vielen
Welten sehr gefragt...

Damit sind wir dann auch beim Rangsystem von Elite. Neben der Notwendigkeit
des Geldverdienens gibt es ja noch das Streben nach Ruhm und Ehre (oder
nach Furcht und Unehre, wenn man sein Leben als Pirat leben will ;). Wie
bereits erwähnt, wird der Spieler im Verlauf des Spiels bewertet, nämlich
nach fliegerischem Können und Gesetzestreue. Je mehr Piraten oder andere
Angreifer man besiegt, desto höher wird man eingestuft. Diese Rangstufen
laufen von "Harmlos" über "Gefährlich" bis "Elite" (mit ein paar Stufen
dazwischen). Zusätzlich wird in die Bewertung die Zeit eingerechnet, die
man bis zum Sieg über den Gegner benötigt. Der Spieler wird im Laufe des
Spiels nämlich feststellen, dass unter den Piraten und vor allem den
Thargoiden ziemlich harte Brocken sind, die man nur schwer knacken kann.
Je schneller man diese besiegt (und damit vom fliegerischen Können her
besser als diese ist), desto mehr Rangpunkte erhält man. Allerdings ist das
Programm so gemein (oder so klug), die Rangpunkte im Laufe des Spiels immer
stärker nach der Zeit bis zum Sieg und der Klassifizierung des Gegners zu
vergeben, so dass ab einem bestimmten Level es nicht mehr ausreicht,
möglichst viele (einfache ;)) Gegner zu besiegen.

Das Rechtssystem von Elite ist dagegen relativ einfach gestrickt: Greift
man ein Raumschiff an, dass nicht erkennbar ein Pirat ist oder einen selbst
nicht angegriffen hat, verstößt man gegen geltendes Recht, was auch im
Strafregister festgehalten wird. Genauso wird es gehalten, wenn man Waren
in ein Sonnensystem einführt, die laut Preisliste illegal sind. Je nach
Anzahl und Höhe der Verstöße kann es einem dann recht schnell passieren,
dass man in einem Sonnensystem gleich von der Polizei angegriffen wird,
statt von Piraten ;)

Ein Wort zu den Thargoiden: Nach einhelliger Meinung vieler altgedienter
Elite-Kämpfer sind diese außergalaktischen Wesen die härtesten Gegner, die
man in Elite zu Gesicht bekommt (mit einer Ausnahme, die hier aber nicht
verraten wird ;).
Sie treten eher selten auf, dann aber in Gruppen und immer mit einem großen
Mutterschiff, dass man nur mit den größeren Geschützen kleinkriegt. Eine
kleine Gemeinheit diesbezüglich ist im Programm eingebaut: Ab und an
versagt das Hypersprung-System des eigenen Raumschiffs und bringt einen in
eine Art Raumblase, wo sich häufig Thargoiden versteckt halten. Man kann
sich vorstellen, dass gerade Anfänger hier oft scheitern, die Profis es
dagegen darauf anlegen, einen missglückten Hypersprung zu machen...

An der Länge des Artikels merkt man es vielleicht schon: ein wahrer
Klassiker. Und jeder darf ihn selbst testen oder wiederentdecken, denn er
ist frei erhältlich auf der Website des Programmierers Ian Bell [1].

[1] http://www.iancgbell.clara.net/elite/

Oliver Tacke <oliver@aakt.de>

@ENDNODE

@NODE "Spiele8" "Spieleteil"
@TOC "MAIN"

8. Schlusswort

Das war es schon. Mein Versprechen, mehr Artikel zu liefern, habe ich
eingehalten, und das nächste Mal werden es vermutlich sogar noch mehr
werden. Ein paar Ideen habe ich noch in der Hinterhand, für die ich bislang
keine Zeit hatte. Helfende Hände werden natürlich dennoch gerne gesehen.

Das nächste Mal werde ich Payback ein wenig genauer unter die Lupe nehmen.
Zwar ist das Spiel schon ein paar Tage alt, aber diverse Updates,
zahlreiche neue Maps und nicht zuletzt die in Arbeit befindliche Version
für das AmigaDE sollten einen guten Grund abgeben.

Ähnliches gilt für dynAMIte, das seit der Urversion um zahlreiche
Funktionen erweitert wurde. Das schau ich mir auch an.

Wieder dabei sein wird ein Bericht über einen Oldie, einen Klassiker, ein
Sahnestück der Unterhaltungssoftware.

Und warten wir mal ab, was uns der Frühling noch so bringt.

Bis dahin,

Euer Oliver <oliver@aakt.de>

@ENDNODE

@NODE "AMIGANG1" "Neues zum AmigaNG"
@TOC "MAIN"

Neues zum AmigaNG
-----------------

1. Neues Executive Update von AMIGA-CEO Bill McEwen

AMIGA, Inc. (http://www.amiga.com) informiert:

»Executive Update - AMIGA-Status und Ankündigungen

Bill McEwen - 22. Februar 2002

Meine Grüße an die weltweite Amiga-Familie!

Ja, ich weiß, es hat länger als eine Woche gedauert und, ja, die
Verhandlungen laufen immer noch und, ja, es geht flott vorwärts mit
uns, wie ich es Ihnen allen weiter unten beschreiben werde.

Ich möchte persönlich allen unseren Freunden und Familien danken, dass
sie zu uns und unseren Träumen gehalten haben, die nun Wirklichkeit
werden sollen.

AMIGA entwickelte sich in den vergangenen zwei Jahren, und unsere Pläne
mussten nur leichte Änderungen erfahren, deshalb möchte ich jedem Einzelnen
von Ihnen danken für Ihre Geduld und Hoffnung bei unserem Voranstreben.

Im Jahre 1999 entschloss sich AMIGA, Inc., einen vollständig anderen Weg
einzuschlagen als den, der zuvor für die Gemeinschaft aufgezeichnet
war. Von einigen wurde er ungläubig betrachtet, von den meisten aber mit
der Erwartung, dass ein Pfad geschlagen wird in eine Zukunft, in der
digitale Inhalte von jedem beliebigen digitalen Gerät in Anspruch genommen
werden können. Amiga wählte mit der Tao-Group in Reading, England, einen
unbekannten Partner, und ich kann Ihnen versichern, das war die beste
Entscheidung, die wir je getroffen haben.

Nie zuvor waren Tao und AMIGA enger in einer wahren Partnerschaft
verbunden als jetzt. Ich möchte meinem lieben Freund Francis Charig danken
genau so wie dem Rest des Tao-Teams, da sie uns zu den Erfolgen gefördert
haben, die bald öffentlich bekannt gegeben werden.

Doch bei allen den großen Plänen, die wir hatten, und bei der Entwicklung
der Produkte, die begonnen hatte, bestand immer die Notwendigkeit, die
erforderlichen Mittel dafür zur Verfügung zu haben, und da war der Zugang
von Frank Wilde als unser Vorsitzender eine erstaunliche Hilfe, und ich
kann sagen, dass AMIGA voran schreitet in einer Weise, die AMIGA auf
neue Ebenen bringen wird und ich könnte nicht glücklicher sein als mit
den Ergebnissen, die nun in Sichtweite sind.

Dank an Sie alle, die die Treue halten und die Wahrheit über AMIGA
weitergeben.

Ich habe einige Ankündigungen über Dinge zu machen, die hier geschehen
und Sie sollen wissen, dass wir im Jahr 2002 mehr auf Amiga basierende
Produkte ausliefern werden als in den früheren Jahren.

   o Unser STB (Set Top Box) Partner - Nokia - und sein neues Media
     Terminal. Ja, das gleiche Nokia, dass Sie alle kennen und lieben.
     Amiga wird auf diesem Produkt vorinstalliert sein und wir werden
     die Auslieferung im Frühsommer dieses Jahres beginnen. Die Ankündigung
     von Nokia wird in den nächsten Wochen auf deren Website erscheinen,
     aber wir haben den Vortritt und stellen unsere Veröffentlichung
     vor, und danach wird noch eine gemeinsame Erklärung folgen.
   o Ich erhalte oft Mitteilungen mit der Frage, wann wir den Rest der
     Welt von dem, was geschieht, in Kenntnis setzen. Nun, für alle, die
     gefragt haben - AMIGA wird an der Embedded Systems Show in San
     Francisco, Kalifornien, vom 12. bis 15. März teilnehmen. Wir werden
     im Stand 1602 in der Südhalle des Moscone Center sein. Wir werden
     die neue Amiga Technologie vorstellen und einige erstaunliche neue
     Eigenschaften zeigen, die bisher noch bei keinem anderen Produkt zu
     sehen waren. Wir werden dort bei der Show mindestens eine weitere
     Ankündigung machen.
   o Wir haben zwei neue Mitglieder in unser Team aufgenommen, und bald
     werden viele weitere genannt werden. Die ersten Beiden sind Teil
     unser Vertriebsmannschaft. Beide sind voll engagiert und freuen sich,
     bei der Amiga-Familie zu sein. Liz Barnick und David Brott traten im
     Januar zu uns und arbeiten sich schnell ein mit neuen Geschäftsideen
     und guten Vorschlägen. Ich habe Informationen über beide Mitarbeiter
     in einem weiteren Dokument zusammengestellt, das diesem Update
     beigefügt ist.
   o AmigaOS 4.0 macht schöne Fortschritte und ich freue mich sehr über
     Hyperion und die Art und Weise, wie sie die Dinge voran treiben.
     Wir alle werden stolz sein mit dem Ergebnis ihrer Anstrengungen
     und ich weiß, dass viele von Ihnen anerkennen werden, was da
     geschaffen wurde, und was für ein Produkt da gebaut wird.

Ich kann Ihnen versichern, dass unsere Geduld wirklich belohnt wird und
dass nun viele andere lernen, was Sie bereits wissen. Dass nämlich Amiga
die stabilste, talentierteste und engagierteste Gemeinschaft hat, die
eine Computerplattform jetzt oder in der Zukunft haben kann.

Danke für Ihre immerwährenden Gebete und Ihre Unterstützung. Sie werden
bald belohnt werden.


Mit meinen besten Wünschen an alle,

Bill McEwen und das übrige AMIGA Team«


Die Übersetzung aus dem Englischen stammt von Gernod Schomberg.

@ENDNODE

@NODE "AMIGANG2" "Neues zum AmigaNG"
@TOC "MAIN"

2. Nokia wird offizieller Partner von AMIGA, Inc.

AMIGA, Inc. hat bekanntgegeben, dass die in Entwicklung befindliche
Betriebsumgebung AmigaDE auf dem Multimediagerät "Mediaterminal" des
weltgrößten Mobiltelefonherstellers Nokia vorinstalliert sein wird.
Zunächst ist das Produkt, dessen genaue Spezifikationen auf der Website
http://www.nokia.com/multimedia/mediaterminal.html zu finden sind, für den
schwedischen Markt vorgesehen.


AMIGA, Inc. (http://www.amiga.com) informiert:

»AMIGA soll AmigaDE auf Infotainment Device [Informations- und
Unterhaltungsgerät] für den Heimbereich bereitstellen

02. Februar 2002, Snoqualmie, Washington - AMIGA Inc, ein aufsteigender
Führer bei der Medienübertragung, gab heute bekannt, dass Amiga auf
dem Nokia-Mediaterminal für den schwedischen Markt vorinstalliert sein
wird. Das kürzlich in Schweden gestartete Nokia-Mediaterminal, ein
innovatives 'Infotainment' [Informations- und Unterhaltungs-] Gerät für
den Heimbereich, vereinigt digitalen Videorundfunk (DVB) [= Digital Video
Broadcast], Spielmöglichkeiten, Direktempfang und Herunterladen von
digitalen Medien, vollen Internet-Zugang und persönliche Videorecorder
(PVR) Technologie. Eine auf Linux basierende Version des AmigaDE wurde
im Nokia Mediaterminal eingesetzt.

"Die heutige Ankündigung ist ein weiterer klarer Schritt vorwärts zu
unserer Vision, dem Amiga-Anwender die Möglichkeit zu bieten, auf ihre
beliebtesten Anwendungen mit jedem Gerät und auf jeder Plattform
zugreifen zu können," sagte Bill McEwen, Präsident/CEO von AMIGA Inc.
"Der Einsatz von Amiga auf dem Nokia Mediaterminal bietet den Verbrauchern
eine Fülle von Spiel- und Unterhaltungsmöglichkeiten über ein zentrales
Gerät, das an ihren Fernseher angeschlossen ist."

Durch die Verwendung des AmigaDE auf dem Nokia Mediaterminal können die
Anwender die neusten Spielmöglichkeiten, MP3, MPEG4 herunterladen und
speichern, an allgemeinen Chats teilnehmen und Video direkt empfangen.
Damit wird aus dem Familienfernseher ein multifunktionelles Zentrum
für die Unterhaltung.


Über AMIGA
AMIGA Inc. etablierte sich 1985 als der weltweit erste Anbieter für
Multimadiatechnologien. Heute führt AMIGA immer noch auf dem Weg zu
Multimedia dadurch, dass es sprachunabhängige Technologien den Entwicklern
zur Verfügung stellt, um Anwendungen zu schreiben und zu portieren für
eine neue Multimediaplattform, die Hardware-unabhängig ist. Deren AmigaDE,
betrieben mit intent(TM) der Tao Group erlaubt es, Anwendungen unverändert
auf einem weiten  Bereich von Prozessoren laufen zu lassen, darunter ARM,
StrongARM, Intel X-Scale, MIPS, Intel x86, Motorola 68K und Hitachi SH.
Es kann aufgesetzt werden auf viele verschiedene Operationssysteme, wie
Linux, Embedded Linux, Windows 95, 98, 2000, NT, and Pocket PC. AmigaDE
Player und Anwendungen für die AmigaDE-Umgebung können gekauft werden bei
http://de.amiga.com. Die Zentrale von AMIGA ist in Snoqualmie, WA, USA und
hat weltweit Niederlassungen. Sie können AMIGA erreichen über (425) 396-
5660 oder AMIGA im Internet besuchen bei http://www.amiga.com.«


Die Übersetzung aus dem Englischen stammt von Gernod Schomberg.

@ENDNODE

@NODE "AMIGANG3" "Neues zum AmigaNG"
@TOC "MAIN"

3. AMIGA, Inc. stellt weitere leitende Mitarbeiter ein

AMIGA, Inc. (http://www.amiga.com) informiert:

»Liz Barnick tritt als Direktorin, Business Development, bei AMIGA ein

02. Februar 2002, Snoqualmie, WA - Liz Barnick kommt zu AMIGA mit einer
über 15-jährigen Erfahrung in der Verkaufs-, Vermarktungs- und
Geschäftsentwicklung in der technologischen Industrie. Zuletzt war sie
Vizepräsidentin für Geschäftsentwicklung bei RAVISENT Technologies Inc.,
wo sie verantwortlich für die Begründung und Pflege kritischer Geschäfts-
Verbindungen war und mit großem Eifer Ziele der Auftragsbeschaffung
weltweit verfolgte. Davor hatte sie die Verkaufsverwaltung bei Seagate
Softwarenetwork & Systems Group, wo sie eine Verkaufsgruppe leitete,
die unternehmensweite Lösungen für das Fortune 1000 bereitstellte. Und
davor arbeitete sie bei Computer Associates als Leiterin des landesweiten
Verkaufs und war für die Hauptabrechnung zuständig. Frl. Barnick war auch
viele Jahre in der CAD/CAM-Industrie tätig bei Gesellschaften wie
CalComp-Lockheed Company und Summagraphics. Frl. Barnick hat einen
Abschluss als Bachelor of Science der California Polytechnic Universität,
Schwerpunkt Absatzpolitik.«


»David Brott tritt als Direktor, Business Development, bei AMIGA ein

02. Februar 2002, Snoqualmie, WA - Vor seinem Eintritt bei AMIGA war Herr
Brott Vizepräsident für Lizenzvergabe und Beurkundung bei InterActual
Technologies, wo er die weltweiten Tätigkeiten zur Lizenzierung von
Technologien und Warenzeichen leitete. Seine Verantwortung schloss
InterActuals Bestätigungsprozess ein, der die Prüfung der API-Eignung
für eingebettete Webbrowser, MPEG-2 DVD Halbleiter und DVD-Set-Top-
Systeme für Endkunden enthielt. Herr Brott hatte auch die Stelle eines
Direktors für Geschäftsentwicklung bei Ravisent Technologies mit
weltweiter Verantwortung für Technologie-Lizenzierung und Geschäfts-
Verbindungen. Beim Seal Team Three, United States Navy, war Herr Brott
verantwortlich für taktische Kommunikation und Einsatzplanung. Er erhielt
seinen BA [Bachelor of Arts] von der University of California in San Diego,
und hat die Fortgeschrittenenkurse der Wharton Executive Education und des
Center For Creative Leadership abgeschlossen.«

@ENDNODE

@NODE "AMIGANG4" "Neues zum AmigaNG"
@TOC "MAIN"

4. Zusammenfassung der »AMIGA & Microsoft«-Ereignisse (von C. Schröder)

Nachdem AMIGA-CEO Bill McEwen in seinem neuesten Executive Update - ihr
könnt es in dieser Ausgabe nachlesen - versehentlich oder mit Absicht (das
sei einmal dahingestellt) die Nummer des (vermeintlichen AMIGA-)
Messestandes auf der Mitte März in San Francisco stattfindenden "Embedded
Systems Show" veröffentlichte, dauerte es nur Stunden, bis die ersten User
feststellten, dass in der offiziellen Ausstellerliste [1] unter besagter
Nummer (1602) nicht etwa AMIGA, Inc., die Tao-Group oder auch Nokia
eingetragen ist - sondern niemand Geringeres als der weltgrößte
Softwarekonzern Microsoft. Natürlich schossen sofort Gerüchte ins Kraut -
AMIGA bei Microsoft, konnte da etwas dran sein? Die zu dem Zeitpunkt noch
recht gelassene Stimmung unter den Anwendern deutete jedoch darauf hin,
dass dies kaum jemand für möglich hielt.

Um all diesen Spekulationen ein Ende zu setzen, entschloss sich wenige Tage
später Gary Peake, Mitarbeiter von AMIGA, Inc., in der offenen Amiga-
Mailingliste "AMIGEN" folgende Bestätigung zu veröffentlichen:

"Yes, Microsoft has asked us to demo DE and some of the developer
applications running on various devices in their booth."

(Auf deutsch: "Ja, Microsoft hat uns gebeten, das AmigaDE und einige
Entwicklerprogramme auf verschiedenen Geräten an ihrem Stand vorzuführen.")

Wie jeder weiß oder sich zumindest denken kann, erreichte er damit das
genaue Gegenteil - alle möglichen Gerüchte machten fortan die Runde, und
die Reaktionen mancher User glichen einem Erdbeben. Das alles, obwohl noch
völlig unklar war und auch heute noch ist, was AMIGA, Inc. und Microsoft
auf dieser Messe eigentlich bekanntgeben werden - wenn das überhaupt der
Fall ist. Denn bislang hat AMIGA - wenn man die Äußerung von Gary Peake als
offiziell betrachtet - lediglich einen einzigen(!) Satz - siehe oben - von
sich gegeben - der zwar Raum für allerlei Spekulationen lässt, aber extrem
arm an konkreten Informationen ist und nur aussagt, dass die Firma AMIGA,
Inc. auf Einladung von Microsoft an dessen Stand auf verschiedenen Geräten
das AmigaDE und einige Entwicklerprogramme präsentieren wird - mehr nicht.
Von einer Kooperation ist (noch?) keine Rede. Dass aber das AmigaDE
zukünftig auf einer Vielzahl von Hardwareplattformen, darunter auch
Microsofts PDA-Betriebssystem, lauffähig sein soll, ist bereits seit einer
Ewigkeit bekannt, und aus diesem Grund, ist auch eine Präsentation der
Amiga-Entwicklung an einem Microsoft-Messestand aus meiner Sicht zunächst
einmal nichts Sensationelles.
Unter [2] sind übrigens Informationen zu Microsofts Messeauftritt inklusive
der Namen der beteiligten Unternehmen - AMIGA, Inc. ist bei weitem nicht
das einzige - zu finden.

Ergo: Bevor nicht klar ist, wie sich eine mögliche Beziehung zwischen den
beiden Unternehmen konkret gestaltet, sehe ich keinen Grund, mich zu
irgendwelchen Spekulationen hinreißen zu lassen. Ich möchte an dieser
Stelle lediglich anmerken, dass sich bei einer Kooperation mit Microsoft
für die Firma AMIGA - neben ein paar Risiken (die existieren allerdings bei
jeder Partnerschaft) - eine Vielzahl von Chancen ergeben könnten - in
unterschiedlichsten Bereichen (finanziell, technologisch, die Bekanntheit
AMIGAs bzw. Verbreitung des AmigaDE betreffend, etc.). Lassen wir uns also
von dem überraschen, was Mitte März - möglicherweise - bekanntgegeben wird.

Übrigens: Viel spekuliert wurde in den letzten Tagen wie gesagt über die
Beziehung zwischen AMIGA und Microsoft - aber nicht über die des neuen
AMIGA-Chairmans Frank Wilde und des CEO Bill McEwen sowie deren
Machtpositionen im Unternehmen.
Ich jedenfalls halte es für sehr gut möglich, dass die jüngsten
Entwicklungen maßgeblich vom Chairman initiiert worden sind - dafür spricht
auch die Berufung von Liz Barnick und David Brott ins Management von AMIGA,
Inc. Denn beide waren zuvor bei der Firma Ravisent tätig - und bis vor gar
nicht so langer Zeit war deren CEO ein gewisser Frank Wilde...

[1]
http://vbooth.tscentral.com/exhibitorsDynamic.asp?project=CM
P_ESCONF_SF0_02&systemAttrs=DrawingInventory.number^Booth&so
rt=Booth&OpsMode=true&template=SPBoothNameSort

[2]
http://www.microsoft.com/windows/embedded/sak/techinfo/events/escwest.asp

Carsten Schröder <aakt@aakt.de>

@ENDNODE

@NODE "AMIGANG5" "Neues zum AmigaNG"
@TOC "MAIN"

5. Kommentar zur »AMIGA & Microsoft«-Thematik (von Jürgen Theiner)

Früher oder später kriegen wir euch...

Kaum ein Thema hat die Amiganer in der letzten Woche mehr bewegt als die
Ankündigung, daß sich Microsoft für AmigaDE interessiert.
Natürlich kann auch ich bei so einer Sache nicht den Mund halten und muß
meinen Senf dazu geben.

Als ich die Nachricht las, wußte ich zuerst einmal wirklich nicht, was ich
davon halten soll. Deshalb fing ich erst einmal damit an, mir Gedanken über
die Beweggründe von AMIGA, Inc. zu machen. Und die scheinen ja auf der Hand
zu liegen: Geld. Nachdem man sich anscheinend mit Nokia einig ist, daß das
AmigaDE dort auf den neuen Handys läuft, ist mit Microsoft der nächste
große "Partner" gefunden. Aus marktwirtschaftlicher Sicht ist es sicher
richtig, sich immer an den Ersten zu orientieren. Und dann sagten mir auch
einige Leute, daß sie stolz darauf seien, daß so ein Riese wie MS sich
überhaupt mit dem kleinen Zwerg Amiga abgibt. Nun, wie gesagt, im VWL-
Unterricht würde ich sagen: gut gemacht!

Trotzdem blutete mir innerlich das Herz. Da habe ich seit über 10 Jahren
einen Rechner bei mir, den ich in mühevoller Kleinarbeit (und unter Einsatz
beträchtlicher Geldmittel) hege und pflege, während sich mein Bruder jedes
Jahr einen neuen Rechner kauft und die alten Teile einfach verscherbelt. Er
läuft mit einem Microsoft T-Shirt herum, während ich stolz auf meine Amiga-
Socken und den Wintel-Outside-Aufkleber bin. Es tut halt gut, etwas
Besonderes zu sein!

Das Problem ist halt folgendes: Natürlich muß AMIGA, Inc. Geld machen, um
wettbewerbsfähig zu sein. Und ich glaube, daß es noch nicht einmal die
Tatsache ist, daß sie auf dem Microsoft-Stand AmigaDE vorführen, sondern
eher die Frage: Ist das überhaupt noch Amiga?

Wie definiert sich Amiga? Ist es Pflicht, daß es eines der "alten"
Motherboards sein muß (eventuell halt mit Erweiterungen) oder ist die
Plattform komplett egal (eben auch x86 z.B.)? Oder soll es doch eine
komplett neue Hardware sein, die sich aber wie seinerseits der Classic-
Amiga durch spezifische Merkmale von der Masse abhebt? Oder ist selbst das
kein Amiga mehr?

Ich glaube, der Aufruhr geht nicht nur gegen Microsoft (obwohl das an und
für sich schon ein guter Grund ist) sondern ist einfach die Art der meisten
User, sich mit der Tatsache abzufinden, daß es "den Amiga" auf kurz oder
lang nicht mehr gibt. Für mich persönlich ist es halt so, daß das
Motherboard, welches seit Jahren für mich den Dienst verrichtet, "mein
Amiga" ist. Lösungen wie Amithlon sind halt wirklich gut und helfen
wahrscheinlich auch, den Spirit noch ein paar Jahre in die Zukunft zu
befördern, aber ich persönlich werde versuchen, den Tag, an dem ich meinem
Amiga den Saft abklemmen muß, um irgendeinen neuen Computer (egal was da
kommt, egal mit welcher Software) in Betrieb zu nehmen, hinauszuzögern.

Ja, ja, ich weiß. Diese Einstellung verhindert den Fortschritt. Man kann
nicht immer am Alten festhalten, man muß auch schon mal loslassen, um neuen
Sachen den Einzug zu ermöglichen. So halten viele das OS 4 für absolut
überflüssig, weil es keine Innovation darstellt, um neue Kunden zu gewinnen
oder gar alte Amiga-User wiederzuholen. Ich persönlich halte dies
allerdings für nicht ganz richtig. Ich freue mich auf das neue OS, um noch
einmal das letzte aus meinem alten Amiga herauszuholen. Wenn dann
irgendwann einmal dieses OS auf einer neuen Plattform läuft, wird mir der
Übergang wesentlich leichter fallen. Aber zu diesem Thema gibt es
wahrscheinlich zig verschiedene Ansichten, deshalb würde ich mich freuen,
wenn ihr uns so viele Mails wie möglich hierzu schickt (aakt@aakt.de)
Wie steht ihr zu dem Ganzen?

Lange Tage und angenehme Nächte,

Euer

Jürgen Theiner <juergen.Theiner@t-online.de>

@ENDNODE

@NODE "AMIGANG6" "Neues zum AmigaNG"
@TOC "MAIN"

6. Neue Informationen zum AmigaONE

Wenige Tage nachdem auf der britischen Messe alt.WOA eine lauffähige
Version des in Entwicklung befindlichen PowerPC-Mainboards AmigaONE
präsentiert werden konnte, hat sich Alan Redhouse von Eyetech mit neuen
Informationen über das Projekt zu Wort gemeldet.

Nachfolgend die wichtigsten Punkte in Kürze, welche Christoph Gutjahr
(c.gutjahr@gmx.de) für unseren Partner amiga-news.de auf deutsch
zusammengefasst hat, im Anschluss daran findet ihr das komplette Original-
Statement in englischer Sprache:


»
* Im Laufe dieser Woche wird es ausführliche, offizielle Informationen auf
  den Webseiten von Eyetech und Amiga, Inc. geben.

* Der AmigaOne wurde im Auftrag von Eyetech in Fernost entwickelt.

* Das Motherboard hat ein OpenFirmware-kompatibles BIOS, derzeit läuft
  TurboLinux darauf.

* Sobald absehbar ist, dass die OS4-Betatests reibungslos über die Bühne
  gehen, wird die Produktion gestartet. Etwa sechs Wochen später wird das
  Board dann im Handel erhältlich sein.

* Das Einsteigermodell kommt mit festverlöteter G3/600 CPU.

* Die zweite Charge kommt dann mit gesockelter CPU, evtl. wird es auch eine
  Version mit fest verlötetem G4 Prozessor geben.

* Anschlüsse für Keyboard/Maus (PS/2), Floppy, Seriell, Parallel.

* 2 USB Anschlüsse auf dem Motherboard plus zwei zusätzliche per "Header".

* 133 MHz FSB, AGP2

* LAN, AC97, MC97, UDMA100 on-board

* Preis für das Einsteigermodell: 350 UKP / 600 Euro (ohne Steuern und
  Versandkosten)«


»First of all thanks to everyone on this list for their patience. We have
been working very hard to get something demonstrably working rather than
just announcing more promises. Ideally on Friday we would have announced
that the A1 was going to be at the show, but at that point the board was
locked up in British customs. We didnt pick it up from UPS's Durham depot
(120 miles from the show) until 7:30 saturday morning and had no idea
whether it had survived the journey from the other side of the world until
we configured it at the show and switched it on.

Secondly, Fleecy and I were plannning to sit down and make sure that we
issued a jointly acceptable, coordinated, news release on the A1. But he
got snowed in in Cumbria, so we cant now do that until later in the week.
Expect a major web site update on both our and Amiga's sites next Monday.

But in the meantime I'm going to repeat here some of the things I said at
Alt-Woa as some of the 'authoritative' postings on this list (& ann) have
been off in the realms of fantasy and bear little if any relationship to
what I actually said.

But first a bit of of background.

Yes I do read this list and try to filter out and take note of what is said
(apart of course from the rude postings). The main feedback that has come
out over the last year can, I think, be summarised as follows:

CPU speed concerns
Memory speed concerns
Provision of legacy peripherals (FDD/Serial/Parallel/kb/mouse)
Provision of integrated peripherals
AGP speed
Will it run Linux?
But I dont have/want/will never buy an A1200
Will it fit in in an EZTower mk1-5/RBM/xyz tower?
It costs too much (interesting this one as the price has never been
announced)
and, of course
Where is it?

In October 2000 when we laid out the design for the A1, there was no
commercially available 'northbridge' chip (the interface between the CPU,
memory and PCI bus) at the relatively small quantities that we needed at an
economic price. 'Southbridge' chips were available (these handle the system
timing, interrupts etc and, traditionally also embed the lower speed
peripheral functions such as IDE, USB etc), but clearly these do not come
with a built in A1200-PCI bridge - which would have to be built in custom
logic. It therefore made economic sense to build a custom southbridge chip
- but without the integrated peripherals (these were available on separate
chips at low cost anyway) which incorporated the A1200-PCI bridge. Things
were going nicely until May/June . . . . and you know the rest, or most of
it anyway.

By the time OS4 development had been signed off in early November the world
had moved on. Commercially available PPC northbridge chips were available,
and coupled with off-the-shelf southbridge chips, were able to deliver
better price performance than the original A1 custom chip design, and
(since the big boys had already been using them successfully) without the
risk of bugs intrinsically present in any custom logic implementation. This
meant that the only custom logic function needed was the PCI to A1200
bridge.

Alongside this many people had expressed a wish only to have a stand-alone
A1 board, without the need (or ability) to run hardware-hitting
applications. In addition Hyperion have been making better than expected
progress in decoupling the chipset dependancies in the OS with a result
that it will cease to be reliant on the Amiga chipset quite soon now. (Of
course hardware hitting applications will still to a greater or lesser
degree need access to a genuine Amiga chipset). Given this, we thought it
would be sensible to try to provide Amiga chipset availability as an a
option, so that the main A1 board would not have to carry the cost of
providing this connection - in terms of PCB and component real-estate and
in requiring a custom tower to mount it in. The upshot is that Escena has
come up with a solution which allows the bridge to the A1200 chipset to be
made from a PCI card, via ribbon cable, to the A1200 edge connector. The
use of a ribbon cable also solves the 'will it work in an xyz tower'
problem, as there is (within limits) quite a wide range of A1 & A1200
relative board positioning that can be used. Theis A1200 bridge will be an
additional cost item for those who need it.

So with Escena concentrating their efforts on the bridge card, and us
deciding to use off-the-shelf north and south bridge parts for the main
board it made sense to subcontract the design and manufacture to experts in
this field, who, surprise, surprise, are far east based (hence the problem
with customs on Friday). The board (currently) runs an open
firmware-compatible bios and runs PPC linux (which is how we know that the
hardware works properly before OS4.0 is released).

In terms of timeframes the board is now ready to go into production, with a
lead time of 4-6 weeks. However we will not press the button until we can
be sure that OS4 will be ready to run on the board in the same timeframe.
OS4 is scheduled to go into beta during March, and we will make A1 boards
available to help with this process. When we get the thumbs up from
Hyperion we will start production and they will be with your local dealer
around 6 weeks later.

In terms of specification the entry level board will run a 600MHz G3 CPU
and will come with this soldered in place, thereby keeping the costs as low
as possible. After the first production run we will be producing boards -
obviously at a higher cost - with a cpu carrier so that cpu's can easily be
interchanged to suit your speed and pocket requirements. As G4's fall in
price we may also offer a soldered in place G4 cpu option as well. What
happens if you buy an entry level board and want to upgrade it in a  year
or so's time? Well exactly the same as when you bought a similarly priced
accelerator a couple of years back and want to upgrade to a faster one. You
either sell it privately or trade it in to the dealer where you purchased
it. In fact in the PC market, depite all processors being socketed, hardly
anyone ever changes the cpu to improve the computer - they nearly always
have to buy a (at least) a new motherboard as well. We're just being
upfront
about it!

So lets revisit that feedback list again:


CPU speed concerns   -- G3/G4 to their current clocking limits

Memory speed concerns  --  133MHz FSB (DDR doesn't help PPC's I am told)

Provision of legacy peripherals (FDD/Serial/Parallel/kb/mouse)  - On board

Provision of integrated peripherals - 2xUSB (motherboard) + 2 more on
headers; LAN; AC97; MC97; UDMA100

AGP speed - 2x (although this is still a red herring in my view)

Will it run Linux? - Yes

But I dont have/want/will never buy an A1200 - Fine by me

Will it fit in in an EZTower mk1-5/RBM/xyz tower? - Yes (subject to xyz
definition - not sure about wooden towers)

It costs too much (interesting this one as the price has never been
announced) - A1 including 600MHz G3 cpu at current component prices and
exchange rates GBP 350/USD500/Euro 600 excluding local taxes and shipping.
And before anyone (who probably has no notion of real manufacturing and
development costs) pipes up that they can buy a xzzz PC motherboard for
$2.49 from Walmart remember this is for a board being manufactured in the
(very?) low thousands, not by the million. (And don't forget that a 240MHz
603 ppc blizzard with 060 cost around ukp550 ex tax when they were last
available - those were the days ;-) )

Where is it? - In my office running Turbo Linux at the moment. In your
dealer as soon as OS4 is ready.

More on the website next week


Thanks for your patience

Alan«

@ENDNODE

@NODE "Zwischenruf" "Der Zwischenruf"
@TOC "MAIN"

Der Zwischenruf (von Ralf Driesner)
-----------------------------------

Ich bin klein. Mein Herz ist rein.

Es gibt Tage, an denen man die Welt nicht mehr versteht. Der Kaffee ist
goldblond, obwohl man sich sicher zu sein scheint, keine Milch in die Brühe
geschüttet zu haben. Man findet dünne Fadennudeln in der selbstgebrauten
Nudelsuppe, obwohl man dem unerschütterlichen Glauben verfallen war,
Makkaroni-Chips in das mit Pulver gefärbte Suppenwasser gegeben zu haben.
Und zu guter Letzt liest man, dass ausgerechnet AMIGA ein Gastspiel an
einem Microsoft-Messestand haben soll.

Was ist nur los auf dieser kosmischen Kartoffel, in Expertenkreisen auch
Erde genannt? Ein Blick aus dem Fenster zeigt noch dasselbe besch...eidene
Wetter wie am Vortag. Der Nachbar macht auch noch genauso Radau, wie ich es
von ihm gewohnt bin (er beschimpft seinen Hund mit Worten, die wir an
dieser Stelle aus Rücksicht auf die katholische Kirche nicht wiederholen
wollen). Und das Stadtteil-Werbe-Käseblatt ist - wie immer - ein mit Wasser
durchtränkter, trauriger und höchst übelriechender, aus dem Briefkasten
halb heraushängender Zellstofflappen.

Der astrologisch beeinflusste Teil meines Großhirns scheint also
unbegründet Alarm geschlagen zu haben. Die Mondphase ist ok. Und wir werden
auch nicht von Aliens unterminiert. Zum Teil scheinen die aktuellen
Ereignisse unter der Karteikarte "Zufall" abgehackt werden zu können.

Die Story mit Microsoft und AMIGA will mir jedoch nicht ganz aus dem Kopf
gehen. Welche Strategie steckt dahinter? Nun, es gibt verschiedene
Szenarien. Sehen wir uns diese im einzelnen an:


1.

Microsoft will Amiga(-technologie) auf- oder einkaufen. Das meistverkaufte
Betriebssystem der Welt soll also ausgerechnet an einer nicht in der Praxis
erprobten und bewährten Technik anknüpfen. Milliarden Dollar
Forschungsgelder werden ausgegeben, um dann ausgerechnet für 'n Appel und
'n Ei den Kniff der Menschheitsgeschichte in Form von AmigaDE-Technologie
zu integrieren? Unwahrscheinlich.

2.

Ein simpler Schreibfehler, der die ganze Amiga-Welt an den Rand des Herz-,
Hirn- und Ohrinfarkts führt. An jeder Ecke liegt ein röchelndes Etwas mit
einem kleinen BoingBall-Sticker auf der linken Brust. Wie fahrlässig....

3.

Microsoft möchte zeigen, wie einfach multiple Anwendungen und Oberflächen
auf seinem neuen PDA-Betriebssystem gehostet werden können. AMIGA möchte
zeigen, dass keine Rechnerplattform, auch kein PDA, mehr vor dem AmigaDE
sicher ist. Simpel und portabel programmiert. Klein und effizient genug, um
es auch den Großen zu zeigen. Clever...!


Der treue Zwischenruf-Leser, an die unverfälschlich einfache Denkweise des
Schreibers gewöhnt, wird sicher sofort die richtige Antwort herausgefunden
haben. Keine der drei Varianten erscheint sehr realistisch. Obwohl Ziffer
2. gewisse Bezüge zur Realität.....na ja, lassen wir das.

Zunächst ist's wie immer im Leben....David kämpft gegen Goliath. Wir kennen
die Zukunft eben nicht. Und wenn sich die beiden ausgetobt haben wird's bei
einer Maß Milch so richtig zünftig.

Beim Stichwort Milch fällt mir ein, dass ich die, abgelenkt durch die
Köter-Schelte meines Nachbarn, vor dem Kaffe in die Tasse geschüttet habe.
Und Makkaroni-Chips stehen zwar auf der Einkaufsliste aber eindeutig nicht
im Küchenschrank. Alzheimer sei Dank; die Welt ist doch in Ordnung. Auch
wenn das mit diesem pitschnassen Werbeblatt nun nicht unbedingt notwendig
gewesen wäre.....

Lebt lang und erfolgreich!

Euer

Ralf Driesner <global-dries@gmx.de>

@ENDNODE

@NODE "Diverses1" "Diverse Amiga-News"
@TOC "MAIN"

Diverse Amiga-News
------------------

1. Extreme Computing kündigt Amiga-Rechner auf x86-Basis an

Vor wenigen Tagen hat die Extreme Corporation einen neuen Amiga-Rechner auf
x86-Basis angekündigt, der auf der Messe »Amiga Expo«, welche Ende März in
Baltimore/USA stattfindet, präsentiert werden soll.
Hier die englischsprachige Ankündigung, die leider nicht viele Details zu
dem Produkt beinhaltet:

»FOR IMMEDIATE RELEASE

                  Extreme Computing Announce Amiga X1200

Amiga Expo and Extreme Computing are pleased to bring you the following
press release. Please make plans now to visit Amiga Expo on March
29th-31st at the Marriott Hunt Valley Inn in Maryland where you will see
all the latest developments including those from our friends at Extreme
Computing!

Extreme Computing (a branch of Extreme Corporation) began reseach and
development of new Amiga-based products in the Spring of 1999. With the
announcement of the Amiga x86 solution in the Summer of 2001, we began
working overtime to come up with new designs of x86-based hardware that
would be powerful, functional, compelling, upgradable, and above all else
- Amiga and AmigaDE compliant!

The results have far exceeded our expectations. Our new line of x86 based
Amiga hardware will ultimately usher in new levels in design and
performance for the Amiga consumer computing experience. The main goal was
to give the consumers back a true Amiga system. One where you can take it
right out of the box and boot up to an Amiga screen without any hassles or
unnecessary complexity.

One of our guiding concepts was to combine classic designs with modern
technology - thus bringing you the Amiga X1200 computer system. This
system offers the design and compactness of the original Commodore Amiga
A1200, but with all new, and blazingly fast, hardware under the hood. The
Amiga X1200 is the ideal replacement, or addition, to your Amiga computing
needs.

The Amiga X1200 isn't the only exciting new hardware we have coming.
Extreme Corporation will have several MORE innovative and powerful Amiga
solutions on display at their booth at Amiga Expo. All of these designs
are will be shipping with Amiga OS x86(3.9) pre-installed and will come
with a full copy of Nova Design, Inc.'s ImageFX 3.2 on CDROM. As a special
show bonus, all orders placed at Amiga Expo will also come with FREE
SHIPPING.

Extreme Corporation (Formerly Amitech Electronics) was founded by Amiga
Enthusiasts to assist in providing Amiga Owners with useful tools and
information for an ever growing computing experience.

Nova Design, Inc. are the creators of Aladdin 4D and ImageFX - the Amiga's
most consistently top-rated image editing and special effects package and
are the hosts of Amiga Expo. See us all at the show!

For more information on other exhibits and information about Amiga Expo
visit our web site at www.amigaexpo.com and sign up today! Don't forget to
get your hotel rooms and banquet tickets! You can order everything online
or by toll free number as shown on the web site.«

@ENDNODE

@NODE "Diverses2" "Diverse Amiga-News"
@TOC "MAIN"

2. »GlowIcon Collection 2« bei Schatztruhe erschienen

Schatztruhe (http://www.schatztruhe.de) informiert:

»Der Erfolg der GlowIcon Collection 1 bestätigte uns, dass die Freunde des
Amigas sich eine ansprechende Workbenchoberfläche wünschen, die Anwender
anderer Systeme neidisch werden lässt.

Deshalb haben wir eine zweite CD-ROM mit mehr als 3500 neuen Icons
zusammengestellt, die auch die Optik Ihres Systems noch verschönern können.


Die Features:

- qualitativ hochwertige Icons im GlowIcon-Format und im NewIcon-Format aus
  den verschiedensten Bereichen wie Anwendung, Spiele, Schubladen usw.

- Werkzeugleisten im GlowIcon Stil für einige der beliebtesten Programme
  (YAM, Amiga-Writer, ArtEffect, Directory Opus, IBrowse, Voyager, u.a.)

- Skins im GlowIcon Stil für AmigaAmp und CoolCalc.

- Workbench-Hintergründe passend zum GlowIcon Look

Und alles glüht!


GlowIcon Collection 2 lieferbar ab sofort für EUR 19,95
GlowIcon Collection 1 noch verfügbar für nur EUR 9,95
GlowIcon Collection 1 & 2 Bundle EUR 24,95«

@ENDNODE

@NODE "Diverses3" "Diverse Amiga-News"
@TOC "MAIN"

3. Neuigkeiten von Haage & Partner

Haage & Partner (http://www.haage-partner.com) informiert:

»OS XL: Offizielles Update für Amithlon und AmigaXL

05. Feb. 2002: Dies ist das erste offizielle AmigaOS XL-Update, welches die
uns bisher bekannten bzw. gemeldeten Probleme behebt. Unter Amithlon wurde
die Sound-Ausgabe ebenso verbessert wie Maus- und Tastaturtreiber sowie
die CPU/FPU-Emulation. Unter Amithlon und AmigaXL läuft nun die HDToolBox
wieder stabil.


OS XL: Running AmigaOS on a PC - Ein Bericht über AmigaOS XL

06. Feb. 2002: Mike Bourma hat einen interessanten Bericht über AmigaOS XL
auf OSNews veröffentlicht. Er hat bereits sehr viele Pageviews dafür
erhalten und ist schon jetzt der am zweithäufigsten gelesene Artikel auf
OSNews.


DOpus: GP ernennt H&P zum deutschen Distributor

07. Feb. 2002: Das australische Softwarehaus GP Software ernennt
HAAGE&PARTNER Computer zum Exklusiv-Vertrieb für den deutschen Sprachraum
für das Produkt Directory Opus 6 für Windows.

H&P wird zunächst die englische Version vertreiben und dazu einen
deutschsprachigen Support per E-Mail und Telefon anbieten. Die Übersetzung
des Programms folgt in Kürze. Diese wird den Kunden von H&P dann kostenlos
per Download zur Verfügung stehen. Ebenso wird an der Übersetzung der
umfangreichen Anleitung gearbeitet.

Der Preis der neuen Version 6.1 wurde zudem von vorher 89 Euro auf nur noch
69,95 Euro gesenkt. Für registrierte Besitzer der Amiga-Version gibt es
jetzt auch die Möglichkeit eines Sidegrades.


OS XL: AmigaOS XL-Komplettsystem für 999 Euro

08. Feb. 2002: Jetzt gibt es noch mehr Leistung für weniger Geld. Der
Midi-Tower mit der schnellen Athlon XP 1600+ CPU, GeForce 2-Grafikkarte
und einem schnelleren CD-RW-Brenner kostet jetzt nur noch 999 Euro.
Amithlon und AmigaXL/QNX sind dabei vorinstalliert und können über einen
Bootmanager ausgewählt werden. Auf Wunsch können wir Ihnen auch noch ein
Windows-Betriebssystem vorinstallieren.


Xara: H&P übernimmt dt. Vertrieb

Der englische Spezialist für Webgrafik-Software XARA Ltd. ernennt
HAAGE&PARTNER Computer zum Exklusivvertrieb für den deutschen Sprachraum.

Die Palette umfasst dabei das Illustrationsprogramm XaraX und die
Webgrafik-Programme Xara Webstyle und Xara3D. Die Produkte von Xara sind
schon seit Jahren für ihre hohe Geschwindigkeit und sehr einfache
Handhabung bekannt.

Angebot: Bei uns registrierten Besitzern der Vollversion von DrawStudio 2
oder ArtEffect 4 bieten wir XaraX für 178 Euro (statt 198 Euro) und Xara
Webstyle für 88 Euro (statt 98 Euro) an. Bitte bei der Bestellung die
Seriennummer und den Sonderpreis angeben (im Online-Shop im Feld
"Bemerkungen").

Weitere Informationen und 15-Tage-Demoversionen aller Produkte findet man
unter: xara.haage-partner.de


PageStream 4.13

22. Feb. 2002: Seite einiger Zeit ist nun die Versionen 4.1 für Amiga und
Windows verfügbar - genauer gesagt sind dies die Version 4.12 für Windows
und 4.13 für Amiga. Wir haben jedoch von Grasshopper erfahren, dass die
Version 4.13a für Amiga bald erscheinen soll. Daher haben wir die Version
4.13 nicht zum Download angeboten. Wir arbeiten derzeit an den dt. Locales
für die Amiga und die Windows-Version. Auch diese solten bald verfügbar
sein. www.pagestream.de


Freespace: Update

22. Feb. 2002: Auf der Homepage von Hyperion-Entertainment gibt es ein
Update für Freespace.«

@ENDNODE

@NODE "Diverses4" "Diverse Amiga-News"
@TOC "MAIN"

4. Neuigkeiten von der Amiga Arena

Amiga Arena (http://online-club.de/~ARENA/) informiert:

»Amiga Arena - Interview
Stefan Blixth,vielen von Euch besser unter "OnyxSoft" bekannt,hat bis heute
zahlreiche Tools für den Amiga entwickelt. OnyxBase, QuickNote, Graphica
sind nur einige wobei letzteres sich noch in der Alpha Phase befindet und
noch unveröffentlicht ist.
Die Amiga Arena sprach mit Stefan Blixth über seine neuen Programme und ein
sehr ausführlicher Kommentar von Stefan rundet das Interview ab.

PuzzelBOBS News
Auf der PuzzelBobs Support Seite der Amiga Arena liegt das Modul "Rockers
Galore" von  "Up Rough System" zum Download bereit!
Passend zum Puzzel Spiel bietet dieses Modul einen relaxten Dub Sound!
Einfach in das Verzeichniss "Module" von PuzzelBOBS kopieren!

Aural Ilusion V. 3.0 Souce frei!
Der bisher unveröffentlichte Souce Code des leider nie erschienenden Sound
Sampler Aural Ilusion V 3.0 von "Blachford Technology" liegt nun zum
Download und zur freien weiterentwicklung bereit!
Nach Angaben von Nicolas Blachford darf dieser frei verwendet werden!
Der Source liegt unter http://blachford.info/blachtech/ zum Download!
Bei Intersse bitte mail an: nicholas@blachford.info«


»Amiga Arena - Vollversion "ArtPro 1.20b"
In Zusammenarbeit mit Frank Pagels ermöglicht die Amiga Arena die
Vollversion von "ArtPRO"!
Über den Grafik Konverter "ArtPRO"
ArtPRO bietet eine Anzahl von verschiedenen File formaten, wie
ILBM,GIF,TIFF, BMP,PCX.
Ausserdem können mittels Datatype weitere Formate geladen werden.
ArtPRO unterstützt weiterhin einige Raw Formate wie Chunky.
Bilder können als Bitplane, Chunky oder Truecolor als binary oder Source
gespeichert werden.
Dabei hat ArtPRO einen hoch flexible Sourcecodegenerator.
Ausserdem können Copperlisten und Sprites generiert werden.
ArtPRO bietet eine sehr schnelles runterrechnen von Bildern, und das in
ehr guter Qualität. Ausserdem einen Paletteoptimizer und ein Realtime Color
Bias der auch mit Truecolor Bildern funktioniert.

Weiter Entwicklung?
ArtPRO wurde zu 100% in Assembler entwickelt und wer ernsthaft daran
interressiert ist ArtPRO weiter zu entwickeln möchte sich bitte mit Frank
Pagels (copper@coplabs.org) in Verbindung setzten!
Es währe wirklich schön wenn sich jemand dafür finden würde!

Amiga Arena - Interview
Die Amiga Arena sprach mit Frank Pagels dem Entwickler von "ArtPro" über
die Entwicklungsgeschichte und wie es dazu kam!«


»Amiga Arena - Status Report
Liest hier (AmigaArenaStatus.txt) zur aktuellen Amiga Arena Situation!

Amiga Arena - Interview
Die Amiga Arena hat schon vor kurzem auf die Sourcen der Sampler Software
"Aural Illusion" hingewiesen die zur freien weiter Entwicklung frei gegeben
wurden von Nicholas Blachford.
Das mit Abstand umfangreichste Interview in der Amiga Arena Geschichte mit
vielen Interressanten Aussagen eines Ex-Amiga Entwicklers ist Online!
(Das Interview ist z.Zeit nur in Englisch Online!)

Amiga Arena - Interview II
Neben Stefan Blixth gehört auch Daniel Westerberg zu "OnyxSoft".
Programme wie MultiRen, Detris, oder DRemind erfreuen sich grosser
beliebtheit und auch Daniel Westerberg stellte sich den Fragen der Amiga
Arena!


               (·· Amiga Arena ··)

           .-----------------------.
           | S · T · A · T · U · S |
           `-----------------------'
                 [R·E·P·O·R·T]


Ende Januar gab Ich bekannt das die
"Amiga Arena" vorerst von mir eingestellt werden würde.
Bis zum jetzigen Zeitpunkt konnte ich aber noch einige Interviews
sowie eine weiter Shareware Vollversion ermöglichen!
Jetzt, wo ich keine weiteren Interviews,Sonderpreise
und Vollversion "in arbeit" habe möchte ich Euch einige Gründe
erläutern wieso Ich mich zu diesem Schritt entschlossen habe!
Zuerst möchte ich Euch mitteilen das bis Dato noch kein
Interresse seitens Entwickler bekundet wurde, um "ArtPro" sowie
"Aural Illusion" weiter zu entwickeln!
Mein Ziel war es mit der "Amiga Arena" zwischen Entwicklern und Anwendern
eine "Brücke" zu bilden um Vorurteile seitens der Anwender gegenüber
Registrationen (Weiterentwicklung etc.) abzubauen, Feedback zu ermöglichen,
auf Projekte aufmerksam zu machen sowie ein wenig mehr Einblick über die
Personen hinter den Programmen zu ermöglichen!
Für mich galt - jeder User der über die Amiga Arena auf ein Programm
aufmerksam gemacht werden könnte war ein Gewinn für den aktiven Amiga
Markt!
Nun mittlerweile sieht es so aus,das abgesehen davon es kaum noch Shareware
Software gibt,die Angebote nicht mehr angenommen werden!
Die "Sonderpreis Aktion" erwies sich nie als wirklich Erfolgreich und wenn
eine "Handvoll" neu Registrationen ermöglicht werden konnte war dies schon
als Grosser Erfolg zu bezeichnen!
Gründe dafür gibt es mitsicherheit viele,nur lassen sich die Zugriffszahlen
mit dem Endergebnis der Aktionen (Sonderpreise,Aufrufe,Feedback..)
auf kein für mich logiches Ergebniss bringen!
(Die Anwender scheint es ja zu geben!)
Somit macht es zur Zeit keinen Sinn diese Rubrik aufrecht zuerhalten!
(Angebot und Nachfrage!)

Die Vollversionen waren immer ein netter Nebeneffekt der sich auf der Suche
nach AKTIVEN Entwicklern ergab!
Es war nie mein Ziel Vollversionen zu ermöglichen denn jede Vollversion
bedeutete einen Entwickler weniger für den Amiga oder die Einstellung eines
Programmes!
Auch führten Aufrufe,Appelle etc. nicht auf offenen Ohren sodas das
Feedback weiterhin unerhört seitens der Anwender blieb!

Dies bezieht sich Selbstverständlich nur über die Erfahrung und mir
bekannten Werte der Amiga Arena,wobei ich aber von mir behaupten möchte das
sich ein grossteil der aktiven Free und Shareware Entwickler mit der Amiga
Arena immer wieder gut zusammengearbeitet hat!
Es gibt nur ganz wenige Ausnahmen die nicht bereit waren in welcher Form
auch immer mit mir eine Aktion durchzuführen!

Somit bin ich heute an einem Punkt angelangt wo es für mich immer schwerer
wird die Hoffnung auf weiter Entwicklung von Software oder die
fertigstellung eines Programmes zu unterstüzen!
(Ich habe dafür in den letzten Jahren zu viele Kontakte zu Entwicklern
gehabt deren Entwicklungen aufgegeben wurde oder Sie ganz den Amiga
verlassen haben!)
Es ist auf die dauer nicht motivierend keine Teilerfolge erzielen zu
können!
Zu viele Entwicklungen stehen still aufgrund von Demotivation,mangelnder
mitarbeit,feedback ect.!
Ein Sog gegen den Ich auch nicht mehr ankomme!

Ich weiss,nicht jeder Amiga Anwender ist ein Grafiker,Sounder oder
Programmierer aber Fakt ist das mittlerweile der Amiga grösstenteils aus
"Einzel Kämpfer" besteht und im laufe der Zeit angestrebte Ziele nicht mehr
erreicht werden!

Es gibt zu viele Gründe um Sie hier auch nur annähernd zu Ende zu bringen!
Ich hoffe Ihr könnt dies einwenig nachvollziehen!
Ich war sehr berührt über das viele Feedback was ich erhalten habe und
wünsche uns allen die bis heute dabei geblieben sind,das wir Amiga Freunde
wieder eine Gesunde und AKTIVE Anwendergemeinschaft werden!

Bis dahin Euer Olaf Köbnik - Amiga Arena


Nachtrag:
Ich möchte in Zukunft die Amiga Arena weiterführen
und werde nicht ganz die aktivitäten einstellen!

Vielen dank für Euer Verständniss!


 .... __ -- (c) Amiga Arena 16.02.2002 -- __ ....«


»Amiga Arena - Interview Update!
Das Interview mit Nicholas Blachford ("Aural Illusion") ist nun auch in
Deutsch Online!
Besonderen Dank an Christain Busse für seine Arbeit!«


»Amiga Arena - Interview mit "Thilo Köhler"
In kürze erscheint das letzte Update zu "Samplemanager",dem
Audiobearbeitungsprogramm    mit einmaligen Features wie dem "Autotune
Effekt".
Doch mit "HDRec" ,einen MIDI/Audio Sequencer ähnlich wie Cubase befindet
sich schon der Nachfolger von "Samplemanager" in Entwicklung und es dürfte
bald mit der ersten Beta Version zu rechnen sein!
Thilo Köhler sprach mit der Amiga Arena ausführlich über sein neues
Programm "HDRec" sowie dem "Samplemanager"!

Amiga Arena - Interview mit Nicholas Blachford Update II!
Wie mir  Nicholas Blachford mitteilte war er sehr darüber erstaunt das in
einer Woche über 200 Downloads  von "Aural Illusion" gedownloadet wurden -
mehr als er in 5 Jahren verkauft hat!
Die Downloads erfolgten aus 34 verschiedenen Ländern!
Nachwort
Diese Ausage brauche ich wohl nicht mehr zu Kommentieren!
Das Verhältniss Downloadzahlen zu Verkaufszahlen (Registrationen) trifft
leider auch heute genau so zu!«


»Amiga Arena - Sonderpreis Aktion News
Bis zum 28.02.2002 können noch folgende Programme zum Sonderpreis
registriert werden!

- GeoWorld, das Erdkundeprogramm!
- PhotoAlbum/CyberShow, die Bildverwaltung!
- DocDatatypes (für MSWord,Wordperfect..)
- Siteway, Site und Content managment
- AMPlifier, Hardware basierender Dekoder

Zum 01.03.2002 stellt die Amiga Arena die Shareware "Sonderpreis Aktion"
ein.

Amiga Arena - Interview mit "Marcin Kielesinski"
Marcin Kielesinski hat mit "Sherman Blanker" einen weiteren ausgefallenen
PC Blanker für den Amiga portiert!
Ein kleines Interview  über die Zukunft seiner Programme und über "Sherman
Blanker" ist Online!«


»Amiga Arena - Interview mit "Gareth Griffiths"
Wer seine MP3 Sammlung schnell und Plattform übergreifend aufgelistet haben
möchte sollte sich einmal das Programm "MP3-2-HTML" von "Gareth Griffiths"
ansehen!
Die gesamten ID3 Informationen werden in einer HTML Liste dargestellt!
"MP3-2-HTML" bietet dazu noch weitere Features und ist wirklich ein sehr
nützliches Tool!
Die Amiga Arena sprach mit dem recht Jungen Entwickler "Gareth Griffiths"
der nebenbei noch an einem PD Spiel namens "Shoot Out" arbeitet!
Wie wichtig Feedback ist und das Ihr regelrecht "Einfluss" auf die weiter
Entwicklung von Software haben könnt,spiegelt auch dieses Interview einmal
mehr wieder!«


»Amiga Arena - Interview mit "Volker Grabbe"
Der Mangel an Kommerzieller Software und die dadurch entstandenen Lücken
sind in den letzten Jahren durch Free und Shareware Programme gerade im
Anwenderbereich gut geschlossen worden!
Allerdings vermissen die meisten Amiga User einen Browser der "up to Date"
ist und ein Office Paket    was auch den Daten austausch zu anderen
Plattformen wirklich ermöglicht.
Gerade im Bereich "Textverarbeitung" ist der Amiga nicht mehr Zeitgemäss!
Die Amiga Arena sprach mit Volker Grabbe der das Projekt "OpenOffice" ins
Leben gerufen hat und sich zum Ziel gesetzt hat,diesen missstand auf dem
Amiga mit der Open Source Variante von Suns "StarOffice 6" zu beenden!
Da Volker Grabbe solch ein Projekt nicht alleine umsetzten kann,hat er ein
kleines Team gebildet und ist auch weiterhin auf die mithilfe der Amiga
Gemeinde angewiesen die "OpenOffice" unterstüzen möchten.
Jeder der an diesem Projekt teilnehmen möchte,möge sich bitte mit Volker
Grabbe  (openoffice@vgrabbe.de)  in Verbindung setzten für weitere
Informationen.
Liebe Amiga User,
es währe schön wenn sich zahlreiche Entwickler finden
lassen die dieses Ziel umsetzten!
Es ist mir unbegreiflich wie User sich untereinander bekämpfen!
Wir alle haben einen nutzen von solchen Projekten und sollten uns Glücklich
schätzen das es im Amiga Sektor noch Enthusiasten gibt die Ihre Freizeit
für uns und dem Amiga "opfern"!
Ich habe bewust hier keine vergleichbaren Produkte erwähnt,da es mir hier
in erster Linie um die Aufmerksamkeit für OpenOffice geht!«


»Amiga Arena - Interview mit "Costel Mincea"
Vor wenigen Tagen gab das Unternehmen "Remedy Systems" bekannt das neue
Software Produkte auch für den Amiga entwickelt werden.
Mit dem Programm "AmiDynDNS" befindet sich zur Zeit ein CLI Client für die
Services von DynDNS.org. in Entwicklung!
Die Amiga Arena sprach mit "Costel Mincea" über die Zukunft und über
weitere mögliche Entwicklungen für den Amiga.«

@ENDNODE

@NODE "Diverses5" "Diverse Amiga-News"
@TOC "MAIN"

5. Neuigkeiten von Airsoft Softwair

Airsoft Softwair (http://www.airsoftsoftwair.de) informiert:

»Endlich ist es wieder soweit! Eine neue Version von Akiko, dem CD32
und CDTV Emulator für Microsoft(r) Windows(r) Systeme, steht zum
Download auf der Airsoft Softwair Homepage (http://www.airsoftsoftwair.de/)
bereit.
Bei dieser Version 1.2 handelt es sich um ein großes Update, so ist der
Emulator jetzt ungefähr 20 Prozent schneller, unterstützt die Emulation des
statischen Speicherblocks des CD32 inkl. einem NVRam-Editor, der es erlaubt
Spielstände zu importieren und zu exportieren sowie zu modifizieren
(patchen). Beispiele dafür gibt es in der Dokumentation. Außerdem
bietet Akiko nun eine echte Joypad-Emulation, d.h. der Benutzer kann jedem
Knopf auf dem CD32-Joypad eine Taste bzw. einen PC-Joystickknopf zuweisen.
Außerdem unterstützt Akiko jetzt auch die Sprachemulation vom CD32 & CDTV,
so dass viele Spiele jetzt einfach in der eingestellten Sprache erscheinen.
Schließlich gab es einige Fehlerbeseitigungen und es wurden auch einige
Patches verbessert sowie die Dokumentation ausgebaut. Wer sich noch immer
nicht für Akiko registriert hat (Kostenpunkt: Nur 15 Euro!!), dem noch ein
letzter Anreiz: In der aktuellen Demoversion ist jetzt auch Defender Of The
Crown 2 CDTV spielbar (nicht vergessen die Sprache in den Akiko
Settings auf deutsch zu stellen, um in den vollen Genuss zu kommen).
Akiko benötigt übrigens nicht die sogenannten Extended Roms von
CD32 und CDTV sondern gibt sich mit den Kickstarts 1.3 und 3.1 zufrieden.
Registrierte Benutzer können sich mit dem Betreff "subscribe" an
akiko@airsoftsoftwair.de wenden, um die aktuelle Vollversion
von Akiko zugeschickt zu bekommen (wer sich einmal anmeldet, erhält
immer die neueste Version, sonst nix, auch keine Produkthinweise).
Wer sich noch nicht registriert hat, holt sich am besten schnell
die Demoversion von Akiko.«


»Auf der Airsoft Softwair Homepage (http://www.airsoftsoftwair.de/)
wurde soeben der Akiko 1.3 veröffentlicht.
Mit dieser neuen Version wird nun erstmals Unterstützung für die
sogenannten "extended roms" vom CD32 und CDTV geboten, d.h. im Klartext,
dass Akiko nun nicht nur die tollen Bootanimationen von beiden Konsolen
anzeigen kann, sondern auch dass die im ROM eingebauten Anwendungen
funktionieren, wie z.B. die Audio CD Spieler in beiden ROMs oder auch
der NVRam Editor vom CD32 bzw. das Einstellungsprogramm vom CDTV oder
das Sprachauswahlmenü vom CD32. Auf der Airsoft Softwair Homepage
stehen im Akiko-Produktbereich
(http://phobos.spaceports.com/~sfa/de/prod_akiko.html)
einige Screenshots von diesen ROM-spezifischen Funktionen bereit. Wer noch
kein ROM Image aber ein CD32 oder CDTV besitzt, kann mittels des ebenfalls
gerade bereitgestellten Werkzeugs RipROM diesen Speicherbereich des Amigas
als Datei sichern lassen, um diese Datei dann mit Akiko zu verwenden.
Außerdem wurde in Akiko 1.3 die Emulation etwas verbessert.«


»Die Airsoft Softwair Homepage <http://www.airsoftsoftwair.de/> wurde
im Produktbereich stark erweitert. Es stehen nun ausführliche Informationen
zu allen größeren Programmen von Airsoft Softwair dort zur Verfügung.
Außerdem können jetzt alle Shareware-Programme von Airsoft Softwair
auch per Kreditkarte bestellt werden.«


»Auf der Airsoft Softwair Homepage <http://www.airsoftsoftwair.de/>
wurde soeben Version 1.4 des Windows CD32 & CDTV Emulators Akiko
veröffentlicht.
Diese Version kann jetzt erstmals alle CD32 & CDTV Spiele starten.
Akiko benutzt hierzu eine sehr generelle Prozedur, um beste Kompatibilität
zu gewährleisten. Im Praxistest liefen über 90 Prozent der getesteten
Spiele mit dieser Bootprozedur. Außerdem wurden in dieser Version noch
einige von  Akiko-Benutzern gewünschte Verbesserungen verwirklicht. Akiko
1.4 steht ab sofort auf der Airsoft Softwair Homepage
<http://www.airsoftsoftwair.de/> zum Download bereit.«

@ENDNODE

@NODE "Diverses6" "Diverse Amiga-News"
@TOC "MAIN"

6. Kurzmeldungen (von Oliver Tacke)

---------------------------------------------------------------------------
Software AmigaOS 68k (kommerziell)
---------------------------------------------------------------------------

Ein Update des "MMKeyboard"-Archivs (V1.20) ist erschienen, das neben
internen Verbesserungen auch Euro-kompatible Win95-Keymaps enthält.
[http://ftp.uni-paderborn.de/aminet/aminet/hard/hack/MMKeyboard.lha]

Für das DTP-Programm "PageStream" ist ein Update auf Version 4.1.3
erschienen.
[http://www.grasshopperllc.com/downloads.html]

Für die Drucker-Software "TurboPrint" ist ein Update auf Version 7.30
erschienen. Es umfasst Treiber für die Drucker Canon S500, Canon 630,
Canon 6300, HP-Deskjet 92x, HP-Deskjet 94x, HP-Deskjet 96x, Epson Stylus
C60, Epson Stylus C70, Epson Stylus C80 und Epson Stylus Photo 810.
http://www.irseesoft.de]

Für alle PCI-Bus-Board-Modelle der "Mediator"-Reihe, darunter auch die
neuen Modelle für Amiga 3000 und Amiga 4000T sind Warp3D-Treiber
erhältlich.
Weiterhin wurden ein Update der Treibersoftware MediatorUP auf Version
2.9 und ein Update der Software Mediator MultimediaUP auf Version 1.13
veröffentlicht.
[http://www.elbox.com]

Für Besitzer des "G-Rex"-PCI-Bus-Boards ist eine spezielle neue Version
der Grafikkartensoftware CyberGraphX erschienen, die die Versionsnummer
4.3 Beta3 trägt.
[http://www.vgr.com/cybergfx]


---------------------------------------------------------------------------
Software AmigaOS 68k (nicht kommerziell)
---------------------------------------------------------------------------

Die Programmiersprache "AmiBlitz" ist in Version 2.24 erschienen.
[http://blitz2000.gazchap.com]

Für den Disk-To-HD-Installer "WHDLoad" sind auch in diesem Monat zahlreiche
neue Module erschienen. Es ist nun z.B. möglich, "FIFA Soccer",
"Double Dragon 2" und viele andere Spiele auf Festplatte zu installieren.
[http://www.whdload.de]

Der AOL-Messenger-Clone "AmigAIM" ist in einer neuen Betaversion mit den
Nummer 0.9441 erschienen.
[http://amigaim.missingpiece.com]

Das IRC-Programm "AmIRC ist ebenfalls in einer neuen Betaversion (V3.5.23)
für registrierte Nutzer herausgegeben worden.
[http://www.vapor.com]

Der Virenscanner "Safe", der sich stetig in Entwicklung befindet, steht in
Version 17.8 zum Download bereit.
[http://home4.inet.tele.dk/vht-dk/amiga/safe/safe.htm]

Auch der Virenscanner "Watchdog", der im Hintergrund laufen kann und dort
regelmäßig nach Viren sucht, wurde verbessert. Die neue Versionsnummer
lautet 2.7.
[http://home4.inet.tele.dk/vht-dk/amiga/]

Martin Mason Merz hat viele seiner ausgezeichneten GlowIcon-Sets
aktualisiert, darunter zum Beispiel VoyagerMI und AWebMI. Desweiteren gibt
es auch einige neue Sets.
[http://mason.home.beu.t-online.de/]

Das Mail-Programm "SimpleMail" ist weiterentwickelt worden und trägt nun
die Versionsnummer 0.15. Die Änderungen sind hauptsächlich interner Natur.
[http://www.simplemail.de.vu]

Dem Malprogramm "Perfect Paint" ist ein Update auf Version 2.81
widerfahren. Neben Fehlerbereinigungen wurden diverse Dinge hinsichtlich
Geschwindigkeit und Nutzbarkeit verbessert.
[http://gothic.fr.free.fr/amiga]

Das Soundprogramm "Amplify" ist in der neuen Version 1.4a erschienen und
bietet nun auch mp3-Import.
[http://homepages.compuserve.de/bwoern]

Für das Programm "GeoWorld" ist Version 1.6 des Developer-Tools erhältlich,
mit dem man Daten selbst ändern und erweitern kann.
[http://home.arcor.de/geoworld/GeoWorld.html]

Version 1.37 des vielfach genutzten Programms "MCP" wurde veröffentlicht.
[http://mcp.dgroppe.de]

Der Screen/Window-Grabber "sgrab" ist in Version 1.19a erschienen.
[http://home.wtal.de/stephanr/downloads/sgrab.lha]

Der Systemmonitor "Scout", der auf keinem System fehlen sollte, ist in
Version 2.15 erschienen.
[http://de.aminet.net/pub/aminet/util/moni/Scout.lha]

Die Börsensoftware "Bonds" ist in Version 1.68 erhältlich.
[http://www.programmed-excellence.de/]

"MagicMenu" ist in Version 2.34 erschienen und bietet nun auch direkte
Amithlon-Unterstützung.
[http://www.magicmenu.de]

Der Video-Player "Frogger" liegt in Version 1.69rc vor.
[http://frogger.rules.pl]


---------------------------------------------------------------------------
Software AmigaOS PPC (nicht kommerziell)
---------------------------------------------------------------------------

Die Version 1.1 des Programms "PNGTool", das Bilder ins PNG-Format
konvertieren kann, unterstützt nun auch den PPC über WarpUP.
[http://home.wtal.de/stephanr/]

Der Screen/Window-Grabber "sgrab" ist in Version 1.19a erschienen. Ein
Fehler im PPC-Modul wurde beseitigt.
[http://home.wtal.de/stephanr/downloads/sgrab.lha]

Der Video-Player "SoftCinema" wurde in Version 0.17 veröffentlicht.
[http://amiga.pl/softcinema/]

Auch der Video-Player "Frogger" ist aktualisiert worden und liegt nun in
Version 1.69rc vor.
[http://frogger.rules.pl]


---------------------------------------------------------------------------
Software MorphOS (kommerziell)
---------------------------------------------------------------------------

Eine Demoversion des Textverarbeitung-Pakets "Papyrus" ist für Mai 2002
angekündigt worden.
[http://www.titan-computer.com/ami/papyrus/]


---------------------------------------------------------------------------
Hardware
---------------------------------------------------------------------------

Es sind zwei neue Versionen des PCI-Bus-Boards "Mediator" erschienen,
nämlich eine für den Amiga 3000D und eine für Amiga 3000T bzw. 4000T. Die
Boards stellen je 5 PCI-Slots und 6 bzw. 4 ZorroII/III-Slots bereit.
[http://www.elbox.com]

Eine erste lauffähige Version des AmigaOne, dessen Spezifikationen
überarbeitet wurden, ist auf der alt.WOA in Huddersfield gezeigt worden.
[http://www.eyetech.co.uk]


---------------------------------------------------------------------------
Diverses
---------------------------------------------------------------------------

Das erste Update des AmigaOS-XL-Pakets ist erschienen. Es behebt zahlreiche
Fehler; weiterhin wurde die Soundunterstützung von Amithlon verbessert.
[http://amigaosxl.haage-partner.de]

Volker Grabbe möchte gern OpenOffice auf den Amiga portieren und sucht
verständlicherweise (der Sourcecode ist sehr umfangreich) Programmierer,
die ihn unterstützen.
[http://www.vgrabbe.de/OpenOffice.html]

Für MorphOS sind Programmierrichtlinien veröffentlicht worden; sie können
u.a. im PDF-Format heruntergeladen werden.
[http://www.morphos.de]

Oliver Tacke <oliver@aakt.de> - schickt mir eure News!

@ENDNODE

@NODE "Schluss" "Abschließend"
@TOC "MAIN"

Abschließend
------------

Wer mit den Wölfen heult... (von Christian Aichinger)

So kurz der vergangene Monat auch war, so viele und in der Tat umwerfende
Neuigkeiten gab es schon lange nicht mehr. Neben der Präsentation des
ersten lauffähigen Prototypen des AmigaONE auf der alt-WOA in Huddersfield
[1], der Lüftung des Geheimnisses um den sagenumwobenen "Milliarden-
Dollar"-Partner AMIGAs - nämlich der hauptsächlich unter Handybesitzern
bekannten Firma Nokia -, dürfte vor allem eine Meldung für viele Amiga-User
ein Grund für kalte Schweißausbrüche, Atemnot, Angstattacken und natürlich
die obligatorischen Gerüchte und Spekulationen gewesen sein: Gary Peake
(bei AMIGA, Inc. als Direktor für Entwickler-Support angestellt) bestätigte
in der öffentlich zugänglichen Mailingliste "AMIGEN", daß der weltgrößte
und auf Grund seiner Geschäftspraktiken stark in der Kritik stehende
Softwarehersteller Microsoft, AMIGA Inc. gebeten hat, AmigaDE während der
Embedded System Conference (ESC; [2]) auf ihrem Stand zu präsentieren.

Nachdem zumindest ich den ersten Schreck mental verdaut hatte, stellt sich
mir nur eine Frage, die ich mir bis dato noch nicht befriedigend
beantworten konnte: Was will Microsoft mit AmigaDE?


Erklärungsversuche

Da sich AMIGA, Inc. selbst als Content Provider für PDA und Handheld-
Computer bezeichnet, wäre es nur logisch, daß Microsoft versucht, den
"Content", also das Softwareangebot, für ihr eigenes PDA-Betriebssystem
(genannt "PocketPC 2002" - der Nachfolger von WinCE), mit Produkten aus der
Software-Schmiede AMIGAs aufzubessern - zumal AMIGA Inc. selbst von Anfang
an auch WinCE als mögliches Hostsystem für AmigaDE betrachtet hat. Schaut
man sich aber die aktuelle Softwarepalette AMIGAs an, kann dieses Argument
noch nicht so richtig überzeugen. Denn für Desktop-Spiele á la Series Zero
kann Microsoft immer noch selbst mit Softwarepaketen aus dem eigenen
Sortiment sorgen. Falls es sich also um ein Produkt handelt, das Microsoft
interessiert und sogar dazu bewogen hat, AmigaDE auf dem eigenen Messestand
zu präsentieren, könnte es sich dabei um ein bisher unveröffentlichtes oder
allgemein völlig unterschätztes Projekt handeln. Denn das Produkt eines
Fremdherstellers müßte schon wesentliche Vorteile mit sich bringen, um
überhaupt das Interesse Microsofts daran zu wecken - für Amiga-User ein
Grund zur Freude.


Paranoid?

Betrachtet man sich allerdings Microsofts Ambitionen, mit .NET eine eigene
hardwareunabhängige Laufzeitumgebung zu etablieren, sollte jeder
informierte Amiga-Fan sofort mißtrauisch werden. Zur Erklärung: Microsofts
.NET stellt eine Art virtuelle CPU dar, die mittels der Intermediate
Language (kurz IL; eine Art Assembler für diese virtuelle CPU) betrieben
wird. Microsoft stellt mehrere Compiler zur Verfügung (das gesamte .NET-SDK
läßt sich sogar kostenlos von der Homepage Microsofts downloaden), die den
Quellcode eines jetzt schon existenten Programms in den neuen Binärcode
(also IL) kompilieren können. Ältere Programme, die z.B. in C++ oder
VisualBasic verfaßt wurden, können nach Anpassung an die neue
Laufzeitumgebung und mit dem entsprechenden Compiler auf .NET portiert und
damit theoretisch auf sämtlichen Plattformen - sei es PC, PDA, Mikrowelle
oder Internet - lauffähig werden. Die Parallelen zu AmigaDE sind
offensichtlich, stellt doch Elate/AmigaDE ein vergleichbares Projekt dar.
Ergo stehen Microsoft und AMIGA in direkter Konkurrenz zueinander, und wer
der Anwärter mit den besseren Chancen für die Etablierung eines neuen
Standards darstellt, muß nicht explizit erwähnt werden. Interessant wird
aber vor allem der Gesichtspunkt, daß auch Sun mit einem weiteren
vergleichbaren Projekt um den zukünftigen plattformunabhängigen Standard
einer Laufzeitumgebung feilscht. SunONE (Sun Open Net Environment) ähnelt
den beiden bereits genannten Lösungen, außer, daß anstatt eines neuen
Zwischencodes das altbewährte Java zum Einsatz kommen soll.
Da auch Sun schon in diversen Executive Updates von Bill McEwen Erwähnung
gefunden hat, könnte man meinen, daß AMIGA mit den Wölfen heult. Ob
allerdings genug Platz für einen Goldfisch im Haifischbecken ist, wird sich
erst in den kommenden Monaten (wenn nicht sogar erst Jahren) beantworten
lassen.


Der Glanz der Großen

Daß es zumindest im Moment kein Fehler von AMIGA sein kann, sich mit
Microsoft einzulassen, sollte andererseits auch klar sein. Sollte es
tatsächlich gelingen, einen gewinnbringenden Vertrag mit Microsoft oder
einem ihrer Partner einzugehen, wären AMIGAs Visionen wieder ein Stück mehr
der Realität näher gekommen. Denn die Aussichten auf neue Verträge und
allein schon die Referenz Microsofts könnte AmigaDE so manche Tür im
hartumkämpften Markt eröffnen und damit den Finanzen AMIGAs nur zu Gute
kommen. Dass sogar AmigaOS 4 und seine Nachfolger von einer finanziell
gesunden Firma ausschließlich profitieren können, scheinen viele Amiga-User
aber zu vergessen (was auch kein Wunder nach diesen Schock sein dürfte ;-))
und schreien schon jetzt "Boykott", drohen mit dem Wechsel des Systems oder
denunzieren AMIGA in aller Öffentlichkeit. Sicher, einen bitteren
Beigeschmack hat diese Meldung, doch sollten vor allem die Vorteile einer
Zusammenarbeit gesehen werden: AMIGA könnte neue Geschäftspartner gewinnen,
neue Verträge abschließen, dadurch ihre Finanzen restaurieren und einer
Verbreitung des AmigaDE würde dies letztendlich nur nützen. Ich finde, das
hört sich alles gar nicht so schlecht an und sollte Baldrian für die
Hitzköpfe unter den Amiga-Usern sein.


Gerüchteküche

Im den Disziplinen "Gerüchte streuen" und "Computerphilosophie" sind
Amiga-User die Größten. Eine gute Portion Fanatismus, Dickköpfigkeit und
Tratsch-Tante steckt wohl in fast jedem Amiga-Fan (ich schließe mich
hierbei nicht aus ;-)). Dass eine alleinige Erwähnung der Firma Microsoft
von einem Mitarbeiter AMIGAs dieselben Folgen in der Community hat, wie ein
Fuchs im Hühnerstall, müßte sogar AMIGA, Inc. inzwischen zu Ohren gekommen
sein. Womit ich mal wieder beim Feingefühl der Informationsweitergabe
AMIGAs wäre: Es kann einfach nicht sein, daß eine solche Information von
einem Mitarbeiter des Unternehmens, der zudem nichts mit der
Öffentlichkeitsarbeit zu tun hat, kommentarlos in einem Internet-Forum
verbreitet wird. Dass die Pressearbeit bisher ein immenser Spagat für
AMIGA, Inc. war, weiß jeder, der sich schon einmal über den Sinngehalt
einiger Executive Updates gewundert hat. Zwischen Einhaltung der
Verschwiegenheit über firmeninterne Verhandlungen mit etwaigen
Vertragspartnern und der Befriedigung der Neugier der Amiga-Community gab
es bisher immer schwere Defizite, die - und das zum Teil mit Recht - mit
heftiger Kritik am Pressemanagement AMIGAs beantwortet wurden.

Dass aufgrund solch unqualifizierten Verhaltens Gerüchte und Halbwahrheiten
die Runde machen und sich auch nicht besonders gut auf das Image AMIGAs
auswirken, sollte den Herrschaften in Snoqualmie allmählich auffallen. So
wurden sogar schon völlig unbegründete Gerüchte laut, daß AMIGA von
Microsoft übernommen werden soll. Mit der höchst interessanten Frage, wie
die Zusammenarbeit zwischen AMIGA und Microsoft aussehen könnte bzw. ob es
überhaupt eine Zusammenarbeit gibt, läßt AMIGA die Community mal wieder im
Regen stehen und schadet sich damit selbst. Dass das Unternehmen unbedingt
an der eigenen Öffentlichkeitsarbeit feilen muß, wird an dieser Stelle mit
Sicherheit nicht zum letzten Mal erwähnt sein, obwohl ich die Hoffnung
nicht aufgebe ;-).


Summa summarum

Die nächsten Monate werden spannend. Spätestens am 16. März - denn das ist
der letzte Tag der diesjährigen ESC - dürfte sich das Geheimnis um die
Beziehung (inwieweit man überhaupt davon sprechen kann, wird sich zeigen)
zwischen AMIGA, Inc. und Microsoft lüften. Auch die neuen Amiga-Modelle und
das generalüberholte AmigaOS stehen laut Aussage ihrer Hersteller kurz vor
der Veröffentlichung. Dieser Frühling wird heiß - für Amiga-User auf jeden
Fall.

[1] http://www.alt-woa.org
[2] http://www.esconline.com


Bis zum nächsten Mal,

Euer

Christian Aichinger <christian@aakt.de>

@ENDNODE

<HTML>
<HEAD><TITLE>Workshops / Hintergrundberichte</TITLE></HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000AA" ALINK="#000066" VLINK="#000066">
<CENTER>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=1><TR><TD COLSPAN=2 VALIGN=TOP ALIGN=LEFT>
  <IMG SRC="../menu/title_amiga.gif" WIDTH=58 HEIGHT=20 BORDER=0>
</TD></TR>
<TR><TD VALIGN=TOP ALIGN=LEFT>
  <IMG SRC="../menu/title_aktuell.gif" WIDTH=9 HEIGHT=60 BORDER=0>
</TD><TD VALIGN=TOP ALIGN=CENTER>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=1 BGCOLOR="#000000"><TR>
<TD ROWSPAN=3 VALIGN=TOP>
<IMG SRC="../menu/empty.gif" BORDER=0 WIDTH=19 HEIGHT=15>
</TD><TD ROWSPAN=3 VALIGN=TOP>
<A HREF="../index.html"><IMG SRC="../menu/hauptseite.gif" BORDER=0 WIDTH=62 HEIGHT=15></A>
</TD><TD ROWSPAN=3 VALIGN=TOP>
<A HREF="0501.html"><IMG SRC="../menu/links.gif" BORDER=0 WIDTH=15 HEIGHT=15></A>
</TD><TD ROWSPAN=3 VALIGN=TOP>
<A HREF="0600.html"><IMG SRC="../menu/rechts.gif" BORDER=0 WIDTH=15 HEIGHT=15></A>
</TD><TD ROWSPAN=3>
<IMG SRC="../menu/empty.gif" BORDER=0 WIDTH=19 HEIGHT=15>
</TD><TD>
<A HREF="index.html"><IMG SRC="../menu/inhalt.gif" BORDER=0 WIDTH=37 HEIGHT=15></A>
</TD><TD>
<A HREF="0100.html"><IMG SRC="../menu/vorwort.gif" BORDER=0 WIDTH=47 HEIGHT=15></A>
</TD><TD>
<A HREF="0200.html"><IMG SRC="../menu/intern.gif" BORDER=0 WIDTH=37 HEIGHT=15></A>
</TD><TD>
<A HREF="0300.html"><IMG SRC="../menu/gewinnspiel.gif" BORDER=0 WIDTH=70 HEIGHT=15></A>
</TD><TD>
<A HREF="0400.html"><IMG SRC="../menu/forum.gif" BORDER=0 WIDTH=37 HEIGHT=15></A>
</TD><TD ROWSPAN=3 VALIGN=TOP>
<IMG SRC="../menu/empty.gif" BORDER=0 WIDTH=19 HEIGHT=15>
</TD></TR>

<TR><TD>
<A HREF="0500.html"><IMG SRC="../menu/workshops.gif" BORDER=0 WIDTH=62 HEIGHT=15></A>
</TD><TD>
<A HREF="0600.html"><IMG SRC="../menu/testberichte.gif" BORDER=0 WIDTH=70 HEIGHT=15></A>
</TD><TD>
<A HREF="0700.html"><IMG SRC="../menu/spieleteil.gif" BORDER=0 WIDTH=55 HEIGHT=15></A>
</TD><TD>
<A HREF="0800.html"><IMG SRC="../menu/amigainc.gif" BORDER=0 WIDTH=87 HEIGHT=15></A>
</TD><TD>
<A HREF="0900.html"><IMG SRC="../menu/poweruptodate.gif" BORDER=0 WIDTH=90 HEIGHT=15></A>
</TD>
</TR><TR>
<TD>
<A HREF="1000.html"><IMG SRC="../menu/produktankuendigungen.gif" BORDER=0 WIDTH=125 HEIGHT=15></A>
</TD><TD>
<A HREF="1100.html"><IMG SRC="../menu/diverses.gif" BORDER=0 WIDTH=50 HEIGHT=15></A>
</TD><TD>
<A HREF="1200.html"><IMG SRC="../menu/kurzmeldungen.gif" BORDER=0 WIDTH=85 HEIGHT=15></A>
</TD><TD>
<A HREF="1300.html"><IMG SRC="../menu/geruechte.gif" BORDER=0 WIDTH=52 HEIGHT=15></A>
</TD><TD>
<A HREF="1400.html"><IMG SRC="../menu/abschliessend.gif" BORDER=0 WIDTH=75 HEIGHT=15></A>
</TD></TR>
<TR><TD BGCOLOR="#EEEEEE" COLSPAN=11>
<H2 ALIGN=CENTER>Workshops / Hintergrundberichte</H2>
</TD></TR>
</TABLE>

</TD></TR>
</TABLE>
</CENTER>

<P>

<H2>2. Programmierung des PowerPC mit WarpOS (von Steffen H&auml;user)</H2>

<P>
»Seit dem Erscheinen der PowerUP-Karten erschienen auf dem Aminet bereits
einige Programme, die den PPC unterst&uuml;tzen. Es gibt jedoch zahlreiche
Autoren, die ihre Programme noch nicht mit PPC-Support versehen, obwohl
dies durch die Verwendung von StormC und WarpOS eigentlich sehr einfach
ist. Dieser Artikel beschreibt, wie man ein Programm mit PPC-Support
versieht.
<P>
Dabei w&auml;re es sogar durchaus denkbar, ein Programm jetzt f&uuml;r den 68k zu
entwickeln - da weder PPC-Karte noch PPC-Compiler verf&uuml;gbar -, jedoch mit
Blick auf eine leichte PPC-Portierbarkeit, und dann sp&auml;ter die wenigen noch
n&ouml;tigen Schritte, um eine PPC-Version zu generieren.
Dieses Vorgehen d&uuml;rfte vor allem f&uuml;r Spiele-Entwickler interessant sein. Im
Zweifelsfall, falls ein Rechner gesucht wird, auf dem ein bereits
fertiggestelltes PPC-Programm compiliert werden kann, ohne gleich eine PPC-
Karte kaufen zu m&uuml;ssen, stehe ich auch gerne zum Recompilieren zur
Verf&uuml;gung (obwohl es sicher praktikabler w&auml;re, einen eigenen Rechner hier
zu haben). Das Programmtesting kann im &Uuml;brigen prinzipiell auch mit der
68k-Version erfolgen, da eigentlich keine gr&ouml;&szlig;eren &Auml;nderungen erforderlich
sind.
<P>
Prinzipiell erfolgt die Anpassung in folgenden Phasen (um die Entwicklung
zu vereinfachen, ist empfohlen, dies schon w&auml;hrend der Entwicklung der 68k-
Version durchzuf&uuml;hren):
<P>
<PRE>
A) Umschreiben aller 68k-Assembler-Teile nach C oder C++ oder PPC-ASM
B) ANSI/StormC-Anpassung
C) PPC-Anpassung
D) Kontextswitch-Optimierung
E) Weitere Anpassung
</PRE>
<P>
Im Gegensatz zu einer PPC-Anpassung auf ppc.library hat man bei WarpOS nach
Schritt A) eigentlich schon fast "gewonnen", die letztlichen PPC-
Anpassungen sind (zumindest bei Sourcen ohne Assembler-Optimierung)
minimal. Ich verzichte darauf, auf Teil A) einzugehen, wer unbedingt
Assembler-Projekte auf PPC portieren m&ouml;chte, sollte E-Mail-Kontakt mit mir
aufnehmen, da es evtl. ein besser geeignetes Verfahren der Portierung als
das hier beschriebene gibt (und zudem vor einer Riesenarbeit gepr&uuml;ft werden
sollte, ob es sich &uuml;berhaupt lohnt).
<P>
Ich empfehle, zumindest Schritt B) bereits w&auml;hrend der Entwicklung der 68k-
Version vorzunehmen, um sp&auml;ter nicht mehr durch den ganzen Source
durchgehen zu m&uuml;ssen.
<P>
<B>B. StormC - ein strenger ANSI-Compiler</B>
<P>
Der wildeste Part bei der Anpassung eines PPC-Programms ist nicht etwa die
Anpassung von 68k auf PPC, sondern von SAS/C oder GNU C auf StormC.
<P>
StormC ist ein strenger ANSI-Compiler, daher sind Standard-C-Funktionen,
die im ANSI-Standard nicht verf&uuml;gbar sind, nicht zul&auml;ssig. Einige der
Funktionen k&ouml;nnen &uuml;ber die offiziell noch nicht releaste UnixLib emuliert
werden.
<P>
Die Liste der nicht erlaubten SAS/C-Funktionen w&auml;re (keine dieser
Funktionen ist im ANSI-Standard enthalten...):
<P>
<PRE>astcsma    isascii    iscsym     iscsymf    toascii    scdir      stcpm
stcpma     stcsma     stccpy     stpcpy     stcis      stcisn     stclen
stpbrk     stpchr     stpchrn    strcmpi    strnset
strset     stcarg     stpsym     stptok     stpblk     strbpl     strdup
strins     strmid     stcd_i     stcd_l     ecvt       fcvt       gcvt
stch_i     stch_l     stci_d     stci_h     stci_o     stcl_d     stcl_h
stcl_o     stco_i     stco_l     stcu_d     stcul_d    toascii    stpdate
stptime    __datecvt  __timecvt  utpack     utunpk     cot        iabs
max        min        pow2       __emit     getreg     putreg     geta
isatty     ovlyMgr    dqsort     fqsort     lqsort     sqsort     strsrt
tqsort     drand48    erand48    jrand8     lcong48    lrand48    mrand8
nrand48    seed48     srand48    __autoopenfail        chkabort   Chk_Abort
_CXBRK     __exit     onexit     _XCEXIT    forkl      forkv      onbreak
wait       waitm      bldmem     rstmem     sizmem     chkml      getmem
getml      halloc     lsbrk      sbrk       _MemCleanup rbrk      rlsmem
rlsml      memccpy    movmem     repmem     setmem     swmem      except
__matherr  poserr     datecmp    timer      __tzset    getch      fgetchar
fputchar   _dread     _dwrite    read       write      clrerr     close
_dclose    fcloseall  creat      _dcreat    _dcreatx   fdopen     fileno
fmode      iomode     open       _dopen     flushall   mkstemp    mktemp
setnbf     _dseek     lseek      tell       access     chkufb     chmod
fstat      getfa      getft      stat       stcgfe     stcgfn     stcgfp
strmfe     strmfn     strmfp     strsfn     unlink     argopt     chgclk
dos_packet getclk     getasn     getdfs     putenv     rawcon    stackavail
stacksize  stackused  chdir      closedir   dfind      dnext      findpath
getcd      getcwd     getfnl     getpath    mkdir      opendir    readdir
rmdir      seekdir    rewinddir  telldir    readlocale scr_beep   scr_bs
scr_cdelete scr_cinsert scr_clear scr_cr   scr_curs  scr_cursrt  scr_cursup
scr_eol    scl_home   scr_ldelete scr_lf    scr_linsert scr_tab   _CXFERR
_CXOVF     _EPILOG    _PROLOG
</PRE>
<P>
Die Liste sieht lang aus, aber man mu&szlig; bedenken, da&szlig; die meisten
aufgelisteten Funktionen "extrem exotische Funktionen" sind, die vermutlich
vielen Programmierern gar nicht bekannt sind. Im ANSI-Standard sind sie
jedenfalls nicht enthalten.
<P>
Nach den Ersetzungen (die wichtigsten Ersetzungen laufen auf das Ersetzen
von open/close/read/write hinaus...) gibt es noch einen anderen Aspekt von
ANSI zu bedenken:
<P>
Schreibweisen wie:
<P>
<TT>char *string=malloc(300);</TT>
<P>
die bei SAS/C nur eine WARNING produzieren, produzieren bei strengen ANSI-
C-Compilern einen Fehler. Derartiger Code sollte so aussehen:
<P>
<TT>char *string=(char *)malloc(300);</TT>
<P>
ANSI C verlangt eine STRENGE TYPISIERUNG. Dies gilt &uuml;brigens auch f&uuml;r
Zeiger auf Funktionen. Ein guter "Trick", um einen nicht ANSI-konformen
Source rasch zu konvertieren, ist:
<P>
<OL><LI>Einfach mal durchcompilieren und dabei auf die Warnings/Fehler achten.</LI>
<LI>Alles, was nach Zeiger aussieht, und nicht streng typisiert ist, auf
<TT>void *</TT> casten. Alles, was nicht nach Zeiger aussieht, und falsch
typisiert ist, je nach Anwendung auf int, long oder double casten.
Zeiger auf Funktionen auf void * casten, z.B.:<BR>
<TT>void *funktion=(void *)meine_funktion;</TT>
</LI></OL>

Programmierer, die keinen StormC besitzen, k&ouml;nnen das "Test-Compilieren"
auch mit SAS/C im "<TT>STRICT_ANSI</TT>"-Modus machen, der meines Wissens ziemlich
&auml;hnlich wie StormC reagiert.
<P>
Zudem sollte man noch jedes Auftreten von K&R-Syntax durch die normale C-
Syntax ersetzen, z.B.
<P>
<PRE>void main(argv,argc)
int argv;
char **argc;</PRE>
<P>
durch
<P>
<PRE>void main(int argv,char **argc);</PRE>
<P>
ersetzen, da der PPC-Compiler keine K&R-Syntax mag.
<P>
Falls ein Source - wie etwa der Doom-Source - relativ h&auml;ufig Funktionen aus
der Unix-Welt verwendet, so hat es sich als hilfreich erwiesen, eine auf
StormC umgeschriebene Version der AmiTCP/IP-Includes zu verwenden, so da&szlig;
Datentypen wie z.B. dev_t zur Verf&uuml;gung stehen. Ein Source, der von Anfang
an auf ANSI-Kompatibilit&auml;t getrimmt ist, sollte solche Typen jedoch nicht
n&ouml;tig haben. Wer dies dennoch n&ouml;tig hat, soll einfach mal bei mir mit Bitte
um Hilfestellung anfragen (Kontaktadresse siehe unten).
<P>
Ein letzter Aspekt der Compiler-Unterschiede w&auml;ren spezifische Unterschiede
zwischen SAS/C und StormC. Ich habe mich hierbei auf die Beschreibung
"normaler" Sources beschr&auml;nkt, wer gerne PPC-Shared Libraries machen
m&ouml;chte, soll mich kontaktieren, und ich werde auch hier beschreiben, was
die Unterschiede zwischen SAS/C und StormC sind.
<P>
Einige Schl&uuml;sselworte von SAS/C entfallen einfach, indem man sie auf "leer"
definiert:
<P>
<PRE>#define __stdargs
#define __regargs
#define __asm</PRE>
<P>
__far sollte durch das Schl&uuml;sselwort FAR ersetzt werden, __inline durch
inline, in diesen Dingen orientiert sich StormC ebenfalls mehr an ANSI.
__chip, __fast und __interrupt funktionieren nicht so wie bei SAS/GNU, hier
mu&szlig; man den Weg &uuml;ber die entsprechenden OS-Funktionen gehen.
<P>
Registerparameter funktionieren (bis auf das Weglassen des Schl&uuml;sselwortes
__asm) genau wie beim SAS/C, jedoch sollte man f&uuml;r eine PPC-Version darauf
verzichten, da der PPC ja z.B. kein Register d0 hat (das ist ein 68k-
Register). Man kann nat&uuml;rlich
<P>
<TT>register int a;</TT>
<P>
schreiben, das funktioniert. Der PPC sucht dann selbst nach einem
geeigneten Register, bzw. der Compiler tut das.
<P>
<B>C. PPC-Anpassung</B>
<P>
So, den wildesten Part haben wir nun, es folgen eigentlich nur noch
Kleinigkeiten.
<P>
Da die eigentliche PPC-Anpassung ja noch gar nicht erfolgte (bis auf die
Kleinigkeit mit den Registern...), folgt, da&szlig; man mit WarpOS die 68k- und
die PPC-Version sehr leicht parallel entwickeln kann.
<P>
Der erste wesentliche Unterschied betrifft die OS-Includes. Ein
<P>
<TT>#include &lt;proto/exec.h></TT>
<P>
oder
<P>
<TT>#include &lt;clib/exec_protos.h><BR>
#include &lt;pragma/exec_protos.h></TT>
<P>
schreibt sich unter PPC als:
<P>
#include &lt;clib/exec_protos.h>
<P>
Die Pragmas entfallen komplett, und man sollte auch keine Protos includen.
<P>
F&uuml;r die Parallelentwicklung sieht das Ganze so aus:
<P>
<PRE>#include &lt;clib/exec_protos.h>
#ifndef __PPC__
#include &lt;pragma/exec_lib.h>
#endif</PRE>
<P>
Der Define __PPC__ ist immer entsprechend der Compiler-Optionen gesetzt.
<P>
Ein weiterer Unterschied f&auml;llt bei der Verwendung von Subtasks an. In
dieser einfachen Variante der PPC-Portierung verwenden wir ja keine Mixed
Binaries (&uuml;ber die Mixed Binary schreibe ich vielleicht sp&auml;ter noch einen
anderen Artikel), daher sind alle Tasks unseres Programms PPC-Native.
Sollte man nun einen PPC-Native-Subtask starten, so mu&szlig; dieser nat&uuml;rlich
mit CreateTaskPPC() der powerpc.library gestartet werden, nicht etwa mit
CreateTask(), weil das 68k-AmigaOS nat&uuml;rlich keine PPC-Tasks starten kann.
Der Aufruf entspricht jedoch bei praktisch allen "Exec-&auml;hnlichen"
Funktionen der powerpc.library 1:1 dem Vorgehen unter dem 68k-AmigaOS. Eine
Alternative w&auml;re nat&uuml;rlich die Verwendung eines Mixed Binary, aber das
sollte man vermeiden, da es die Performance senkt.
<P>
Ein weiterer Unterschied betrifft noch die Tag-List-Schreibweisen mancher
OS-Funktionen. So beherrscht der PPC-Compiler zwar OpenScreenTagList, aber
nicht OpenScreenTags. Man mu&szlig; den Source also entsprechend anpassen.
<P>
Ein weiterer Unterschied betrifft die Funktion BeginIO der alib_protos.h.
Diese Funktion ist unter PPC nur &uuml;ber ein (im Beispiel f&uuml;r das
audio.device)
<P>
<PRE>#include &lt;libraries/powerpc.h>
#include &lt;ppcamiga.h>

void BeginIOAudioPPC(struct IORequest *arg1)
{
  extern struct Library *AudioBase;
  ULONG regs[16];
  regs[9] = (ULONG) arg1;
  __CallLibrary(AudioBase,-30,regs);
}
</PRE>
<P>
verf&uuml;gbar. Wie man sieht, mu&szlig; man unter PPC grunds&auml;tzlich die LibBase des
Devices auslesen. Ein Beispielaufruf k&ouml;nnte wie folgt aussehen (Code-
Beispiel aus ZhaDoomPPC...):
<P>
<PRE>
AudioBase = (struct Library *)audio_io->ioa_Request.io_Device;
c = &channel_info[cnum];
c->audio_io->ioa_Request.io_Command = CMD_WRITE;
c->audio_io->ioa_Request.io_Flags = ADIOF_PERVOL;
c->audio_io->ioa_Data = &chip_cache_info[cache_chip_data
(id)].chip_data[8];
c->audio_io->ioa_Length = lengths[id] - 8;
c->audio_io->ioa_Period = period_table[pitch];
c->audio_io->ioa_Volume = vol &lt;&lt
c->audio_io->ioa_Cycles = 1;
#ifdef PPC
BeginIOAudioPPC((struct IORequest *)c->audio_io);
#else
BeginIO ((struct IORequest *)c->audio_io);
#endif
</PRE>
<P>
Einige Leser fragen sich vielleicht inzwischen, wo der ber&uuml;hmte
Kontextswitch bleibt. Ganz einfach: Er bleibt. StormC verf&uuml;gt n&auml;mlich &uuml;ber
das Feature des "vollautomatischen Kontextswitches", was bedeutet, der User
mu&szlig; sich um nichts mehr k&uuml;mmern, da dies bereits der Compiler f&uuml;r ihn
erledigt. Es m&uuml;ssen lediglich Stub-Dateien oder Defines f&uuml;r die per
Kontextswitch aufzurufenden Funktionen vorliegen. Diese sind f&uuml;r alle
AmigaOS-Funktionen sowie f&uuml;r die 68k-Funktionen der rtgmaster.library (die
jedoch auch PPC-Native-Funktionen besitzt) bereits in die ppcamiga.lib
integriert. F&uuml;r Funktionen, die nicht integriert sind, generiert man die
Stubs mittels
<P>
<TT>genppcstub mylib_protos.h mylib.fd VERBOSE</TT>
<P>
wobei die Proto- und die FD-Datei vorliegen m&uuml;ssen. Das Ergebnis wird dann
einfach ins Projekt integriert (es handelt sich um einen C-Source). Im
Falle eines "Mixed Binary" geht &uuml;brigens der Wechsel zwischen 68k und PPC
wieder automatisch, ohne da&szlig; etwas Zus&auml;tzliches gemacht werden mu&szlig;.
<P>

Unter WarpOS braucht ein Kontextswitch etwa 0.5 Millisekunden (h&auml;ngt aber
auch von der verwendeten PPC-Karte ab, 0.5 Millisekunden braucht es bei
einer 200-MHz-Karte). Es sollte vermieden werde, "viele Kontextswitches pro
Sekunde" zu erzeugen.
<P>
Beispiele, was zu vermeiden ist:
<P>
<UL><LI>
   Byteweises Einladen von Files mit fgetc (statt dessen mit fread in einen
Fast-RAM-Buffer einladen, und dann nachbearbeiten)
</LI><LI>
   Pixelweises Darstellen auf dem Bildschirm (statt dessen in einen Fast-
RAM-Buffer zeichnen und den dann mit einem Befehl zeichnen)
</LI><LI>
   In h&auml;ufig pro Sekunde aufgerufenen Schleifen viele OS-Calls
<P>
</LI></UL>
Die Grafik kann auch mittels der PPC-Version der rtgmaster.library komplett
PPC-Native abgearbeitet werden.
<P>
<B>Ein Beispiel der Effekte von Kontextswitches:</B>
<P>
ZhaDoomPPC auf einem 150-MHz-Rechner ohne Sound: 36 fps<BR>
ZhaDoomPPC auf einem 150-MHz-Rechner mit Sound : 32 fps
<P>
Der Sound bewirkt bei ZhaDoomPPC derzeit 9 Kontextswitches. Eine L&ouml;sung des
Problems w&auml;re die Auslagerung der kompletten Sound-Funktion in einen 68k-
Part, den man dann &uuml;ber einen manuellen Aufruf des Kontextswitchers (siehe
Dokumentation der powerpc.library) oder &uuml;ber ein Mixed Binary aufruft.
Damit w&uuml;rde der Mehraufwand auf einen Kontextswitch reduziert. Im Falle von
ZhaDoomPPC war das leider nicht so einfach machbar, da die Kontextswitches
in verschiedenen Funktionen lagen, und so genau habe ich mir das noch nicht
angeschaut.
<P>
Es sind zudem noch Optimierungen durch Ausnutzung der BAT-Register des PPC
m&ouml;glich, hier m&ouml;chte ich jedoch einfach auf die Dokumentation von WarpOS
verweisen.
<P>

Es ist nat&uuml;rlich m&ouml;glich, Teile des Codes in PPC-Assembler zu &uuml;bersetzen,
aber im Normalfall ist das eigentlich gar nicht n&ouml;tig. Der PPC ist
eigentlich schnell genug, um (fast) alles in C oder C++ zu machen
(rtgmaster PPC hat trotzdem einige Assembler-Parts, da dies bei einem
Grafiktreiber Sinn macht).
<P>
In einigen Newsgruppen wurde diskutiert, Programmteile parallel auf dem 68k
und dem PPC laufen zu lassen. Dies w&uuml;rde man mittels des Message-Systems
von WarpOS implementieren (Stichwort AllocXMsg in der powerpc.library-
Dokumentation), man sollte es jedoch aus zwei Gr&uuml;nden vermeiden:
<P>
1) Ein solches Programm w&uuml;rde bei (zuk&uuml;nftigen) PPC-only Maschinen nicht in
idealster Weise profitieren, da Teile immer noch als 68k-Code abgearbeitet
w&uuml;rden. Und ich denke, auf lange Sicht werden solche Maschinen kommen.
<P>
2) Die Hardware ist schlichtweg nicht f&uuml;r den Multiprozessor-Betrieb
geeignet, ganz gleich, wie man die Software anstellt. Ich werde hierauf
nicht n&auml;her eingehen, ist in den Newsgruppen genug zu Tode diskutiert
worden.
<P>
Solange die Tasks nicht miteinander kommunizieren, d&uuml;rfte es
unproblematisch sein, aber dann machen sie auch vermutlich nicht viel Sinn.
Dies ist ein prinzipielles Problem der Hardware.
<P>
Aus oben genannten Gr&uuml;nden kann ich nur empfehlen, "synchron" zu bleiben.
Wobei zuk&uuml;nftige Kompatibilit&auml;t bei optimaler Geschwindigkeit da wohl
beinahe das Wichtigere ist.
<P>
Kontaktadresse bei R&uuml;ckfragen:
<BR>
Steffen H&auml;user<BR>
Limburgstr. 127<BR>
73265 Dettingen/Teck<BR>
Tel. 07021-51787<BR>
email: <A HREF="mailto:MagicSN@Birdland.es.bawue.de">MagicSN@Birdland.es.bawue.de</A>
<P>
Informationen zur Person:
<P>
Informatik-Student.
<P>
Haupt-Aktivit&auml;ten im Amiga-Bereich:
<P>
<UL><LI>
   rtgmaster.library
</LI><LI>
   ZhaDoomPPC (Ein PPC-Doom-Port unter WarpOS)
</LI><LI>
   WarpView (Ein Image-Viewer f&uuml;r PPC unter WarpOS und 68k)
</LI><LI>
   WarpAMP (ein Port des AMP-MPEG-3-Players f&uuml;r WarpOS)
</LI><LI>
   Crystal3D (ein Port einer Spiele-artigen 3D-Engine)
</LI><LI>
   Seit kurzem Coder bei der Demo-Gruppe "Giants"
</LI><LI>
   ehemals Autor der "Amiga Texturemapping FAQ"
</LI><LI>
   "Berater" in Grafikkarten/PPC-Fragen bei einigen Amiga-Spiele-Firmen
</LI><LI>
   ppctut.guide (Einf&uuml;hrung in PPC-Assembler-Programmierung)«
</LI></UL>
<P>


<P ALIGN=RIGHT>
<A HREF="0501.html"><IMG SRC="../menu/pfeil_links.gif" BORDER=0 WIDTH=20 HEIGHT=20></A>
<A HREF="0600.html"><IMG SRC="../menu/pfeil_rechts.gif" BORDER=0 WIDTH=20 HEIGHT=20></A>
</P>
</BODY>
</HTML>

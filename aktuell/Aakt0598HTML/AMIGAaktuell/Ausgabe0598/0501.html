<HTML>
<HEAD><TITLE>Workshops / Hintergrundberichte</TITLE></HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000AA" ALINK="#000066" VLINK="#000066">
<CENTER>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=1><TR><TD COLSPAN=2 VALIGN=TOP ALIGN=LEFT>
  <IMG SRC="../menu/title_amiga.gif" WIDTH=58 HEIGHT=20 BORDER=0>
</TD></TR>
<TR><TD VALIGN=TOP ALIGN=LEFT>
  <IMG SRC="../menu/title_aktuell.gif" WIDTH=9 HEIGHT=60 BORDER=0>
</TD><TD VALIGN=TOP ALIGN=CENTER>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=1 BGCOLOR="#000000"><TR>
<TD ROWSPAN=3 VALIGN=TOP>
<IMG SRC="../menu/empty.gif" BORDER=0 WIDTH=19 HEIGHT=15>
</TD><TD ROWSPAN=3 VALIGN=TOP>
<A HREF="../index.html"><IMG SRC="../menu/hauptseite.gif" BORDER=0 WIDTH=62 HEIGHT=15></A>
</TD><TD ROWSPAN=3 VALIGN=TOP>
<A HREF="0500.html"><IMG SRC="../menu/links.gif" BORDER=0 WIDTH=15 HEIGHT=15></A>
</TD><TD ROWSPAN=3 VALIGN=TOP>
<A HREF="0502.html"><IMG SRC="../menu/rechts.gif" BORDER=0 WIDTH=15 HEIGHT=15></A>
</TD><TD ROWSPAN=3>
<IMG SRC="../menu/empty.gif" BORDER=0 WIDTH=19 HEIGHT=15>
</TD><TD>
<A HREF="index.html"><IMG SRC="../menu/inhalt.gif" BORDER=0 WIDTH=37 HEIGHT=15></A>
</TD><TD>
<A HREF="0100.html"><IMG SRC="../menu/vorwort.gif" BORDER=0 WIDTH=47 HEIGHT=15></A>
</TD><TD>
<A HREF="0200.html"><IMG SRC="../menu/intern.gif" BORDER=0 WIDTH=37 HEIGHT=15></A>
</TD><TD>
<A HREF="0300.html"><IMG SRC="../menu/gewinnspiel.gif" BORDER=0 WIDTH=70 HEIGHT=15></A>
</TD><TD>
<A HREF="0400.html"><IMG SRC="../menu/forum.gif" BORDER=0 WIDTH=37 HEIGHT=15></A>
</TD><TD ROWSPAN=3 VALIGN=TOP>
<IMG SRC="../menu/empty.gif" BORDER=0 WIDTH=19 HEIGHT=15>
</TD></TR>

<TR><TD>
<A HREF="0500.html"><IMG SRC="../menu/workshops.gif" BORDER=0 WIDTH=62 HEIGHT=15></A>
</TD><TD>
<A HREF="0600.html"><IMG SRC="../menu/testberichte.gif" BORDER=0 WIDTH=70 HEIGHT=15></A>
</TD><TD>
<A HREF="0700.html"><IMG SRC="../menu/spieleteil.gif" BORDER=0 WIDTH=55 HEIGHT=15></A>
</TD><TD>
<A HREF="0800.html"><IMG SRC="../menu/amigainc.gif" BORDER=0 WIDTH=87 HEIGHT=15></A>
</TD><TD>
<A HREF="0900.html"><IMG SRC="../menu/poweruptodate.gif" BORDER=0 WIDTH=90 HEIGHT=15></A>
</TD>
</TR><TR>
<TD>
<A HREF="1000.html"><IMG SRC="../menu/produktankuendigungen.gif" BORDER=0 WIDTH=125 HEIGHT=15></A>
</TD><TD>
<A HREF="1100.html"><IMG SRC="../menu/diverses.gif" BORDER=0 WIDTH=50 HEIGHT=15></A>
</TD><TD>
<A HREF="1200.html"><IMG SRC="../menu/kurzmeldungen.gif" BORDER=0 WIDTH=85 HEIGHT=15></A>
</TD><TD>
<A HREF="1300.html"><IMG SRC="../menu/geruechte.gif" BORDER=0 WIDTH=52 HEIGHT=15></A>
</TD><TD>
<A HREF="1400.html"><IMG SRC="../menu/abschliessend.gif" BORDER=0 WIDTH=75 HEIGHT=15></A>
</TD></TR>
<TR><TD BGCOLOR="#EEEEEE" COLSPAN=11>
<H2 ALIGN=CENTER>Workshops / Hintergrundberichte</H2>
</TD></TR>
</TABLE>

</TD></TR>
</TABLE>
</CENTER>

<P>

<H2>1. ARexx-Kurs - Teil 4 (von Heiko Kuschel)</H2>

<P>
»ARexx-Kurs: &Uuml;bersicht
<P>
1. Einf&uuml;hrung in ARexx
<UL><LI>
   Wie funktionierts?
</LI><LI>
   Was brauche ich?
</LI><LI>
   Installation
</LI><LI>
   ein erstes kleines Programm
</LI><LI>
   Ein- und Ausgabe
</LI><LI>
   do...end
<P>
</LI></UL>
2. Programmstruktur und Ansteuerung von anderen Programmen
<UL><LI>
   if
</LI><LI>
   do...end
</LI><LI>
   address
</LI><LI>
   Tracing
<P>
</LI></UL>
3. Ein- und Ausgabe; Funktionen
<UL><LI>
   Ein- und Ausgabe
</LI><LI>
   Stringfunktionen
</LI><LI>
   mathematische Funktionen
</LI><LI>
   Konvertierungsfunktionen
</LI><LI>
   Bitmanipulation
<P>
</LI></UL>
4. komplexere Programmstrukturen
<UL><LI>
   Operatoren
</LI><LI>
   Procedure
</LI><LI>
   Libraries
</LI><LI>
   sonstiges
<P>
</LI></UL>
5. Beispiele f&uuml;r die Vernetzung von Programmen
<UL><LI>
   Wordworth
</LI><LI>
   GoldEd
</LI><LI>
   Database Professional
</LI><LI>
   YAM
</LI><LI>
   Miami
</LI><LI>
   usw.
<P>
</LI></UL>
&Auml;nderungen vorbehalten. Spezielle W&uuml;nsche werden, wenn m&ouml;glich, gerne
aufgenommen.«
<P>
»<H3>4. Programmstrukturen und Systemfunktionen</H3>
<H4>4.0. Vorbemerkungen</H4>
Hier wiederhole ich f&uuml;r Quereinsteiger noch einmal einen Teil der
Vorbemerkungen, die ich zum ganzen Kurs gemacht habe.
<P>
Der Kurs wird als reine Text-Datei angefertigt, da auch Amiga aktuell u.a.
in ASCII-Form verschickt wird. Um den Text etwas zu gliedern, habe ich
daher ein paar "Textmarker" eingef&uuml;gt.
<P>
<PRE>
********** unterteilt einzelne Abschnitte
__________ bezeichnet Beginn und Ende eines ARexx-Programms. Die Striche geh&ouml;ren nicht zum Programm!
</PRE>
<SMALL>Hinweis: In der HTML-Version verzichten wir auf diese Kennzeichnung und benutzen
&uuml;bersichtlichere Formatierungen</SMALL>
<P>
ARexx-Befehle werden in diesem Kurs immer GROSS geschrieben, obwohl das
eigentlich nicht n&ouml;tig ist. Auf diese Weise kann man sie aber leichter
erkennen.
<P>
Ich hoffe, da&szlig; diese Regelung den Kurs etwas leserlicher macht.
<P>
Wenn Ihr spezielle Fragen habt, etwas nicht verstanden habt oder Anregungen
und Ideen f&uuml;r weitere Kursteile habt, k&ouml;nnt Ihr euch gerne an mich wenden.
Ich selbst benutze folgende ARexx-f&auml;hige Programme und kann daher auf deren
Programmierung kurz eingehen, wenn das gew&uuml;nscht wird:
Wordworth, GoldEd, Database Professional, YAM, Miami, Voyager, TurboCalc.
<P>
<B>Hier meine Kontaktadresse:</B>
<P>
Heiko Kuschel<BR>
Lehmgrubenweg 13<BR>
97280 Remlingen<BR>
E-Mail: <A HREF="mailto:hk0006@wuerzburg.baynet.de">hk0006@wuerzburg.baynet.de</A>
<P>
Und jetzt... viel Spa&szlig; mit ARexx!
<P>
<H4>4.1. Operatoren</H4>
Ein schwierig klingendes Wort f&uuml;r eine Sache, die wir zum Teil schon ganz
selbstverst&auml;ndlich angewendet haben. Operatoren sind einfach die Zeichen,
die zwei Variablen oder sonstige Ausdr&uuml;cke auf irgendeine Art verkn&uuml;pfen.
Also z.B. ein simples +. Das Problem ist nur: Wie sollen diese Operatoren
abgearbeitet werden, wenn mehrere in einem Ausdruck vorhanden sind? Aus
Mathe kennst Du sicher noch "Punkt vor Strich": Erst mal und geteilt durch,
dann plus und minus. In ARexx gibt es eine ganze Priorit&auml;tenliste der
Operatoren, und auch hier gibt es welche, die wie Plus und Minus die
gleiche Priorit&auml;t haben. Diese Liste sieht folgenderma&szlig;en aus:
<P>
<PRE>
Operator    Pri.    Beschreibung
~           8       logisches "nicht"
+           8       als Pr&auml;fix zur Konvertierung
-           8       Pr&auml;fix
**          7       Potenzierung 2**6 meint "2 hoch 6"
*           6       Multiplikation
%           6       ganzzahlige Division
/           6       Division
//          6       Rest der Division
-           5       Subtraktion
+           5       Addition
Leerz.      4       Verkettung mit Leerzeichen
||          4       direkte Verkettung
~==         3       absolut ungleich
==          3       absolut gleich
~=          3       ungleich
=           3       gleich
>=          3       gr&ouml;&szlig;er/gleich
>           3       gr&ouml;&szlig;er
&lt;=          3       kleiner/gleich
&lt;           3       kleiner
&amp;           2       logisches UND
|           1       logisches ODER
&amp;&amp;          1       logisches exklusiv ODER
</PRE>
<P>
Ich denke, es sollte kein Problem sein, diese Liste anzuwenden. Besonders
interessant finde ich, da&szlig; es gleich extra Operatoren f&uuml;r eine ganzzahlige
Division gibt, ebenso wie f&uuml;r den Rest bei einer solchen Operation.
<P>
<H4>4.2. Programmstruktur</H4>
Bis jetzt haben wir nur Programme geschrieben, die mehr oder weniger von
oben nach unten abgearbeitet wurden. Je komplexer Programme werden, desto
wichtiger ist es aber, auch noch &Uuml;berblick zu behalten. Deshalb gibt es in
so gut wie allen Programmiersprachen die M&ouml;glichkeit, ein Programm in
Unterabschnitte aufzuteilen, die dann (z.B. &uuml;ber einen aussagekr&auml;ftigen
Namen) aufgerufen werden.
Das Hauptprogramm ist dann oft nur noch dazu da, die Unterprogramme in der
richtigen Reihenfolge aufzurufen.
<P>
Der erste daf&uuml;r notwendige Befehl lautet CALL.
CALL kann auf verschiedene Arten verwendet werden:
<P>
<B>1. Aufruf einer ARexx-Funktion. Das Ergebnis wird in RESULT abgelegt</B>
<P>

<TABLE CELLSPACING=0 CELLPADDING=4 BORDER=0 BGCOLOR="#FFFFCC"><TR><TD ALIGN=LEFT VALIGN=TOP><FONT COLOR="#000055"><PRE>
CALL OPEN(Dateiname usw.)
ECHO RESULT
</PRE></TD></TR></TABLE>

ist gleichbedeutend mit

<TABLE CELLSPACING=0 CELLPADDING=4 BORDER=0 BGCOLOR="#FFFFCC"><TR><TD ALIGN=LEFT VALIGN=TOP><FONT COLOR="#000055"><PRE>
Ergebnis=OPEN(Dateiname usw.)
ECHO Ergebnis
</PRE></TD></TR></TABLE>

<B>2. Aufruf externer ARexx-Programme</B>
<P>
Andere ARexx-Programme k&ouml;nnen mit CALL "rexx:MeinProg.rexx" gestartet
werden.
<P>
<B>3. Mit CALL kann in ein Unterprogramm verzweigt werden.</B>
<P>
Das ist jetzt der Punkt, der f&uuml;r uns im Moment am interessantesten ist. Die
Unterprogramme werden alle mit Namen versehen. Dieser Name wird einfach in
die erste Zeile einer Unterroutine geschrieben und ein Doppelpunkt
angeh&auml;ngt. Die letzte Zeile der Unterroutine enth&auml;lt dann ein RETURN (Kehre
zur&uuml;ck). Nochmal ein Beispiel mit "HelloWorld" gef&auml;llig?

<TABLE CELLSPACING=0 CELLPADDING=4 BORDER=0 BGCOLOR="#FFFFCC"><TR><TD ALIGN=LEFT VALIGN=TOP><FONT COLOR="#000055"><PRE>
/* Hello World Version 1.6.*/

CALL Fensteroeffnen
CALL FrageundAntwort
EXIT

Fensteroeffnen:
Erfolg=OPEN(Fenster,'CON:20/20/620/100/Hello World 1.6./CLOSE',R)
IF ~Erfolg THEN ECHO "Fehler!"
RETURN

FrageundAntwort:
DO WHILE Eingabe~="Ende"
Erfolg=WRITELN(Fenster,"Gib was ein!")
Eingabe=READLN(Fenster)
Erfolg=WRITELN(Fenster,"Du hast "||Eingabe||" eingegeben.")
END
RETURN
</PRE></TD></TR></TABLE>

Beachte, wieviel k&uuml;rzer und damit &uuml;bersichtlicher selbst bei diesem Mini-
Programm das Hauptprogramm geworden ist!
<P>
<B>&Uuml;brigens:</B> So ganz nebenbei habe ich hier den Befehl EXIT eingef&uuml;gt. Er
beendet das ARexx-Skript. Soll das Skript an das aufrufende Programm einen
Wert zur&uuml;ckgeben, kann man den auch definieren, z.B. EXIT 10. Wenn ein
Skript einfach irgendwo aufh&ouml;rt und kein Befehl mehr nachfolgt, sieht der
Interpreter das als EXIT 0 an. Der R&uuml;ckgabewert, der normalerweise f&uuml;r
Fehlermeldungen benutzt wird, ist dann 0.
<P>
Jetzt w&auml;re es nat&uuml;rlich noch sch&ouml;n, wenn man sich bei der Erstellung der
Unterprogramme nicht immer darum k&uuml;mmern m&uuml;&szlig;te, welche Variablen im
Hauptprogramm oder in anderen Unterprogrammen bereits verwendet wurden.
Dann ist es z.B. sehr leicht m&ouml;glich, einzelne Programmteile in anderen
Skripten wiederzuverwerten, ohne irgend etwas daran ver&auml;ndern zu m&uuml;ssen.
Und nat&uuml;rlich ist auch das m&ouml;glich. Neben der einfachen Form von
Unterprogrammen, wie wir sie gerade eingef&uuml;hrt haben, gibt es auch noch
sogenannte Procedures, die v&ouml;llig unabh&auml;ngig vom Hauptprogramm arbeiten.
Variablen im Hauptprogramm werden nicht ver&auml;ndert, au&szlig;er man sagt es
ausdr&uuml;cklich. So eine Procedure wird durch den Befehl PROCEDURE definiert.
Sie endet mit dem Befehl RETURN, bei dem noch angegeben werden kann, ob der
Wert einer Variable in RESULT abgelegt werden soll.
<P>

<TABLE CELLSPACING=0 CELLPADDING=4 BORDER=0 BGCOLOR="#FFFFCC"><TR><TD ALIGN=LEFT VALIGN=TOP><FONT COLOR="#000055"><PRE>
/* Hello World Version 1.7.*/

CALL Fensteroeffnen
CALL FrageundAntwort
EXIT

Fensteroeffnen:
Erfolg=OPEN(Fenster,'CON:20/20/620/100/Hello World 1.6./CLOSE',R)
IF ~Erfolg THEN ECHO "Fehler!"
RETURN

FrageundAntwort:
DO WHILE Result~="Ende"
CALL Eingabefrage
CALL Ausgabe
END
RETURN

Eingabefrage:
Erfolg=WRITELN(Fenster,"Gib was ein!")
RETURN

Ausgabe: PROCEDURE
Eingabe=READLN(Fenster)
Erfolg=WRITELN(Fenster,"Du hast "||Eingabe||" eingegeben.")
RETURN Eingabe
</PRE></TD></TR></TABLE>

Die Variable Eingabe existiert nur noch in der Prozedur Ausgabe! Versuche
einmal herauszufinden, was diese Variable innerhalb des Hauptprogramms f&uuml;r
einen Wert enth&auml;lt!
(Noch nicht benutzte Variablen enthalten ihren eigenen Namen in
Gro&szlig;schrift... nur so als kleiner Hinweis.)
Hinter PROCEDURE kann man nun auch noch angeben, welche Variablen aus dem
Hauptprogramm im Unterprogramm doch bekannt sein sollen.
Das sieht dann z.B. so aus:
Unterprogramm: PROCEDURE EXPOSE Variable Nocheine Unddiedritte Undsoweiter
<P>
An dieser Stelle m&ouml;chte ich nun noch einen Befehl nachtragen, der
eigentlich schon ein wenig fr&uuml;her sinnvoll gewesen w&auml;re. Aber auch hier
kann er gute Dienste leisten. Wenn nun abh&auml;ngig von dem, was der Benutzer
eingeben will, verschiedene Dinge ausgef&uuml;hrt werden sollen, dann kann man
daf&uuml;r nat&uuml;rlich lauter einzelne IF...THEN-Abfragen machen. Aber was tun,
wenn ich 20 solcher Abfragen habe, und als letztes will ich eine Aktion f&uuml;r
alles, was noch nicht extra abgefragt wurde?
<P>
Also z.B.: Wenn der Benutzer "ich" eingegeben hat, schreibe "Hallo Heiko!".
Wenn der Benutzer "Schafkopf" eingegeben hat, schreibe "Wenz", usw. Und
wenn er gar nichts von den Sachen eingibt, sondern was ganz anderes, dann
schreibe "Wie kreativ! :-)"
<P>
Daf&uuml;r gibt es den Befehl SELECT...END. Das schaut dann folgenderma&szlig;en aus:
<TABLE CELLSPACING=0 CELLPADDING=4 BORDER=0 BGCOLOR="#FFFFCC"><TR><TD ALIGN=LEFT VALIGN=TOP><FONT COLOR="#000055"><PRE>
SELECT
WHEN Eingabe="ich" THEN DO
Erfolg=WRITELN(Fenster,"Hallo Heiko!")
END
WHEN Eingabe="Schafkopf" THEN DO
Erfolg=WRITELN(Fenster,"Wenz!")
END
OTHERWISE DO
Erfolg=WRITELN(Fenster,"Wie kreativ!")
END
END
</PRE></TD></TR></TABLE>
Die Angabe von OTHERWISE ist notwendig, sonst gibt's eine Fehlermeldung!
<P>
<H4>4.3. Systemfunktionen</H4>
<P>
Die Systemfunktionen geben weitgehende Kontrolle &uuml;ber computerinterne
Dinge. Sie werden wie alle Funktionen in ARexx entweder aufgerufen mit
Ergebnis=Funktion(), oder aber, wie wir in diesem Kursteil gesehen haben,
mit CALL Funktion(). Vorsicht! Manche sind schon sehr speziell, Du solltest
wissen, was Du damit anstellst.
<P>
<FONT COLOR="#0000AA"><B><TT>ADDLIB(Name,Priorit&auml;t[,Offset,Version])</TT></B></FONT><BR>
Hiermit lassen sich externe Bibliotheken (Libraries) in ARexx einbinden,
die weitere Befehle zur Verf&uuml;gung stellen. Solche Bibliotheken befinden
sich normalerweise im Verzeichnis LIBS: und haben die Endung .library. F&uuml;r
ARexx sind leider meistens spezielle Abwandlungen dieser Libraries n&ouml;tig.
Im Aminet gibt es aber eine ganze Reihe sehr guter Libraries, z.B.
rexxtricks.library, rexxsupport.library, rexxreqtools.library und andere.
Wie diese im einzelnen arbeiten, kann ich hier kaum erkl&auml;ren, das w&uuml;rde zu
weit f&uuml;hren. Die Befehle, die die Libraries zur Verf&uuml;gung stellen, sind
normalerweise gut dokumentiert. ARexx schaut dann bei Befehlen, die
unbekannt sind, zun&auml;chst einmal in den angemeldeten Bibliotheken nach, ob
dort der entsprechende Befehl zu finden ist. Erst dann wird versucht, &uuml;ber
den ARexx-Port ein Programm zu finden, das diesen Befehl versteht.
Die Priorit&auml;t gibt an, in welcher Reihenfolge in den Bibliotheken gesucht
werden soll. Hoher Wert meint zuerst suchen. G&uuml;ltig sind Werte zwischen 100
und -100. Offset ist die Einsprungadresse f&uuml;r die QUERY-Funktion der
Bibliothek. Ist normalerweise -30 und mu&szlig; angegeben werden, damit alles
funktioniert. Mit Version kann noch eine Versionsnummer der Bibliothek
angegeben werden. Ist die Version der gefundenen Bibliothek kleiner, wird
sie nicht akzeptiert.
Ein Beispiel, f&uuml;r das Du nat&uuml;rlich die rexxreqtools.library installiert
haben mu&szlig;t:
<P>
<TABLE CELLSPACING=0 CELLPADDING=4 BORDER=0 BGCOLOR="#FFFFCC"><TR><TD ALIGN=LEFT VALIGN=TOP><FONT COLOR="#000055"><PRE>
IF ~SHOW("L",rexxreqtools.library) THEN DO
CALL ADDLIB("rexxreqtools.library", 0, -30, 0)
END
gadtxt= "_Weiter|_Cancel"
Eingabe = rtgetstring(" ","Bitte einen Text eingeben:","Hello World 1.8.",gadtxt)
KnopfGedr&uuml;ckt=rtresult
</PRE></TD></TR></TABLE>
... oder in unser Hello World eingebaut, das mittlerweile gigantische
Ausma&szlig;e annimmt:
<P>
<TABLE CELLSPACING=0 CELLPADDING=4 BORDER=0 BGCOLOR="#FFFFCC"><TR><TD ALIGN=LEFT VALIGN=TOP><FONT COLOR="#000055"><PRE>
/* Hello World Version 1.8.*/
IF ~SHOW("L",rexxreqtools.library) THEN DO
CALL ADDLIB("rexxreqtools.library", 0, -30, 0)
END
gadtxt= "_Weiter|_Cancel"
CALL Fensteroeffnen
CALL FrageundAntwort
EXIT
<P>
Fensteroeffnen:
Erfolg=OPEN(Fenster,'CON:20/20/620/100/Hello World 1.8./CLOSE',R)
IF ~Erfolg THEN ECHO "Fehler!"
RETURN
<P>
FrageundAntwort:
DO WHILE (Eingabe~="Ende")&(KnopfGedrueckt~="0")
Eingabe = rtgetstring("","Bitte einen Text eingeben:","Hello World
1.8.",gadtxt)
KnopfGedrueckt=rtresult
Erfolg=WRITELN(Fenster,"Du hast "||Eingabe||" eingegeben.")
END
RETURN
</PRE></TD></TR></TABLE>
Ich m&ouml;chte hier darauf verzichten, rexxreqtools zu erkl&auml;ren. Schau Dir
dieses kleine Beispiel und die zu rexxreqtools geh&ouml;rige Anleitung an und
probiere ein wenig herum damit.
<P>
Jetzt geht's erst mal weiter mit den Systemfunktionen:
<FONT COLOR="#0000AA"><B><TT>ADDRESS()</TT></B></FONT><BR>
ergibt den Namen des ARexx-Ports, an den im Moment die externen Befehle
geschickt werden. Oft sinnvoll am Anfang eines Programms. Die einzige
M&ouml;glichkeit, um z.B. bei einem aus Wordworth gestarteten Programm zu
erfahren, wie denn nun der ARexx-Port tats&auml;chlich hei&szlig;t (Wordworth.1,
Wordworth.2 usw.).
<P>
<FONT COLOR="#0000AA"><B><TT>DATE(Option[,Datum,I|S])</TT></B></FONT><BR>
Gibt die aktuelle Zeit als Zeichenkette zur&uuml;ck. Diese kann weitgehend durch
Optionen ver&auml;ndert werden (auf I|S komme ich gleich zu sprechen).
Diese M&ouml;glichkeiten gibt es, wobei T f&uuml;r Tag, M f&uuml;r Monat und J f&uuml;r Jahr
steht:
<PRE>
Century      Tage seit Beginn des Jahrhunderts
Days         Tage seit Beginn des Jahres
European     TT/MM/JJ
Internal     Systemtage (seit dem 1.1.1978)
Julian       JJTTT (Tage seit Beginn des Jahres)
Month        englischer Monatsname
Normal       TT MMM JJJJ
Ordered      JJ/MM/TT
Sorted       JJJJMMTT
USA          MM/TT/JJ
Weekday      der Wochentag
</PRE>
<P>
Es reicht jeweils der erste Buchstabe als Angabe.
<P>
Durch Angabe des I oder S kann ein Datum, das im Internal- oder Sorted-
Format vorliegt, in jedes beliebige andere umgewandelt werden:
<TABLE CELLSPACING=0 CELLPADDING=4 BORDER=0 BGCOLOR="#FFFFCC"><TR><TD ALIGN=LEFT VALIGN=TOP><FONT COLOR="#000055"><PRE>SAY DATE("E",19960428,"S")</PRE></TD></TR></TABLE>
Ein winziges Beispiel: Ein kleines Programm, das ich einmal t&auml;glich
automatisch aufrufen lie&szlig; und das mir den aktuellen Stand meiner Hausarbeit
auf die Diskette Hausarbeit_BAK: kopierte, und zwar jedesmal in ein neues
Verzeichnis, das als Namen das aktuelle Datum hatte:
<TABLE CELLSPACING=0 CELLPADDING=4 BORDER=0 BGCOLOR="#FFFFCC"><TR><TD ALIGN=LEFT VALIGN=TOP><FONT COLOR="#000055"><PRE>
/*Sicherheitskopie f&uuml;r Hausarbeit*/
Address Command
Datum=DATE("Sorted")
makedir "Hausarbeit_BAK:"Datum
copy "Text:BT-III/Texte/(Hausarbeit|Literaturverzeichnis).TXT
Hausarbeit_BAK:"Datum
</PRE></TD></TR></TABLE>
<FONT COLOR="#0000AA"><B><TT>ERRORTEXT()</TT></B></FONT><BR>
Gibt eine kurze Beschreibung zu jeder Fehlernummer aus, die in ARexx
auftreten kann.
<P>
<FONT COLOR="#0000AA"><B><TT>EXPORT(Addresse[,String,L&auml;nge,F&uuml;llzeichen])</TT></B></FONT><BR>
Hiermit kann der Inhalt eines String an eine 4-Byte-Adresse geschrieben
werden. Der Speicher mu&szlig; vorher reserviert werden! (Siehe GETSPACE)
<P>
<FONT COLOR="#0000AA"><B><TT>FREESPACE([Addresse,L&auml;nge])</TT></B></FONT><BR>
Gibt die mit GETSPACE reservierten Speicherbereiche wieder frei. Bei
Verwendung der Argumente arbeitet die Funktion nicht ganz fehlerfrei. Sie
wird am Ende des Programms sowieso ausgef&uuml;hrt, also vielleicht einfach
weglassen, wenn Du nicht gerade 180 MB Speicher reserviert hast. Und wenn,
dann besser ohne die Argumente, denn FREESPACE wei&szlig;, welcher Speicher ihm
geh&ouml;rt.
<P>
<FONT COLOR="#0000AA"><B><TT>GETCLIP(Name)</TT></B></FONT><BR>
Liest eine Zeichenkette aus dem Clipboard.
<P>
<FONT COLOR="#0000AA"><B><TT>GETSPACE(L&auml;nge)</TT></B></FONT><BR>
Gibt einen Zeiger auf einen freien Speicherbereich zur&uuml;ck.
<P>
<FONT COLOR="#0000AA"><B><TT>HASH(String)</TT></B></FONT><BR>
Gibt den Hashwert des &uuml;bergebenen Strings zur&uuml;ck. Das ist so eine Art
Pr&uuml;fsumme: Alle ASCII-Werte werden addiert, und das unterste Byte der Summe
zur&uuml;ckgegeben.
<P>
<FONT COLOR="#0000AA"><B><TT>IMPORT(Adresse[,L&auml;nge])</TT></B></FONT><BR>
Liest Daten aus einem Speicherbereich. Ohne Angabe einer L&auml;nge wird bis zum
n&auml;chsten "00"x gelesen.
<P>
<FONT COLOR="#0000AA"><B><TT>PRAGMA(Option[,Wert])</TT></B></FONT><BR>
Damit kann man einige Einstellungen des Programms ver&auml;ndern bzw. abfragen.
Folgende Optionen sind m&ouml;glich (es reicht wieder die Angabe des ersten
Buchstabens):
<PRE>
Directory  gibt das aktuelle Verzeichnis des Programms zur&uuml;ck.
ID         Zeiger auf die TaskControlBlock-Struktur
Priority   Damit kann dem Proze&szlig; eine andere TaskPriority gegeben werden.
Vorsicht: REXXMAST hat 4! Nicht h&ouml;her gehen!
Werte zwischen -128 und 127 sind theoretisch m&ouml;glich, normal
ist der Bereich von etwa -5 bis +3.
Window     Damit kann der WindowPointer des Tasks ver&auml;ndert werden. F&uuml;r
</PRE>
"Wert" k&ouml;nnen die Schl&uuml;sselworte "Null" oder "Workbench"
stehen. Der in Wert angegebene logische Name wird als aktueller
Console-Handler eingestellt.
<P>
<FONT COLOR="#0000AA"><B><TT>REMLIB()</TT></B></FONT><BR>
Entfernt eine Library wieder.
<P>
<FONT COLOR="#0000AA"><B><TT>SETCLIP(Name[,Wert])</TT></B></FONT><BR>
Setzt einen Eintrag in der Clipliste. Ohne Angabe eines Wertes wird der
Eintrag gel&ouml;scht. Der R&uuml;ckgabewert ist boolsch (0 oder 1).
<P>
<FONT COLOR="#0000AA"><B><TT>SHOW(Option[,Name,Trennzeichen])</TT></B></FONT><BR>
Option mu&szlig; angegeben werden. Es gibt die folgenden M&ouml;glichkeiten:
<PRE>
Clip      : alle Eintr&auml;ge in der Clip-Liste
Files     : eine Liste der offenen logischen Dateinamen
Internal  : die interne Port-Liste
Libraries : die ge&ouml;ffneten Bibliotheken
Ports     : die allgemeinen PublicMessagePorts, zu denen auch die
            ARexx-Ports geh&ouml;ren.
</PRE>
Es reicht jeweils die Angabe des ersten Buchstaben.
<P>
Wird ein Name angegeben, dann &auml;ndert SHOW() seine Funktion. Es gibt 1
zur&uuml;ck, wenn der unter Name angegebene Port gefunden wurde, und 0, wenn er
nicht gefunden wurde.
Beispiele im zweiten Kursteil unter 2.3.2
<P>
<FONT COLOR="#0000AA"><B><TT>SOURCELINE([Zeile])</TT></B></FONT><BR>
Liefert ohne Wertangabe die Zahl aller Zeilen im aktuellen Skript. Mit
Angabe einer Nummer liefert es einen String, in dem die Zeile mit der
entsprechenden Nummer steht.
<P>
<FONT COLOR="#0000AA"><B><TT>STORAGE(Addresse[,String,L&auml;nge,F&uuml;llzeichen])</TT></B></FONT><BR>
Schreibt den angegebenen String direkt in den Speicher. Ganz ohne Parameter
&uuml;bergibt die Funktion den freien Systemspeicher.
<P>
<FONT COLOR="#0000AA"><B><TT>SYMBOL(Name)</TT></B></FONT><BR>
Damit kann getestet werden, ob es sich bei Name um ein g&uuml;ltiges ARexx-
Symbol (z.B. eine Variable) handelt. Folgende R&uuml;ckgabewerte sind m&ouml;glich:
BAD     war nichts: kein ARexx-Symbol.
LIT     es handelt sich um ein uninitialisiertes Symbol (eine Variable, der
noch kein Wert zugewiesen wurde).
VAR     Eine Variable, der ein Wert zugewiesen wurde.
<P>
<FONT COLOR="#0000AA"><B><TT>TIME([Option])</TT></B></FONT><BR>
&Auml;hnlich wie DATE(), nur f&uuml;r die Uhrzeit. Folgende Optionen gibt es:
<PRE>
Civil     [h]h:mmxx (xx meint am oder pm)
Elapsed   Sekunden und Hundertstelsekunden seit der letzten Abfrage
Hours     Stunden seit Mitternacht
Minutes   Minuten seit Mitternacht
Normal    hh:mm:ss
Reset     wie Elapsed, l&ouml;scht aber danach den Timer.
Seconds   Sekunden seit Mitternacht
</PRE>
<P>
<FONT COLOR="#0000AA"><B><TT>TRACE(Option)</TT></B></FONT><BR>
Gibt die aktuelle Trace-Einstellung zur&uuml;ck oder &auml;ndert je nach Option diese
Einstellung.
<P>
<FONT COLOR="#0000AA"><B><TT>VALUE(Name)</TT></B></FONT><BR>
Gibt den Inhalt einer Variablen zur&uuml;ck. Das ist dann n&ouml;tig, wenn der
Variablenname selbst eine Variable ist:
<TABLE CELLSPACING=0 CELLPADDING=4 BORDER=0 BGCOLOR="#FFFFCC"><TR><TD ALIGN=LEFT VALIGN=TOP><FONT COLOR="#000055"><PRE>
a="Hoppla, ist das kompliziert"
b="a"
SAY VALUE(a)
SAY VALUE("a")
SAY VALUE(b)
</PRE></TD></TR></TABLE>
<P>
<H4>4.4. Ein paar Tips am Rande</H4>
Hier m&ouml;chte ich noch schnell ein paar Tips loswerden, die dem einen oder
der anderen von Euch vielleicht helfen k&ouml;nnen.
<P>
<H5>4.4.1. Start mit Piktogramm</H5>
Ein Piktogramm f&uuml;r ein ARexx-Skript ist mit den entsprechenden Programmen
schnell erstellt. Es sollte vom Typ "Projekt" sein und als Standardprogramm
einfach RX eingetragen haben. Dann steht einem Start per Doppelklick nicht
mehr viel im Weg (au&szlig;er vielleicht Programmfehlern...)
<P>
<H5>4.4.2. Start aus AmigaGuide</H5>
@{"hier" rx hier.rexx} gibt einen Link mit dem Wort "hier". Ein Klick
darauf startet das Skript "hier.rexx". Allerdings mu&szlig;t Du f&uuml;r Ausgabe von
Daten selber sorgen. ECHO funktioniert nicht so einfach. Aber Du hast ja
inzwischen gelernt, wie man Fenster &ouml;ffnet usw.
<P>
<H5>4.4.3. Anf&uuml;hrungszeichen</H5>
Anf&uuml;hrungszeichen sind eine heikle Geschichte in ARexx. Es gibt die zwei
Arten ' (Alt-&auml;) und ". Beide sind v&ouml;llig gleichbedeutend. Bei der
Interpretation wird immer das &auml;u&szlig;erste Paar weggenommen. Aus "'" wird ' und
umgekehrt. Und aus "Name" wird Name, was f&uuml;r ARexx ein g&uuml;ltiges Symbol
(eine Variable!) ist! Im Endeffekt hilft hier nur 'rumprobieren und vor
allem Tracen. Wenn was nicht funktioniert, mach mal noch ein paar
Anf&uuml;hrungszeichen au&szlig;enherum. Beachte au&szlig;erdem Gro&szlig;- und Kleinschreibung!
Au&szlig;erhalb von Anf&uuml;hrungszeichen macht ARexx so ziemlich alles
GROSS.
<P>
<H5>4.4.4. MUIRexx</H5>
MUIRexx ist ein Programm, das eine Schnittstelle zwischen ARexx und MUI
(Magic User Interface) bildet. Es ist sehr leistungsf&auml;hig. Ich bin selber
im Moment noch dabei, es zu verstehen, und hoffe, da&szlig; ich n&auml;chsten Monat
ein kleines Programm damit pr&auml;sentieren kann. Probiert's mal aus! Ebenfalls
im Aminet erh&auml;ltlich, genauso wie MUI.
<P>
<H5>4.4.5. Wordworth finden</H5>
Das ist gar nicht so einfach, denn jedes Fenster &ouml;ffnet einen eigenen Port!
Es gibt zwar auch noch den Port mit dem Namen WordworthLives, was
wahrscheinlich bedeuten soll: Wenn dieser Port existiert, dann ist auch
Wordworth aktiv. Aber sicher bin ich mir da nicht. Meine L&ouml;sung ist nicht
sehr elegant, das mu&szlig; ich zugeben. Aber sie funktioniert:
<P>
<TABLE CELLSPACING=0 CELLPADDING=4 BORDER=0 BGCOLOR="#FFFFCC"><TR><TD ALIGN=LEFT VALIGN=TOP><FONT COLOR="#000055"><PRE>
DO Num = 1 to 20
WwPort = "WORDWORTH." || Num
IF SHOW(PORTS, WwPort) THEN DO
Address Value WwPort
leave Num
end
end
if num=21 then do
echo "Wordworth nicht gefunden! Programm endet."
exit
end
</PRE></TD></TR></TABLE>
So, das waren nun fast alle ARexx-Befehle, die es gibt. Im n&auml;chsten und
letzten Kursteil werde ich einige wenige Befehle noch nachtragen und vor
allem ein paar kleine Beispiele daf&uuml;r geben, was mit ARexx alles m&ouml;glich
ist. Wer daf&uuml;r Ideen oder fertige Skripte hat: Ich bin f&uuml;r Vorschl&auml;ge und
Unterst&uuml;tzung offen!
<P>
Ein kurzes pers&ouml;nliches Wort an diejenigen, die im Lauf des letzten Monats
an mich geschrieben haben: Leider war ich im April sehr wenig zu Hause und
hatte dann sehr viel zu tun, so da&szlig; ich noch nicht dazu gekommen bin, auf
alles zu antworten. Ich werde aber alles noch beantworten! Vielen Dank f&uuml;r
Eure Geduld.
<P>
<H4>4.5. Zusammenfassung der neuen Befehle</H4>
<P>
<PRE>
ADDLIB(Name,Priorit&auml;t[,Offset,Version])
ADDRESS()
CALL
DATE(Option[,Datum,I|S])
ERRORTEXT()
EXIT
EXPORT(Addresse[,String,L&auml;nge,F&uuml;llzeichen])
FREESPACE([Addresse,L&auml;nge])
GETCLIP(Name)
GETSPACE(L&auml;nge)
HASH(String)
IMPORT(Adresse[,L&auml;nge])
PRAGMA(Option[,Wert])
PROCEDURE (EXPOSE)
REMLIB()
RETURN
SETCLIP(Name[,Wert])
SHOW(Option[,Name,Trennzeichen])
SOURCELINE([Zeile])
STORAGE(Addresse[,String,L&auml;nge,F&uuml;llzeichen])
SYMBOL(Name)
TIME([Option])
TRACE(Option)
VALUE(Name)
</PRE>
«
<P>


<P ALIGN=RIGHT>
<A HREF="0500.html"><IMG SRC="../menu/pfeil_links.gif" BORDER=0 WIDTH=20 HEIGHT=20></A>
<A HREF="0502.html"><IMG SRC="../menu/pfeil_rechts.gif" BORDER=0 WIDTH=20 HEIGHT=20></A>
</P>
</BODY>
</HTML>

<HTML>
<HEAD><TITLE>Workshops / Hintergrundberichte</TITLE></HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000AA" ALINK="#000066" VLINK="#000066">
<CENTER>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=1><TR><TD COLSPAN=2 VALIGN=TOP ALIGN=LEFT>
  <IMG SRC="../menu/title_amiga.gif" WIDTH=58 HEIGHT=20 BORDER=0>
</TD></TR>
<TR><TD VALIGN=TOP ALIGN=LEFT>
  <IMG SRC="../menu/title_aktuell.gif" WIDTH=9 HEIGHT=60 BORDER=0>
</TD><TD VALIGN=TOP ALIGN=CENTER>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=1 BGCOLOR="#000000"><TR>
<TD ROWSPAN=3 VALIGN=TOP>
<IMG SRC="../menu/empty.gif" BORDER=0 WIDTH=19 HEIGHT=15>
</TD><TD ROWSPAN=3 VALIGN=TOP>
<A HREF="../index.html"><IMG SRC="../menu/hauptseite.gif" BORDER=0 WIDTH=62 HEIGHT=15></A>
</TD><TD ROWSPAN=3 VALIGN=TOP>
<A HREF="0501.html"><IMG SRC="../menu/links.gif" BORDER=0 WIDTH=15 HEIGHT=15></A>
</TD><TD ROWSPAN=3 VALIGN=TOP>
<A HREF="0600.html"><IMG SRC="../menu/rechts.gif" BORDER=0 WIDTH=15 HEIGHT=15></A>
</TD><TD ROWSPAN=3>
<IMG SRC="../menu/empty.gif" BORDER=0 WIDTH=19 HEIGHT=15>
</TD><TD>
<A HREF="index.html"><IMG SRC="../menu/inhalt.gif" BORDER=0 WIDTH=37 HEIGHT=15></A>
</TD><TD>
<A HREF="0100.html"><IMG SRC="../menu/vorwort.gif" BORDER=0 WIDTH=47 HEIGHT=15></A>
</TD><TD>
<A HREF="0200.html"><IMG SRC="../menu/intern.gif" BORDER=0 WIDTH=37 HEIGHT=15></A>
</TD><TD>
<A HREF="0300.html"><IMG SRC="../menu/gewinnspiel.gif" BORDER=0 WIDTH=70 HEIGHT=15></A>
</TD><TD>
<A HREF="0400.html"><IMG SRC="../menu/forum.gif" BORDER=0 WIDTH=37 HEIGHT=15></A>
</TD><TD ROWSPAN=3 VALIGN=TOP>
<IMG SRC="../menu/empty.gif" BORDER=0 WIDTH=19 HEIGHT=15>
</TD></TR>

<TR><TD>
<A HREF="0500.html"><IMG SRC="../menu/workshops.gif" BORDER=0 WIDTH=62 HEIGHT=15></A>
</TD><TD>
<A HREF="0600.html"><IMG SRC="../menu/testberichte.gif" BORDER=0 WIDTH=70 HEIGHT=15></A>
</TD><TD>
<A HREF="0700.html"><IMG SRC="../menu/spieleteil.gif" BORDER=0 WIDTH=55 HEIGHT=15></A>
</TD><TD>
<A HREF="0800.html"><IMG SRC="../menu/amigainc.gif" BORDER=0 WIDTH=87 HEIGHT=15></A>
</TD><TD>
<A HREF="0900.html"><IMG SRC="../menu/poweruptodate.gif" BORDER=0 WIDTH=90 HEIGHT=15></A>
</TD>
</TR><TR>
<TD>
<A HREF="1000.html"><IMG SRC="../menu/produktankuendigungen.gif" BORDER=0 WIDTH=125 HEIGHT=15></A>
</TD><TD>
<A HREF="1100.html"><IMG SRC="../menu/diverses.gif" BORDER=0 WIDTH=50 HEIGHT=15></A>
</TD><TD>
<A HREF="1200.html"><IMG SRC="../menu/kurzmeldungen.gif" BORDER=0 WIDTH=85 HEIGHT=15></A>
</TD><TD>
<A HREF="1300.html"><IMG SRC="../menu/geruechte.gif" BORDER=0 WIDTH=52 HEIGHT=15></A>
</TD><TD>
<A HREF="1400.html"><IMG SRC="../menu/abschliessend.gif" BORDER=0 WIDTH=75 HEIGHT=15></A>
</TD></TR>
<TR><TD BGCOLOR="#EEEEEE" COLSPAN=11>
<H2 ALIGN=CENTER>Workshops / Hintergrundberichte</H2>
</TD></TR>
</TABLE>

</TD></TR>
</TABLE>
</CENTER>

<P>

<H3>3. ARexx-Kurs - Teil 3 (von Heiko Kuschel)</H3>
<P>
»<B>ARexx-Kurs: &Uuml;bersicht</B>
<P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=4><TR><TD BGCOLOR="#EEEEEE" VALIGN=TOP WIDTH=33%>
<B>1. Einf&uuml;hrung in ARexx.</B>
<OL><LI>
   Wie funktionierts?
</LI><LI>
   Was brauche ich?
</LI><LI>
   Installation
</LI><LI>
   ein erstes kleines Programm
</LI><LI>
   Ein- und Ausgabe
</LI><LI>
   do...end
<P>
</LI></OL>
</TD><TD BGCOLOR="#EEEEEE" VALIGN=TOP WIDTH=33%>
<B>2. Programmstruktur und Ansteuerung von anderen Programmen</B>
<OL><LI>
   if
</LI><LI>
   do...end
</LI><LI>
   address
</LI><LI>
   Tracing
<P>
</LI></OL>
</TD><TD BGCOLOR="#EEEEEE" VALIGN=TOP WIDTH=33%>
<FONT COLOR="#880000"><B>3. Ein- und Ausgabe; Funktionen</B>
<OL><LI>
   Ein- und Ausgabe
</LI><LI>
   Stringfunktionen
</LI><LI>
   mathematische Funktionen
</LI><LI>
   Konvertierungsfunktionen
</LI><LI>
   Bitmanipulation
<P>
</LI></OL>
</FONT>
</TD></TR><TR><TD BGCOLOR="#EEEEEE" VALIGN=TOP WIDTH=33%>
<B>4. komplexere Programmstrukturen</B>
<OL><LI>
   Operatoren
</LI><LI>
   Procedure
</LI><LI>
   Libraries
</LI><LI>
   sonstiges
<P>
</LI></OL>
</TD><TD BGCOLOR="#EEEEEE" VALIGN=TOP WIDTH=33%>
<B>5. Beispiele f&uuml;r die Vernetzung von Programmen</B>
<OL><LI>
   Wordworth
</LI><LI>
   GoldEd
</LI><LI>
   Database Professional
</LI><LI>
   YAM
</LI><LI>
   Miami
</LI><LI>
   usw.
<P>
</LI></OL>
</TD><TD BGCOLOR="#EEEEEE"></TD></TR></TABLE>
&Auml;nderungen vorbehalten. Spezielle W&uuml;nsche werden, wenn m&ouml;glich, gerne
aufgenommen.«
<P>
»<H3>3. Ein- und Ausgabe; Funktionen</H3>
<H4><B>3.0. Vorbemerkungen</B><BR></H4>
Hier wiederhole ich f&uuml;r Quereinsteiger noch einmal einen Teil der
Vorbemerkungen, die ich zum ganzen Kurs gemacht habe.
<P>
Der Kurs wird als reine Text-Datei angefertigt, da auch Amiga aktuell u.a.
in ASCII-Form verschickt wird. Um den Text etwas zu gliedern, habe ich
daher ein paar "Textmarker" eingef&uuml;gt.
<P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=4 BGCOLOR="#000000"><TR><TD BGCOLOR="#EEEEEE">
<TT>**********</TT></FONT> unterteilt einzelne Abschnitte
<P>
<TT>__________</TT></FONT> bezeichnet Beginn und Ende eines ARexx-Programms. Die Striche
geh&ouml;ren nicht zum Programm!<BR>
</TD></TR><TR><TD BGCOLOR="#CCCCFF">
<SMALL>Anmerkung: In der HTML-Version verwenden wir selbstverst&auml;ndlich
entsprechende Formatierungen statt der Zeichenfolgen "***..." und "___...".</SMALL>
</TD></TR></TABLE>
<BR>
ARexx-Befehle werden in diesem Kurs immer GROSS geschrieben, obwohl das
eigentlich nicht n&ouml;tig ist. Auf diese Weise kann man sie aber leichter
erkennen.
<P>
Ich hoffe, da&szlig; diese Regelung den Kurs etwas leserlicher macht.
<P>
Wenn Ihr spezielle Fragen habt, etwas nicht verstanden habt oder Anregungen
und Ideen f&uuml;r weitere Kursteile habt, k&ouml;nnt Ihr euch gerne an mich wenden.
Ich selbst benutze folgende ARexx-f&auml;hige Programme und kann daher auf deren
Programmierung kurz eingehen, wenn das gew&uuml;nscht wird:
Wordworth, GoldEd, Database Professional, YAM, Miami, Voyager, TurboCalc.
<P>
Hier meine Kontaktadresse:
<P>
Heiko Kuschel<BR>
Lehmgrubenweg 13<BR>
97280 Remlingen<BR>
E-Mail: <A HREF="mailto:hk0006@wuerzburg.baynet.de">hk0006@wuerzburg.baynet.de</A>
<P>
Und jetzt... viel Spa&szlig; mit ARexx!
<P>

<H4><B>3.1. Ein- und Ausgabefunktionen</B></H4>

Heute m&ouml;chte ich Euch eine ganze Menge Funktionen von ARexx vorstellen.
Viele sind sehr &auml;hnlich in Aufbau und Funktion, daher werde ich in diesem
Kursteil nicht f&uuml;r jede Funktion ein Beispiel bringen, sondern statt dessen
nur ein, zwei jeweils ausf&uuml;hrlicher erkl&auml;ren.
Es geht heute verst&auml;rkt darum, mit Variablen zu "jonglieren", mit dem/der
BenutzerIn zu kommunizieren, Ausgaben zu machen usw.
Nat&uuml;rlich kennen wir schon einen Befehl zur Ausgabe von Text, n&auml;mlich ECHO.
Und der f&uuml;r die Eingabe lautet PARSE PULL bzw. PULL.
Nur: Damit kann ich &uuml;berhaupt nicht definieren, wie mein Ein-
/Ausgabefenster beschaffen sein soll. Und wenn das ARexx-Skript aus einem
Programm heraus gestartet wird, kann es sein, da&szlig; &uuml;berhaupt nichts zu sehen
ist, weil die Ausgabe des Skripts irgendwohin geleitet wird (z.B. nach
NIL:, das "Nimmerwiedersehen-Ger&auml;t").
Und vielleicht mu&szlig; ich ja auch einmal eine Zeile oder ein Zeichen aus einer
Datei lesen...
<P>
F&uuml;r alle diese F&auml;lle gibt es die M&ouml;glichkeit, Dateien zu &ouml;ffnen und zu
schlie&szlig;en. Sinnvollerweise mit der Funktion OPEN().
<P>
<FONT COLOR="#000077"><TT>Erfolg=OPEN(Test,"Text:Golded/Amigaaktuell/ARexx-Kurs/03.txt","R")</TT></FONT>
<P>
&ouml;ffnet diesen Text zum Lesen (R) und weist der Variable Erfolg den Wert 1
zu, wenn die Operation Erfolg hatte, und 0, wenn ein Fehler aufgetreten ist
(z.B., weil ich eine Verzeichnisebene ausgelassen habe... :-) ).
Die Datei kann jetzt unter dem Namen Test mit anderen Befehlen (keine
Angst, die kommen gleich!) angesprochen werden. Das ist der sogenannte
logische Dateiname.
Es gibt folgende Optionen:
<FONT COLOR="#000077"><PRE>R (Read)   -  Lesen
W (Write)  -  Schreiben (Achtung: Eine evtl. vorhandene Datei wird gel&ouml;scht!)
A (Append) -  Anh&auml;ngen
</PRE></FONT>
<P>
So, jetzt haben wir also eine Datei (hoffentlich) erfolgreich ge&ouml;ffnet.
Statt einer Datei kann man mit OPEN() auch ein AmigaDos-Device &ouml;ffnen, z.B.
ein Konsolenfenster (CON:, oder f&uuml;r besondere F&auml;lle, s.u., RAW:).
<P>
Was k&ouml;nnen wir mit der ge&ouml;ffneten Datei nun alles anfangen?
<P>
Wir k&ouml;nnen ein oder mehrere Zeichen aus der Datei lesen:
Zeichen=READCH(Test,Anzahl)
Vorsicht! Die Funktion wartet, bis so viele Zeichen wie angegeben
eingetrudelt sind!
<P>
Wir k&ouml;nnen eine ganze Zeile (bis zum n&auml;chsten Absatzendezeichen) lesen:<BR>
<FONT COLOR="#000077"><TT>Zeile=READLN(Test)</TT></FONT>
<P>
Das gleiche gibt's nat&uuml;rlich auch zum Schreiben in die Datei:
<FONT COLOR="#000077"><PRE>Ergebnis=WRITECH(Test,"Das hier soll in meine Datei geschrieben werden")
Ergebnis=WRITELN(Test,"Das hier soll in meine Datei geschrieben werden")</PRE></FONT>
Im zweiten Fall wird am Schlu&szlig; ein Absatzendezeichen angef&uuml;gt.
<P>
Zum besseren Merken:
<FONT COLOR="#000077"><PRE>READ  hei&szlig;t Lesen
WRITE hei&szlig;t Schreiben.
CH    steht f&uuml;r Char, d.h. Zeichen.
LN    steht f&uuml;r Line, d.h. Zeile.</PRE></FONT>
<P>
Wenn ich nun eine Weile aus der Datei gelesen habe, kann es ja passieren,
da&szlig; mir irgendwann die Zeichen ausgehen, weil die Datei zu Ende ist. Das
kann ich &uuml;berpr&uuml;fen, indem ich folgenden Befehl anwende:
<BR><FONT COLOR="#000077"><TT>Erfolg=EOF(Test)</TT></FONT><BR>
ergibt 1, wenn das Dateiende erreicht ist, ansonsten 0.
<P>
... man kann statt dessen auch die Zeilen z&auml;hlen, und zwar mit der Funktion
<BR><FONT COLOR="#000077"><TT>Ergebnis=LINES(Test)</TT></FONT><BR>
Das gibt allerdings die Zeilen zur&uuml;ck, die im Eingabepuffer stehen, ohne
Angabe eines Namens die Anzahl der Zeilen, die in <FONT COLOR="#000077"><TT>STDIN</TT></FONT> stehen.
<P>
Unter Umst&auml;nden kann es nat&uuml;rlich auch sinnvoll sein, den Zeiger auf ein
anderes Zeichen innerhalb der Datei zu verschieben. Das geht zeichenweise
vor sich, man sollte also genau wissen, wie die Datei aufgebaut ist.
<BR><FONT COLOR="#000077"><TT>NeuePosition=SEEK(Test,Offset,Modus)</TT></FONT><BR>
Offset bedeutet die Anzahl der Zeichen, die weitergegangen werden soll.
Modus kann folgendes sein:
<FONT COLOR="#000077"><PRE>B - Begin
C - Current (momentane Position)
E - End</PRE></FONT>
und besagt, worauf sich der Offset bezieht.
Vorsicht mit Offsets, die &uuml;ber das Dateiende hinausgehen!
<P>
Wie w&auml;re es, das Ganze nun einmal mit einer Eingabekonsole zu versuchen?
Unser gutes altes HelloWorld aus dem ersten Kursteil, aufgepeppt mit einer
selber ge&ouml;ffneten Konsole:
<P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=4><TR><TD BGCOLOR="#EEEEEE">
<FONT COLOR="#000077"><PRE>/* Hello World Version 1.5.*/
<P>
Erfolg=OPEN(Fenster,'CON:20/20/620/100/Hello World 1.5./CLOSE',R)
IF ~Erfolg THEN ECHO "Fehler!"
<P>
DO WHILE Eingabe~="Ende"
Erfolg=WRITELN(Fenster,"Gib was ein!")
Eingabe=READLN(Fenster)
Erfolg=WRITELN(Fenster,"Du hast "||Eingabe||" eingegeben.")
END</PRE></FONT>
</TD></TR></TABLE>

<P>
Es reicht auch, einfach nur CON: einzugeben. Dann kannst Du allerdings
Position und Titel des Fensters nicht beeinflussen.
Im Unterschied zu CON: gibt RAW: jeden Tastendruck sofort weiter. Es mu&szlig;
nicht erst die Return-Taste gedr&uuml;ckt werden.
Auf diese Weise kann man auch abfragen, ob eine bestimmte Taste gedr&uuml;ckt
wurde.
<P>

<H4><B>3.2. Stringfunktionen</B></H4>

<P>
Oft braucht man von einer Zeichenkette nur einen Teil, vielleicht den
Vornamen, wo doch der ganze Name in einer Variablen gespeichert ist o.&auml;.
Zur Behandlung von Zeichenketten gibt es in ARexx eine gro&szlig;e Anzahl von
Funktionen. Zwei davon haben wir schon im letzten Teil kurz angesprochen:
<P>
<FONT COLOR="#000077"><TT>LASTPOS(Buchstabe,Zeichenkette)</TT></FONT><BR>
gibt die Position des Buchstabens an, an der er zum letzten Mal in einer
Zeichenkette auftritt

<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=4><TR><TD BGCOLOR="#EEEEEE">
<FONT COLOR="#000077"><PRE>Position=LASTPOS("e","Heiko Kuschel")
ECHO Position
</PRE></FONT>
</TD></TR></TABLE>

ergibt 11.
<BR>
<FONT COLOR="#000077"><TT>LEFT(Zeichenkette,Zahl)</TT></FONT>
ergibt den linken Teil einer Zeichenkette, bis zum xten Zeichen.

<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=4><TR><TD BGCOLOR="#EEEEEE">
<FONT COLOR="#000077"><PRE>ECHO LEFT("Heiko Kuschel",6)
</PRE></FONT>
</TD></TR></TABLE>

ergibt "Heiko".
<P>
Genauso sind alle anderen Stringfunktionen auch aufgebaut, die ich hier
einfach mal aufliste:
<P>
<FONT COLOR="#000077"><TT>ABBREV(Lang,Kurz,L&auml;nge)</TT></FONT>
<P>
Testet, ob Kurz eine Abk&uuml;rzung (abbreviation) von Lang ist. Optional kann
auch noch eine Anzahl von Zeichen angegeben werden, bis zu der verglichen
werden soll.
Liefert 0 (falsch) oder 1 (wahr)
<P>
<FONT COLOR="#000077"><TT>CENTER(Text,L&auml;nge,F&uuml;llzeichen)<BR>
CENTRE(Text,L&auml;nge,F&uuml;llzeichen)</TT></FONT>
<P>
Liefert einen String, der die in L&auml;nge angegebene Zahl von Zeichen hat.
Optional kann ein F&uuml;llzeichen angegeben werden.
<FONT COLOR="#000077"><PRE>ECHO CENTRE("TesttextTesttext",4)
XTTE
ECHO CENTRE("TesttextTesttext",20)
TESTTEXTTESTTEXT
ECHO CENTRE("TesttextTesttext",20,".")
..TESTTEXTTESTTEXT..
ECHO CENTRE("TesttextTesttext",40,".")
............TESTTEXTTESTTEXT............
</PRE></FONT>
<P>
<FONT COLOR="#000077"><TT>COMPRESS(String[,Liste])</TT></FONT>
<P>
Entfernt die in Liste angegebenen Zeichen aus einer Zeichenkette. Wird
Liste nicht angegeben, entfernt es alle Leerzeichen.
<BR><FONT COLOR="#000077"><TT>ECHO COMPRESS("Haeaikgog Kausgchael","ag")</TT></FONT>
<P>
<FONT COLOR="#000077"><TT>COMPARE(Text1,Text2[,F&uuml;llzeichen])</TT></FONT>
<P>
Gibt die erste Stelle zur&uuml;ck, an der sich die beiden Texte unterscheiden.
Optional kann angegeben werden, mit welchem F&uuml;llzeichen der k&uuml;rzere der
Texte aufgef&uuml;llt werden soll, wenn die zwei nicht gleich lang sind.
Voreingestellt sind Leerzeichen.
<P>
<FONT COLOR="#000077"><TT>COPIES(Zeichenkette,Anzahl)</TT></FONT>
<P>
Gibt Zeichenkette so oft aus, wie Du willst. Nur negativ darf die Zahl
nicht sein.
<P>
<FONT COLOR="#000077"><TT>DATATYPE(Zeichenkette[,Typ])</TT></FONT>
<P>
Gibt NUM als Ergebnis zur&uuml;ck, wenn Zeichenkette eine g&uuml;ltige Zahl ist,
ansonsten CHAR.
Wird ein Typ angegeben, dann kann auf diesen Typ gepr&uuml;ft werden. Ergebnis
ist in diesem Fall 0 oder 1.
Folgende Typen gibt's:
<FONT COLOR="#000077"><PRE>Alphanumeric A-Z, a-z, 0-9
Binary       Bin&auml;r-String
Lowercase    a-z
Mixed        A-Z, a-z
Upper        A-Z
Numeric      Zahl
Symbol       ARexx-Symbol
Whole        ganze Zahl
X            Hexadezimalstring
</PRE></FONT>
<P>
<FONT COLOR="#000077"><TT>DELSTR(Zeichenkette,Pos[,L&auml;nge])</TT></FONT>
<P>
Diese Funktion schneidet von Zeichenkette alles ab dem Buchstaben mit der
Nummer ab, die in Pos angegeben ist. Wird L&auml;nge mit angegeben, so wird ab
Pos ein Teilstring "herausgeschnitten".
<P>
<FONT COLOR="#000077"><TT>DELWORD(Zeichenkette, Pos[,Anzahl])</TT></FONT>
<P>
&Auml;hnlich wie <FONT COLOR="#000077"><TT>DELSTR</TT></FONT>, nur geht's hier um ganze W&ouml;rter.
<P>
<FONT COLOR="#000077"><TT>FIND(Zeichenkette,Worte)</TT></FONT>
<P>
Gibt die Anfangsposition der Worte in der Zeichenkette zur&uuml;ck. 0, wenn
nicht gefunden.
<FONT COLOR="#000077"><PRE>ECHO FIND("Heiko Kuschel", "Kuschel")
2</PRE></FONT>
<P>
<FONT COLOR="#000077"><TT>INDEX(Zeichenkette,Muster[,Start])</TT></FONT>
<P>
Sucht nach dem ersten Auftreten von Muster in Zeichenkette und gibt die
Position aus. 0, wenn nicht gefunden. Eine Startposition kann auch
angegeben werden.
<BR>
Gleichbedeutend damit ist POS(). INDEX() existiert allerdings nur auf der
Amiga-Version von REXX.
<P>
<FONT COLOR="#000077"><TT>INSERT(Quellstring,Zielstring[,Start,L&auml;nge,F&uuml;llzeichen])</TT></FONT>
<P>
F&uuml;gt den Quellstring ab der Startposition in den Zielstring ein. Wenn eine
L&auml;nge angegeben ist, kann sie auch mit F&uuml;llzeichen erreicht werden.
<FONT COLOR="#000077"><PRE>
ECHO INSERT("ARexx-Kurs ","Ein ist eine klasse Sache",4)
EIN AREXX-KURS IST EINE KLASSE SACHE
Vorsicht: Die F&uuml;llzeichen werden an den Quellstring angeh&auml;ngt:
ECHO INSERT("ARexx-Kurs ","Ein ist eine klasse Sache",4,30,"!")
EIN AREXX-KURS !!!!!!!!!!!!!!!!!!!IST EINE KLASSE SACHE
</PRE></FONT>
<P>
<FONT COLOR="#000077"><TT>LASTPOS(Muster, Zeichenkette[,Start])</TT></FONT>
<P>
Wie <FONT COLOR="#000077"><TT>POS()</TT></FONT> bzw. <FONT COLOR="#000077"><TT>INDEX()</TT></FONT>, nur von hinten.
<P>
<FONT COLOR="#000077"><TT>LEFT(Zeichenkette,L&auml;nge[,F&uuml;llzeichen])</TT></FONT>
<P>
Gibt den linken Teil der Zeichenkette zur&uuml;ck, der L&auml;nge lang ist. Evtl.
kann mit F&uuml;llzeichen aufgef&uuml;llt werden, falls die Zeichenkette k&uuml;rzer ist
als die Zahl, die in L&auml;nge steht.
<P>
<FONT COLOR="#000077"><TT>LENGTH(Zeichenkette)</TT></FONT>
<P>
Gibt die L&auml;nge in Zeichen zur&uuml;ck
<P>
<FONT COLOR="#000077"><TT>OVERLAY(Quelle, Ziel[,Start,L&auml;nge,F&uuml;llzeichen])</TT></FONT>
<P>
Damit wird eine Zeichenkette &uuml;ber eine andere gelegt. Im Gegensatz zu
INSERT() geht dabei ein Teil des Zielstrings verloren. Das entspricht so
ungef&auml;hr dem &Uuml;berschreib-Modus in einem Editor oder einer Textverarbeitung.
<P>
<FONT COLOR="#000077"><TT>POS()</TT></FONT><BR>
ist gleichbedeutend mit INDEX()
<P>
<FONT COLOR="#000077"><TT>REVERSE(Zeichenkette)</TT></FONT><BR>
Dreht die Zeichenkette um. Aus ARexx wird xxeRA.
<P>
<FONT COLOR="#000077"><TT>RIGHT(Zeichenkette,L&auml;nge[,F&uuml;llzeichen])</TT></FONT><BR>
Wie LEFT(), nur da&szlig; der rechte Teil abgeschnitten wird.
<P>
<FONT COLOR="#000077"><TT>SPACE(Zeichenkette, Zahl[,F&uuml;llzeichen])</TT></FONT>
<P>
Damit k&ouml;nnen zwischen einzelnen W&ouml;rtern im String beliebig viele
Leerzeichen (oder andere F&uuml;llzeichen) eingef&uuml;gt werden.
<P>
<FONT COLOR="#000077"><TT>STRIP(Zeichenkette[,B|L|T,Zeichen])</TT></FONT>
<P>
... und damit kannst Du sie wieder entfernen.
Optional k&ouml;nnen auch nur die vorangestellten oder nachfolgenden (Leer-)
Zeichen entfernt werden.
<FONT COLOR="#000077"><PRE>L steht f&uuml;r Leading (vorangestellte)
T steht f&uuml;r Trailing (nachgestellte)
B steht f&uuml;r Both (beides) und ist voreingestellt.</PRE></FONT>
<P>
<FONT COLOR="#000077"><TT>SUBSTR(Zeichenkette,Start[,L&auml;nge,F&uuml;llzeichen])</TT></FONT>
<P>
Damit kann ein Teilstring aus einer Zeichenkette &uuml;bernommen werden, und
zwar ab Position Start, optional mit angegebener L&auml;nge und F&uuml;llzeichen.
<P>
<FONT COLOR="#000077"><TT>SUBWORD(Zeichenkette,Start[,Anzahl])</TT></FONT>
<P>
&Auml;hnlich wie SUBSTR(), nur mit ganzen W&ouml;rtern.
<P>
<FONT COLOR="#000077"><TT>TRANSLATE(Zeichenkette[,rein,raus,F&uuml;llzeichen])</TT></FONT>
<P>
Leider kann dieser Befehl nichts in andere Sprachen &uuml;bersetzen... aber
praktisch kann er trotzdem sein.
<BR>
Er vergleicht die in raus angegebenen Zeichen mit der Zeichenkette. Findet
er eines, ersetzt er es durch das Zeichen, das in rein an gleicher Stelle
angegeben ist. Ist rein daf&uuml;r zu kurz, nimmt er ein Leerzeichen oder das
optional angegebene F&uuml;llzeichen. Hmmmh. Kapiert? Vielleicht einmal ein
Beispiel:
<FONT COLOR="#000077"><PRE>ECHO TRANSLATE("Hioku Kaschil","aeiou","eioua")
HEIKO KUSCHEL
ECHO TRANSLATE("Amiga 1200","60","12")
AMIGA 6000</PRE></FONT>
<P>
<FONT COLOR="#000077"><TT>TRIM(Zeichenkette)</TT></FONT>
<P>
entfernt alle nachgestellten Leerzeichen in der Zeichenkette.
<P>
<FONT COLOR="#000077"><TT>UPPER(Zeichenkette)</TT></FONT>
<P>
Wandelt alles in GROSSBUCHSTABEN um. Als ob ARexx das nicht sowieso schon
dauernd tun w&uuml;rde...
<P>
<FONT COLOR="#000077"><TT>VERIFY(Zeichenkette,Liste[,M|N,Startposition])</TT></FONT>
<P>
&Uuml;berpr&uuml;ft, ob Zeichenkette nur Zeichen aus der Liste enth&auml;lt. Wenn ja, ist
das Ergebnis 0, ansonsten die erste Position, an der ein fremdes Zeichen
gefunden wurde. Durch Angabe einer Startposition f&uuml;r die Suche kann man
dann auch weiter hinten stehende "falsche" Zeichen finden.
<BR>
N steht f&uuml;r NOMATCH und ist voreingestellt, d.h., es wird nach Zeichen
gesucht, die *nicht* vorkommen.
<BR>
Mit M (MATCH) wird dann nach Zeichen gesucht, die in der Zeichenkette
vorkommen.
<P>
<FONT COLOR="#000077"><TT>WORD(Zeichenkette,x)</TT></FONT>
<P>
Gibt das x-te Wort aus der Zeichenkette aus, oder eine leere Zeichenkette,
wenn so viele W&ouml;rter gar nicht vorhanden sind.
<P>
<FONT COLOR="#000077"><TT>WORDINDEX(Zeichenkette,Zahl)</TT></FONT>
<P>
Gibt die Position in Zeichen aus, an der das x-te Wort steht.
<FONT COLOR="#000077"><PRE>ECHO WORDINDEX("Das ist ein kleines Beispiel",4)
13</PRE></FONT>
Das hei&szlig;t: Das vierte Wort beginnt mit dem 13. Buchstaben.
<P>
<FONT COLOR="#000077"><TT>WORDLENGTH(Zeichenkette,Zahl)</TT></FONT>
<P>
Gibt die L&auml;nge des an Nummer Zahl stehenden Wortes zur&uuml;ck, oder 0, wenn es
nicht so viele W&ouml;rter gibt.
<P>
<FONT COLOR="#000077"><TT>WORDS(Zeichenkette)</TT></FONT>
<P>
Liefert nat&uuml;rlich die Anzahl der W&ouml;rter.
<P>
<FONT COLOR="#000077"><TT>XRANGE([Start,Ende])</TT></FONT>
<P>
Liefert eine Zeichenkette, die alle ASCII-Codes von Start bis Ende enth&auml;lt.
Voreingestellt ist 0 bis 255.
<P>
Uff, das war's. Eine lange, ziemlich trockene Liste. Aber irgendwann mu&szlig;
ich Euch die ganzen Befehle ja mal sagen...
Und deswegen geht's jetzt gleich noch weiter:
<P>

<H4><B>3.3. mathematische Funktionen</B></H4>

<P>
Keine Angst, das sind nicht ganz so viele!
<P>
<FONT COLOR="#000077"><TT>ABS(Zahl)</TT></FONT><BR>
Gibt den absoluten Wert einer Zahl zur&uuml;ck. V&ouml;llig unmathematisch
ausgedr&uuml;ckt: Entfernt das Minuszeichen vor der Zahl, wenn eins vorhanden
ist
<P>
<FONT COLOR="#000077"><TT>DIGITS()<BR>
FORM()<BR>
FUZZ()</TT></FONT>
<P>
Diese Funktionen liefern die gerade eingestellten Werte f&uuml;r NUMERIC, der
gleich noch besprochen werden soll.
<P>
<FONT COLOR="#000077"><TT>MAX(Zahl1,Zahl2[,Zahl3,...])</TT></FONT><BR>
liefert die gr&ouml;&szlig;te dieser Zahlen
<P>
<FONT COLOR="#000077"><TT>MIN(Zahl1,Zahl2[,Zahl3,...])</TT></FONT><BR>
liefert die kleinste dieser Zahlen
<P>
<FONT COLOR="#000077"><TT>RANDOM([MIN,MAX,STARTWERT])</TT></FONT><BR>
<P>
Liefert eine Zufallszahl, optional kann eine kleinste und gr&ouml;&szlig;te Zahl
angegeben werden. Als voreingestellter Startwert wird die Systemzeit
verwendet. Wenn Du immer die gleiche Abfolge von Zufallszahlen haben
willst, kannst Du einen Startwert angeben, der statt der Systemzeit
verwendet wird.
<BR>
Anmerkung: Zufallszahlen zu erzeugen, ist mit einem Computer praktisch
unm&ouml;glich. Denn ein Computer arbeitet mit mathematischen Formeln, und deren
Ergebnis ist immer gleich. Deshalb nimmt man eine Formel, bei der die
n&auml;chste Zahl nicht so ohne weiteres vorhersehbar ist und bei der die
Ergebnisse halbwegs gleichm&auml;&szlig;ig &uuml;ber alle Zahlen verteilt sind, und f&uuml;ttert
sie mit einem Startwert, der weitgehend zuf&auml;llig ist, n&auml;mlich der
Systemzeit zum Zeitpunkt des ersten Aufrufs dieser Funktion. Wird dagegen
immer der gleiche Startwert genommen, kommt auch immer die gleiche Folge
von Zahlen heraus. Auch das kann n&uuml;tzlich sein, wenn man einen immer
gleichen Ablauf haben will.
<P>
<FONT COLOR="#000077"><TT>RANDU([Startwert])</TT></FONT>
<P>
Wie RANDOM(), nur da&szlig; der R&uuml;ckgabewert immer zwischen 0 und 1 liegt. Die
Zahl der Nachkommastellen wird mit NUMERIC DIGITS bestimmt (s.u.).
<P>
<FONT COLOR="#000077"><TT>SIGN(Zahl)</TT></FONT>
<P>
liefert das Vorzeichen der Zahl oder 0 f&uuml;r 0.
<P>
<FONT COLOR="#000077"><TT>TRUNC(Zahl[,Stellen])</TT></FONT>
<P>
Schneidet die Nachkommastellen ab (rundet nicht!). Optional kann eine
Anzahl von Nachkommastellen angegeben werden.
<P>
Nun brauchen wir noch den NUMERIC-Befehl, der schon ein paar Mal
angesprochen wurde. Er hat die folgenden Optionen:
<P>
<FONT COLOR="#000077"><TT>NUMERIC DIGITS Zahl</TT></FONT><BR>
Stellt ein, wie viele Stellen bei einer numerischen Operation
signifikant sind (1-14).
Ist die Zahl l&auml;nger, wird die Exponentialschreibweise verwendet, z.B.
2.122E+3
<FONT COLOR="#000077"><TT>NUMERIC FUZZ Zahl</TT></FONT><BR>
Stellt ein, wie viele Stellen (von rechts) bei Vergleichsoperationen
*nicht* ber&uuml;cksichtigt werden sollen.
<FONT COLOR="#000077"><TT>NUMERIC FORM (Scientific|Engineering)</TT></FONT><BR>
Stellt die Form der Exponentialschreibweise ein. Da gibt es einen
Unterschied zwischen akademischer und Ingenieursschreibweise, der mir
allerdings nicht klar ist.
<P>

<H4><B>3.4. Konvertierungen</B></H4>

<P>
Jetzt brauchen wir nat&uuml;rlich noch die M&ouml;glichkeit, z.B. Zahlen in
Zeichenketten zu verwandeln usw.
<BR>
Daf&uuml;r gibt es in ARexx ein sehr einfaches System von Funktionen: Jede "Art"
von Zeichen hat einen Buchstaben:
<FONT COLOR="#000077"><PRE>B - Bin&auml;r
C - Character (Buchstaben)
D - Dezimal
X - hexadezimal
</PRE></FONT>
<P>
... und "2" steht im Englischen manchmal f&uuml;r "to", weil's genauso
ausgesprochen wird.
<P>
Also:
<P>
<FONT COLOR="#000077"><PRE>
ECHO B2C("00100010 01101001")
"i
</PRE></FONT>
Gibt die Zeichen aus, die im ASCII-Code den hier angegebenen Bin&auml;rzahlen
entsprechen.
<P>
Leider sind nicht alle Konvertierungsm&ouml;glichkeiten vorhanden, nur die
folgenden:
<FONT COLOR="#000077"><PRE>B2C()
C2B()
C2D()
C2X()
D2C()
D2X()
X2C()
X2D()</PRE></FONT>
<P>
Bei <FONT COLOR="#000077"><TT>C2D</TT></FONT> darf die Zeichenkette, die &uuml;bergeben wird, maximal 4 Zeichen
enthalten. Sie darf auch ein Hex-String, z.B. "FFFF"x oder ein Bin&auml;rstring,
z.B. "0011"b sein.
<BR>
Optional kann bei C2D() ein Argument angegeben werden:
<BR><FONT COLOR="#000077"><TT>C2D("FFFF"x,2)</TT></FONT></BR>
In diesem Fall wird der Bin&auml;rwert der Zeichenkette als Zweierkomplement von
2 Bytes L&auml;nge behandelt. So kann man auch vorzeichenbehaftete Zahlen
erzeugen.
<P>
Bei <FONT COLOR="#000077"><TT>D2C(Zahl[,Bytes])</TT></FONT> kann ebenfalls ein zus&auml;tzlicher Wert angegeben
werden. Er bewirkt, da&szlig; das Ergebnis die entsprechende L&auml;nge hat und
entweder links abgeschnitten oder mit "00"x aufgef&uuml;llt wird.
<P>
Bei <FONT COLOR="#000077"><TT>D2X() und X2D()</TT></FONT> kann die Zahl von Nibbles (4 Bits, also 2 Nibbles= 1
Byte) angegeben werden, damit auch negative Zahlen dargestellt werden
k&ouml;nnen.
<FONT COLOR="#000077"><PRE>ECHO X2D("FFE0",4)
-32
ECHO X2D("FFE0",6)
65504
ECHO X2D("FFE0")
65504</PRE></FONT>
<P>

<H4><B>3.5. Bitmanipulation</B></H4>

<P>
Noch ein paar Funktionen zur Bitmanipulation, mehr der Vollst&auml;ndigkeit
halber.
<BR>
Bin&auml;rzahlen werden in ARexx folgenderma&szlig;en geschrieben: "00010000"b
Leerzeichen d&uuml;rfen nur an den Byte-Grenzen eingef&uuml;gt werden!
<P>
Folgende Funktionen gibt es:
<P>
<FONT COLOR="#000077"><TT>BITAND(BitStr1[,BitStr2,F&uuml;llzeichen])</TT></FONT>
<P>
ergibt eine UND-Verkn&uuml;pfung der Bit-Strings. Die Funktion arbeitet nicht
korrekt, wenn die Strings unterschiedlich lang sind, da dann mit
Leerzeichen aufgef&uuml;llt wird! Dann mu&szlig; das richtige F&uuml;llzeichen gew&auml;hlt
werden, was auch nicht ganz problemlos ist.
<FONT COLOR="#000077"><PRE>ECHO C2B(BITAND("01010001"b,"11101110"b))
01000000</PRE></FONT>
<P>
zu UND, ODER etc. vgl. unten!
<P>
<FONT COLOR="#000077"><TT>BITCHG(BitString,Bit)</TT></FONT>
<P>
Invertiert das Bit an der angegebenen Stelle. Gez&auml;hlt werden die Bits von
rechts nach links!
<P>
<FONT COLOR="#000077"><TT>BITCLR(BitString,Bit)</TT></FONT>
<P>
L&ouml;scht das angegebene Bit.
<P>
<FONT COLOR="#000077"><TT>BITCOMP(BitStr1,Bitstr2[,F&uuml;llzeichen])</TT></FONT>
<P>
Vergleicht die beiden Bitstrings und liefert 0, wenn sie gleich sind,
ansonsten die erste Position, an der sie sich unterscheiden. Sind die
Strings nicht gleich lang, wird der k&uuml;rzere am linken Ende mit F&uuml;llzeichen
aufgef&uuml;llt.
<P>
<FONT COLOR="#000077"><TT>BITOR(BitStr1[,BitStr2,F&uuml;llzeichen])</TT></FONT>
<P>
ergibt eine ODER-Verkn&uuml;pfung der Bit-Strings. Ansonsten wie bei <FONT COLOR="#000077"><TT>BITAND()</TT></FONT>.
<P>
<FONT COLOR="#000077"><TT>BITSET(BitString,Bit)</TT></FONT>
<P>
Setzt das angegebene Bit auf 1.
<P>
<FONT COLOR="#000077"><TT>BITTST(BitString,Bit)</TT></FONT>
<P>
Testet, ob das angegebene Bit gesetzt ist. Liefert 1, wenn ja, sonst 0.
<P>
<FONT COLOR="#000077"><TT>BITXOR(BitStr1[,BitStr2,F&uuml;llzeichen])</TT></FONT>
<P>
ergibt eine Exklusiv-ODER-Verkn&uuml;pfung der Bit-Strings. Ansonsten wie bei
<FONT COLOR="#000077"><TT>BITAND()</TT></FONT>.
<P>
Was bedeutet UND-, ODER- etc. Verkn&uuml;pfung?<BR>
Ganz einfach: zwei Bits (also einzelne Speicherstellen) werden miteinander
verglichen, und abh&auml;ngig von ihrem Zustand (0 oder 1) kommt es zu einem
Ergebnis.
Das geht nach folgender Tabelle:
<P>
<FONT COLOR="#000077"><PRE>Bit 1 |  0   1   0   1 |  Vergleich
Bit 2 |  0   0   1   1 |
______|________________|____________
UND   |  0   0   0   1 |  Ergebnis
ODER  |  0   1   1   1 |
XODER |  0   1   1   0 |</PRE></FONT>
<P>

<H4><B>3.6. Zusammenfassung</B></H4>

<P>
So, das war heute eine riesige F&uuml;lle von Befehlen. Leider ist dieser
Kursteil dadurch etwas trockener geworden als die ersten zwei. Ich hoffe,
Ihr verkraftet es und probiert nun selbst ein bi&szlig;chen herum.
Hier noch einmal die Zusammenfassung aller Befehle und Funktionen dieses
Kursteils:
<P>
<B>Ein-/Ausgabe:</B><BR>
<FONT COLOR="#000077"><PRE>
EOF(LogName)
LINES(LogName)
OPEN(LogName,Pfad,"R"|"W"|"A")
READCH(LogName,Anzahl)
READLN(LogName)
SEEK(LogName,Offset,Modus)
WRITECH(LogName,Text)
WRITELN(LogName,Text)
</PRE></FONT>
<P>
<B>Zeichenketten:</B><BR>
<FONT COLOR="#000077"><PRE>
ABBREV(Lang,Kurz,L&auml;nge)
CENTER(Text,L&auml;nge,F&uuml;llzeichen)
CENTRE(Text,L&auml;nge,F&uuml;llzeichen)
COMPARE(Text1,Text2[,F&uuml;llzeichen])
COMPRESS(String[,Liste])
COPIES(Zeichenkette,Anzahl)
DATATYPE(Zeichenkette[,Typ])
DELSTR(Zeichenkette,Pos[,L&auml;nge])
DELWORD(Zeichenkette, Pos[,Anzahl])
FIND(Zeichenkette,Worte)
INDEX(Zeichenkette,Muster[,Start])
INSERT(Quellstring,Zielstring[,Start,L&auml;nge,F&uuml;llzeichen])
LASTPOS(Muster, Zeichenkette[,Start])
LEFT(Zeichenkette,L&auml;nge[,F&uuml;llzeichen])
LENGTH(Zeichenkette)
OVERLAY(Quelle, Ziel[,Start,L&auml;nge,F&uuml;llzeichen])
POS()
REVERSE(Zeichenkette)
RIGHT(Zeichenkette,L&auml;nge[,F&uuml;llzeichen])
SPACE(Zeichenkette, Zahl[,F&uuml;llzeichen])
STRIP(Zeichenkette{,B|L|T,Zeichen])
SUBSTR(Zeichenkette,Start[,L&auml;nge,F&uuml;llzeichen])
SUBWORD(Zeichenkette,Start[,Anzahl])
TRANSLATE(Zeichenkette[,rein,raus,F&uuml;llzeichen])
TRIM(Zeichenkette)
UPPER(Zeichenkette)
VERIFY(Zeichenkette,Liste[,M|N,Startposition])
WORD(Zeichenkette,x)
WORDINDEX(Zeichenkette,Zahl)
WORDLENGTH(Zeichenkette,Zahl)
WORDS(Zeichenkette)
XRANGE([Start,Ende])
</PRE></FONT>
<P>
<B>mathematische Funktionen:</B><BR>
<FONT COLOR="#000077"><PRE>
ABS(Zahl)
DIGITS()
FORM()
FUZZ()
MAX(Zahl1,Zahl2[,Zahl3,...])
MIN(Zahl1,Zahl2[,Zahl3,...])
NUMERIC DIGITS Zahl
NUMERIC FORM (Scientific|Engineering)
NUMERIC FUZZ Zahl
RANDOM([MIN,MAX,STARTWERT])
RANDU([Startwert])
SIGN(Zahl)
TRUNC(Zahl[,Stellen])
</PRE></FONT>
<P>
<B>Konvertierungen:</B><BR>
<FONT COLOR="#000077"><PRE>
B2C()
C2B()
C2D()
C2X()
D2C()
D2X()
X2C()
X2D()
</PRE></FONT>
<P>
<B>Bitmanipulation:</B><BR>
<FONT COLOR="#000077"><PRE>
BITAND(BitStr1[,BitStr2,F&uuml;llzeichen])
BITCHG(BitString,Bit)
BITCLR(BitString,Bit)
BITCOMP(BitStr1,Bitstr2[,F&uuml;llzeichen])
BITOR(BitStr1[,BitStr2,F&uuml;llzeichen])
BITSET(BitString,Bit)
BITTST(BitString,Bit)
BITXOR(BitStr1[,BitStr2,F&uuml;llzeichen])
</PRE></FONT>
<P>
So, das war's f&uuml;r heute. Sehr viele Informationen, sehr wenig Beispiele.
Daf&uuml;r haben wir schon fast alles von dem, was ich erst f&uuml;r den n&auml;chsten
Kursteil geplant hatte, mit behandelt. N&auml;chstes Mal gibt's wieder mehr
"richtige" Beispiele, versprochen!«

</BODY>
</HTML>

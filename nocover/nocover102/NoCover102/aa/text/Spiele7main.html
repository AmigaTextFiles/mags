<HTML>
<BODY ALINK=#FFAA00 VLINK=#000077 LINK=#0022CC BGCOLOR=#FFFFFF TEXT=#000000>
<TABLE BORDER=0 WIDTH="100%">
<TR><TD><PRE>
7. Tech-Abteilung: Informationen von Richard Fagher, Autor von »BabeAnoid«

Alles in meinen Programmen ist AMOS-spezifisch, wenn man die 
Standarderweiterungen wie z.B. AMCAF usw. nicht mitz&auml;hlt. Ich benutze keine 
Library-Aufrufe oder externe Maschinencode-Routinen. Es ist nur gute 
Programmierung. Ich gebe gern ein paar hilfreiche Tipps, viele davon sind 
auch in anderen Sprachen anwendbar.

(Nat&uuml;rlich kann ich hier nicht in der gebotenen K&uuml;rze auf die Details 
meiner Programmiertechnik eingehen, aber wenn ein Programmierer einen Blick 
in meine Quellcodes werfen m&ouml;chte, kann er sich gern bei mir melden.)

Zu Anfang ein grundlegendes Konzept, das f&uuml;r die Amiga-Classic- (und AMOS-) 
Programmierung gilt. Das Amiga-System ist haupts&auml;chlich in zwei Gruppen 
unterteilt: Die Grafik (Blitter, etc.) und Code (Prozessor). F&uuml;r jede 
Gruppe separat steht begrenzte Performance zur Verf&uuml;gung. Man kann den 
kleinsten und schnellsten Code haben, aber wenn der Blitter nur ein Pixel 
zuviel zeichnen muss, kann es passieren, dass das Spiel mit 25 FPS statt 
mit 50 FPS l&auml;uft, weil es auf den n&auml;chsten VBL (Bildschirm-Refresh) warten 
muss. Selbst wenn der Code alle verf&uuml;gbare CPU-Zeit ben&ouml;tigt - der Blitter 
kann immer noch eine Menge Grafik in dieser Zeit zeichnen.
Im optimalen Fall sollte man soviel Code und Grafik bearbeiten lassen, wie 
&uuml;berhaupt in 1/50 s bearbeitet werden kann, um die Amiga/AMOS-Ressourcen 
voll zu nutzen.


Ein paar Tipps: Vom Offensichtlichen zum Genialen ;) :

1. Man benutze _nie_ mehr Farben (Bitplanes), als tats&auml;chlich ben&ouml;tigt 
werden, jede zus&auml;tzliche Bitplane kostet Zeit! (Eine schnellere CPU bringt 
hier keinen gro&szlig;en Unterschied.)

Einschub:
Die Hintergrundgrafiken von BabeAnoid belegen nur die ersten beiden 
Bitplanes eines 32-Farben-Screens. Es muss viel zwischen dem Hauptscreen 
und den beiden anderen Screens (Buffer) kopiert werden, um die Schatten und 
die Hintergrunderneuerung zu handhaben. Obwohl alle Screens 32 Farben 
haben, ist es manchmal m&ouml;glich, nur die ersten beiden Bitplanes unter 
Einsatz des "screen copy"-Kommandos zu kopieren.


2. BOBs sollten nie gr&ouml;&szlig;er sein, als tats&auml;chlich notwendig ist. BOBs sind 
sehr langsam, und gro&szlig;e BOBs sind noch langsamer...


3. Das Gesetz der 16: Wegen der Art, wie der Amiga (und ein Computer 
allgemein) aufgebaut ist, sollte die horizontale Gr&ouml;&szlig;e eines Grafikelements 
vorzugsweise durch 16 oder 8 teilbar sein, da dies im allgemeinen schneller 
bearbeitet werden kann (gerade Byteanzahl). Man sollte also ein BOB _nicht_ 
33 Pixel lang machen, wenn man auch mit 32 Pixel leben kann. Dasselbe gilt 
für die Koordinaten, an denen eine Grafikaktion ihren Ausgangspunkt hat, 
man versuche immer, mit dem ersten Bit eines Bytes zu beginnen, also z.B. 
die Pixel 0, 8, 16, 24, 32, usw.
(Ungl&uuml;cklicherweise sind die Bl&ouml;cke in BabeAnoid 12 Pixel gro&szlig;, 
ironischerweise w&auml;ren Blocks mit 16 Pixel Gr&ouml;&szlig;e in einigen Bereichen 
schneller gewesen und h&auml;tten es m&ouml;glicherweise sogar erlaubt, Bl&ouml;cke zu 
animieren)


4. Wenn m&ouml;glich, sollte man Sprites anstelle von BOBs benutzen, weil diese 
mittels DMA dargestellt werden und daher weder CPU- noch Blitter-Zeit 
kosten. Man erstelle die Palette so, dass sie zu den Sprite-Paaren passt, 
um diese optimal einsetzen zu k&ouml;nnen.


5. Positionierung: F&uuml;r einige kleinere Grafikelemente wie Raketen, Sterne, 
usw. kann man dasselbe Sprite in zwei (oder mehr) verschiedenen Positionen 
nutzen, indem man es in jedem neuen Frame an anderer Position darstellen 
l&auml;sst. Diese Elemente werden dann zwar flackern und manchmal zitternd 
dargestellt, aber dies kann durchaus ein erw&uuml;nschter Effekt sein. (Die 
sechs Sterne, die in "BabeAnoid" am unteren Bildschirmrand gescrollt 
werden, sind nur zwei Sprites... und dar&uuml;ber hinaus: Sie werden auch noch 
f&uuml;r andere Effekte genutzt, wie die fallende M&uuml;nze und den Laserstrahl.)


6. Aufgaben aufteilen: Wenn m&ouml;glich, sollte man intensive Grafikoperationen 
in mehrere Teile aufteilen und je einen Teil pro Frame zeichnen lassen (die 
Routine, die die Wiederherstellung der Schatten und des Hintergrunds 
ausf&uuml;hrt, wird &uuml;ber den Zeitraum von drei bis vier Frames ausgef&uuml;hrt, um 
eine Verlangsamung des Spiels zu vermeiden).


7. Die Ausf&uuml;hrungszeiten beachten: Einige AMOS-Kommandos sind wirklich 
langsam, und es gibt oft besseren Ersatz in manchen AMOS-Erweiterungen. Man 
kann die Zeiten messen, indem man die verschiedenen Kommandos/Routinen in 
einer Schleife laufen l&auml;sst und die ben&ouml;tigte Zeit stoppt. Damit l&auml;sst sich 
herausfinden, welches Kommando/welche Routine am besten/schnellsten l&auml;uft 
(man beachte, dass eine Methode, die auf einer Konfiguration sehr schnell 
l&auml;uft, nicht immer auch die beste L&ouml;sung auf einer anderen Konfiguration 
ist. Das ist oft abh&auml;ngig vom eingesetzten Prozessor, Fast-RAM und 
Grafikchip).


8. Eigene Routinen? Wenn das Programm auf schnelle Amigas (040/060) mit 
Fast-RAM zielt, ist es m&ouml;glich, dass man eigene Speicherzugriffsroutinen 
(peek & poke) schreiben kann, die wesentlich schneller sind als die 
eingebauten Kommandos. Man vermeide die Kommandos f&uuml;r Bit-Operationen von 
AMOS (und den Erweiterungen), da diese extrem langsam sind. Dagegen sind 
die Poke-, Doke-, Loke-, Peek-, usw. -Kommandos unheimlich schnell.

(Die Info-Bildschirme mit den animierten Hintergr&uuml;nden zu Beginn von 
BabeAnoid werden mit einer Routine dargestellt, die eine Vierfach-
Vergr&ouml;&szlig;erung in Echtzeit durchf&uuml;hrt, erreicht durch Konvertierung von Bytes 
in Longwords. Diese Routine kann auf einem 68060 in einer Sekunde 100 
160x128-16-Farben-Bilder auf volle Bildschirmgr&ouml;&szlig;e skalieren!)


9. Prozeduren: Man braucht sich nicht vor den AMOS-Prozeduren zu f&uuml;rchten, 
sie werden genauso schnell ausgef&uuml;hrt wie anderer Code. Sie sind im 
Gegenteil ein ausgezeichneter Weg, den eigenen Code in Form zu halten - 
besonders, um die Hauptschleife in gro&szlig;en Programmen kurz zu fassen, da 
AMOS abst&uuml;rzt, wenn die Hauptschleife 30 KByte &uuml;berschreitet.


10. Der heilige Gral: Der Schl&uuml;ssel zum Programmiererfolg ist: Tue nie 
etwas, was du nicht unbedingt tun musst! Man kann davon ausgehen, dass in 
den meisten Programmen 25 bis 50 Prozent der CPU-Zeit verschwendet werden, 
weil das Programm einige Schritte &ouml;fter ausf&uuml;hrt als tats&auml;chlich n&ouml;tig 
w&auml;re! (F&uuml;r Windows sch&auml;tzen wir mal, dass es 90 - 99% sind. ;) )

Ein paar Beispiele daf&uuml;r:

* Man sollte den Punktestand nicht grafisch aktualisieren, solange er sich 
nicht tats&auml;chlich ver&auml;ndert hat.

* Man sollte nicht jeden Frame eine &Uuml;berpr&uuml;fung der Tastatur durchf&uuml;hren, 
wenn eine &Uuml;berpr&uuml;fung alle f&uuml;nf Frames ausreichend ist.

* Man sollte die Tastatur nur _einmal_ abfragen und alle Tastatur-bezogenen 
Funktionen in einer Prozedur handhaben. Man sollte diese Prozedur _nicht_ 
ausf&uuml;hren, wenn die Tastatur noch gar nicht benutzt wurde.


Ein guter Weg, die Arbeit vieler kleiner Routinen und zeitabh&auml;ngiger 
Animationen aufzuf&auml;chern, sind die "rotierenden Variablen"

Beispiel:

DO
    ADD A,1,0 to 5
        IF A=1: "Do thing 1":ENDIF
        IF A=2: "Do thing 2":ENDIF
        IF A=3: ...usw.
LOOP

(F&uuml;r die Nicht-AMOS-Programmierer: Dies f&uuml;hrt eine Reihe von f&uuml;nf Tasks 
aus, einen Task pro Frame &uuml;ber einen Zyklus von f&uuml;nf Frames.)


Man kann auch ein Priorit&auml;ten-System anlegen, indem man eine "Time 
Available"(verf&uuml;gbare Zeit)-Variable nutzt, die immer bis auf 0 
heruntergez&auml;hlt wird und wieder hochgesetzt wird, wenn wichtige und gro&szlig;e 
Funktionen ausgef&uuml;hrt werden m&uuml;ssen.

Beispiel:

DO
    ADD TA,-1,0 to TA: (REM reduziere TA bis TA auf 0 ist)
        IF mouse key = 1: "Dann Code ausf&uuml;hren, der &uuml;ber mehrere Frames hinweg Zeit ben&ouml;tigt.": ADD TA,10
        IF TA = 0 and "Punktezahl ist ver&auml;ndert" then "Punktezahl aktualisieren"
LOOP

Dieser "Code" sorgt daf&uuml;r, dass eine Funktion niedriger Priorit&auml;t, wie die 
Aktualisierung des Punktestands, warten muss, bis eine Funktion h&ouml;herer 
Priorit&auml;t ausgef&uuml;hrt wurde, falls notwendig.


Das waren die Tipps und Tricks von Richard Fagher. Sollte jemand Interesse 
an weiteren Tipps und Tricks haben, kann er sich gern an Richard Fagher 
direkt wenden (dawnbringer@hem.utfors.se).

Wolfgang Hosemann &lt;whose@gmx.de&gt;

</PRE></TD></TR>
</TABLE>
</BODY>
</HTML>
</PRE></TD></TR>
</TABLE>
</BODY>
</HTML>

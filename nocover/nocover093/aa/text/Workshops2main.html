<HTML>
<BODY ALINK=#FFAA00 VLINK=#000077 LINK=#0022CC BGCOLOR=#FFFFFF TEXT=#000000>
<TABLE BORDER=0 WIDTH="100%">
<TR><TD><PRE>
2. Einf&uuml;hrung in die Reaction-Programmierung - T. 1 (von Martin R. Elsner)

Der Einstieg

Vor 10 Jahren war es f&uuml;r einen Programmierer schon eine besondere Leistung,
wenn er ein Workbench-Programm mit vielen Buttons, Texteingabefeldern,
Men&uuml;s usw. entwickelt hatte - jedes Element in seinem Fenster war
Handarbeit und ben&ouml;tigte einige Zeit, bis es an der richtigen Stelle war
und die richtige Gr&ouml;&szlig;e hatte. Wenn dann so etwas wie eine Liste mit Scroll-
M&ouml;glichkeit gefragt war, musste erst mal einiges an Vorarbeit geleistet
werden. Die gro&szlig;e &Uuml;berraschung kam dann aber, wenn jemand auf die Idee kam,
die Zeichens&auml;tze der Workbench zu &auml;ndern, andere Aufl&ouml;sungen oder Farben zu
benutzen: da sah das m&uuml;hsam zusammengestellte Programm eher wie ein
schlechter Scherz aus, was man heute noch mit einigen alten Sch&auml;tzchen aus
dem Aminet ausprobieren kann.

Eine Alternative kam mit MUI, einem Programm, das standardisierte Objekte
mit sich brachte, die dann von jedem Programm benutzt werden konnten.
Leider war es nicht Bestandteil des OS und musste dazugekauft werden, und
es scheint &uuml;berdies nicht mehr weiterentwickelt zu werden.
In diese L&uuml;cke trat dann sp&auml;testens mit OS3.5 Reaction - wobei ich mit
diesem Wort hier auch alles meine, was man als BOOPSI bezeichnet - "Basic
Object Oriented Programming System for Intuition". Genau wie bei MUI
handelt es sich also im Grunde um eine Menge von Oberfl&auml;chenobjekten, die
einmal zur Verf&uuml;gung gestellt werden und dann in allen Programmen
auftauchen k&ouml;nnen. Reaction bietet dann den Kitt, der alles zusammenh&auml;lt
und auch globale Einstellungen f&uuml;r alle Objekte (Hintergrund, Zeichens&auml;tze
usw.) erm&ouml;glicht.

Wer also heute ein Programm f&uuml;r den Amiga (ab OS3.5) entwickeln will, kommt
kaum an Reaction vorbei; deswegen will ich hier versuchen, die Reaction-
Programmierung zu erl&auml;utern und Beispiele f&uuml;r eigene Programme zu geben.
Wer mich kennt, wird wohl auch ClassAction und damit ein gutes Beispiel f&uuml;r
Reaction kennen. Ich werde &ouml;fter mal an diesem Programm die Entwicklung
einer eigenen Oberfl&auml;che erkl&auml;ren und auf gute und schlechte Erfahrungen
hinweisen. Dabei halte ich mich gr&ouml;&szlig;tenteils an die Programmiersprache C
(pers&ouml;nlich programmiere ich nur C++), die Programmierung weicht in anderen
Sprachen aber kaum ab. Grundkenntnisse in einer Programmiersprache setze
ich allerdings voraus. F&uuml;r die Programmierung ben&ouml;tigen wir in jedem Fall
die entsprechenden Bibliotheksdateien, f&uuml;r C sind dies also s&auml;mtliche
Header-Files (z.B. classes/window.h, clib/window_protos.h). In diesen
Dateien sind die ben&ouml;tigten Konstanten, Typen und Funktionsprototypen
enthalten.

Die gr&ouml;&szlig;ten Probleme bei der Programmierung am Amiga ist einerseits das
Fehlen einer grafischen Entwicklungsumgebung wie z.B. Delphi, andererseits
das Fehlen von B&uuml;chern zur aktuellen Programmierung. Deswegen kann ich hier
auch keine B&uuml;cher empfehlen, sondern nur ein paar elektronische Wege zum
Gl&uuml;ck: Die einfachste M&ouml;glichkeit, an Informationen heranzukommen, liegt
auf der Developer CD V2.1. Auf dieser CD befinden sich zum einen alle
AutoDocs und Header-Dateien der Bibliotheksfunktionen, die wir ben&ouml;tigen,
au&szlig;erdem noch einige gute allgemeine Artikel, leider in Englisch (z.B. in
den Ordnern Reference/Amiga_Mail...). Zum zweiten findet man dort den
Storm-C(++)-Compiler in der (bzgl. der kommerziellen Nutzung)
eingeschr&auml;nkten Version 3, den ich sehr empfehlen kann. Das f&uuml;r unser Thema
fast wichtigste ist aber ein kleines Programm im Storm-Verzeichnis mit dem
Titel ReActor. Dabei handelt es sich um ein Tool, mit dem man sich ohne
gro&szlig;e M&uuml;he eine Oberfl&auml;che zusammenbauen und direkt ansehen kann. Es
erzeugt beim Speichern alle ben&ouml;tigten C-Dateien sowie eine Katalogdatei,
mit der das Programm lokalisiert werden kann. Nat&uuml;rlich kommt man auch ohne
dieses Programm aus, aber gerade zum Ausprobieren und f&uuml;r kleinere
Programme ist es wunderbar. Ich werde im Folgenden sowohl die direkte
Programmierung als auch die Bedienung von ReActor beschreiben.

Weitere Informationen gibt es im Aminet. Dort findet man auch neue BOOPSI-
Klassen und Hinweise, wie man eigene Klassen programmiert. Den Anf&auml;nger
werden diese Beispiele jedoch meist mehr verwirren als aufkl&auml;ren. Wenn es
um konkrete Probleme geht, gibt es auch eine Mailingliste (Amiga C) unter
http://yahoogroups.com, in die man sich eintragen und Fragen stellen kann.
Leider hat mein AWeb die Anmeldung nicht hinbekommen, sodass ich hier nicht
mehr dar&uuml;ber sagen kann. Es gibt aber auch viele Programmierer, die gerne
weiterhelfen; ich beantworte gerne Fragen zur Reaction-Programmierung
(obwohl diese Einf&uuml;hrung eigentlich alle Probleme beseitigen sollte).

So, jetzt wird's Zeit mit Reaction anzufangen. Wie man vielleicht schon
ahnt, hat BOOPSI sehr viel mit objektorientierter Programmierung (OOP) zu
tun. Deswegen muss man jetzt nicht C++ benutzen, aber man sollte sich mit
den Grundz&uuml;gen der OOP vertraut machen:

Grob gesagt hei&szlig;t objektorientierte Programmierung, dass die Programme nur
noch aus einzelnen Objekten bestehen, die Eigenschaften und Methoden
besitzen. F&uuml;r BOOPSI hei&szlig;t das z.B., dass es ein Objekt "Fenster" gibt, das
z.B. die Eigenschaft "Titel" besitzt, und die Methoden "&Ouml;ffnen" und
"Schlie&szlig;en". Objekte geh&ouml;ren immer zu einer bestimmten Klasse, hier ist
dies die "Fensterklasse". Da die Klasse schon programmiert ist und als
Datei vorliegt (im Verzeichnis sys:classes), brauchen wir als Programmierer
nur noch ein Objekt (oder auch "Instanz") anzulegen. Klassen k&ouml;nnen auch
hierarchisch aufgebaut werden, z.B. gibt es die Klasse "Buttons", darunter
- sozusagen als Unterklasse - die Klasse "Radiobutton", die Eigenschaften
und Methoden von der &uuml;bergeordneten Klasse &uuml;bernimmt und zus&auml;tzliche zur
Verf&uuml;gung stellt (Gadgetklassen sind im Verzeichnis sys:classes/gadgets
untergebracht).

Eins vorweg: Man sollte jetzt nicht direkt seinen Quelltexteditor starten
und wild draufloshacken; so eine Reaction-Oberfl&auml;che sollte erst mal
sorgf&auml;ltig geplant werden. Wir werden uns im n&auml;chsten Teil mit Fenstern und
dem grunds&auml;tzlichen Aufbau besch&auml;ftigen, jetzt schauen wir uns erst mal an,
was in unserem Programm n&ouml;tig ist, damit wir die OOP nutzen k&ouml;nnen.

Zun&auml;chst ben&ouml;tigt man wie gewohnt bestimmte Bibliotheken, die mit
OpenLibrary und CloseLibrary ge&ouml;ffnet und geschlossen werden. Au&szlig;er den
Standardbibliotheken, die man fast immer ben&ouml;tigt (Intuition,Dos,...),
kommen nun die Klassen hinzu, die man nutzen m&ouml;chte. Ben&ouml;tigt man z.B. ein
Fenster mit nur einem Button, so sieht das in C so aus:

 struct Library
*IntuitionBase,*DosBase,*WindowBase,*LayoutBase,*ButtonBase;
 ...
 IntuitionBase = OpenLibrary( "intuition.library", 39 );
 DosBase       = OpenLibrary( "dos.library", 39 );
 WindowBase    = OpenLibrary( "window.class", 44 );
 LayoutBase    = OpenLibrary( "gadgets/layout.gadget", 44 );
 ButtonBase    = OpenLibrary( "gadgets/button.gadget", 44 );

Die Klassen werden also genauso wie Bibliotheken ge&ouml;ffnet, wobei
OpenLibrary auch in sys:classes sucht, Unterverzeichnisse m&uuml;ssen aber
angegeben werden. Die Nummer der ben&ouml;tigten Version ist hier nicht wichtig,
es sollte aber in jedem Fall sichergestellt sein, dass alle Bibliotheken
ge&ouml;ffnet wurden:

 if( (IntuitionBase == NULL) || (WindowBase == NULL) || (LayoutBase ==
     NULL)) || (ButtonBase == NULL) ){
  CloseLibrary( ButtonBase );
  CloseLibrary( WindowBase );
  CloseLibrary( LayoutBase );
  CloseLibrary( DosBase );
  CloseLibrary( IntuitionBase );
  return;  /* am besten noch Fehlermeldung und raus aus dem Programm */
 }

Und am Ende m&uuml;ssen die Bibliotheken genauso freigegeben werden. Wer Reactor
benutzt, muss auch noch die resource.library &ouml;ffnen. &Uuml;brigens ist
LayoutBase kein Fehler, wir brauchen das Layoutgadget f&uuml;r jedes Fenster.

Haben wir alles ge&ouml;ffnet, kann's losgehen. Statt mit den BOOPSI-Objekten
selbst arbeiten wir im Grunde immer mit Zeigern. D.h. unsere Objekte sind
4-Byte-Variablen, ich arbeite immer mit dem Typ Object*, was im Grunde ein
Zeiger auf ein Langwort ist. Da die BOOPSI-Objekte ja nicht sprachabh&auml;ngig
sind, muss es eine M&ouml;glichkeit geben, Objekte anzulegen, Eigenschaften zu
setzen und zu lesen sowie Methoden auszuf&uuml;hren. Dazu gibt es die Funktionen

 Objekt = NewObject( Klasse,KlassenName,Eigenschaft1,Wert1,
                     Eigenschaft2,Wert2,...,TAG_END )

NewObject legt ein neues Objekt an. Die Klasse wird entweder durch einen
Zeiger auf die Klasse oder durch den Namen der Klasse angegeben. Die
meisten Klassen besitzen eine eigene Bibliotheksfunktion, die den Zeiger
liefert. Zus&auml;tzlich zum Erzeugen kann man auch direkt Eigenschaften
festlegen. Dies kann entweder als Liste geschehen, wie oben angegeben, oder
mit der Funktion

 Objekt = NewObjectA( Klasse,KlassenName,TagList );

wobei TagList der Zeiger auf eine Struktur ist, die die Eigenschaften und
Werte hintereinander als Langworte (4 Byte) enth&auml;lt und wieder durch das
TAG_END (als Eigenschaft) abzuschlie&szlig;en ist (diese Struktur hei&szlig;t TagItem,
die Definition befindet sich in utilities/tagitem.h).

Dieser alternative Aufruf existiert auch f&uuml;r die anderen angegebenen
Funktionen mit sogenannten Tags.

Nat&uuml;rlich kann das Ganze auch schiefgehen - z.B. wenn man mal den
Klassennamen falsch geschrieben hat. Also: immer den R&uuml;ckgabewert auf 0
pr&uuml;fen! Au&szlig;erdem sollte man immer achtgeben, dass man nicht falsche
Eigenschaften setzt, also z.B. f&uuml;r einen Button eine Eigenschaft des
Stringgadgets setzt - dieser Fehler kann nicht vom Compiler erkannt werden,
sorgt aber mindestens f&uuml;r seltsame Effekt, wenn nicht sogar zum Absturz.

 Ergebnis = SetAttrs( Objekt,Eigenschaft1,Wert1,...,TAG_END )

SetAttrs setzt die angegebenen Eigenschaften des Objekts auf die
angegebenen Werte. Bei unseren Gadgets muss meist auch das Fenster
informiert werden, wozu man dann die Funktion

 Ergebnis = SetGadgetAttrs( Gadget,Fenster,Requester,Eigenschaft1,
                            Wert1,...,TAG_END )

benutzen sollte. "Fenster" ist ein Zeiger auf das Fenster, in dem sich das
Gadget befindet, "Requester" ein Zeiger auf den Requester, falls das Gadget
sich in einem solchen befindet.

Die Eigenschaften und zul&auml;ssigen Werte sind in den AutoDocs aufgef&uuml;hrt. Wir
werden uns die wichtigsten noch anschauen.

 Ergebnis = GetAttr( Eigenschaft,Objekt,Pufferadresse )

GetAttr speichert den Wert der Eigenschaft des Objekts im Puffer (der
unbedingt 4 Bytes gro&szlig; sein muss, auch wenn nur eine Boolesche Variable
zur&uuml;ckgegeben wird!). Ist das Ergebnis 0, so besitzt das Objekt diese
Eigenschaft gar nicht. Wer m&ouml;chte, kann auch die reaction.library &ouml;ffnen
und die Funktion GetAttrs benutzen, die auch mehrere Eigenschaften auf
einmal auslesen kann.

 Ergebnis = DoMethod( Objekt,Methode,.. )

DoMethod f&uuml;hrt die angegebene Methode des angegebenen Objekts aus und
&uuml;bernimmt methodenspezifische Parameter. Auch die Bedeutung des
R&uuml;ckgabewerts h&auml;ngt von der Methode ab. Wir werden diese Funktion
haupts&auml;chlich f&uuml;r Fenster benutzen, ansonsten ben&ouml;tigen wir keine Methoden.

Es gibt zwar in der intuition.library noch DoGadgetMethod, aber diese
Funktion wird nur &auml;u&szlig;erst selten n&ouml;tig sein.

&Uuml;brigens gibt es statt eigener Methoden oft Bibliotheksfunktionen, die mit
den Objekten arbeiten, z.B. "HideListBrowserNodeChildren" f&uuml;r Listbrowser-
Objekte.

 DisposeObject( Objekt )

Goldene Regel f&uuml;r Programmierer: was du ausleihst, musst du auch wieder
zur&uuml;ckgeben! Sobald also das Objekt nicht mehr ben&ouml;tigt wird, sollte es
freigegeben werden. Aber Vorsicht: erstens sollte man sicher sein, dass es
auch angelegt wurde, zweitens muss man nicht alles freigeben. Manche
Objekte "geh&ouml;ren" anderen Objekten. Werden dann diese Besitzer freigegeben,
so auch die untergeordneten Objekte. F&uuml;r uns hei&szlig;t das z.B., dass unsere
Gadgets zum Fenster geh&ouml;ren und nicht eigens gel&ouml;scht werden m&uuml;ssen. Man
sollte sich in jedem Fall angew&ouml;hnen, Zeiger nach der Freigabe auf NULL
(bzw. NIL) zu setzen, da die meisten Routinen mit einem NULL-Zeiger, aber
nicht mit einem Zeiger auf ein schon freigegebenes Objekt umgehen k&ouml;nnen.

Bis auf DoMethod (aus der amiga.lib) befinden sich &uuml;brigens alle Funktionen
in der intuition.library.

Das sieht zwar noch sehr theoretisch aus, aber wir schauen es uns mal im
Beispiel an.

/* Prototypen einbinden : */
#include &lt;clib/exec_protos.h&gt;
#include &lt;clib/alib_protos.h&gt;
#include &lt;clib/intuition_protos.h&gt;
#include &lt;clib/dos_protos.h&gt;
#include &lt;clib/window_protos.h&gt;
#include &lt;clib/layout_protos.h&gt;
#include &lt;clib/button_protos.h&gt;

/* Typen und Konstanten einbinden : */
#include &lt;intuition/classusr.h&gt;
#include &lt;classes/window.h&gt;
#include &lt;gadgets/layout.h&gt;
#include &lt;gadgets/button.h&gt;

 /* Die Dateien k&ouml;nnen nat&uuml;rlich bei anderen Compilern anders     */
 /* hei&szlig;en und an anderen Stellen stehen. Zur Not muss man die    */
 /* Verzeichnisse nach den ben&ouml;tigten Konstanten etc. durchsuchen.*/

struct Library *IntuitionBase,*DosBase,*WindowBase,*LayoutBase,*ButtonBase;

int main(){

 Object *window,*layout,*button;

 /* wie gesagt, man kann auch einen anderen Typ benutzen,         */
 /* z.B. ULONG window oder APTR window, es m&uuml;ssen nur 4 Byte sein */

 struct Window *intuiwin; /* das brauchen wir noch */

 /* So, den n&auml;chsten Teil kennen wir schon: */

 IntuitionBase = OpenLibrary( "intuition.library", 39 );
 DosBase       = OpenLibrary( "dos.library", 39 );
 WindowBase    = OpenLibrary( "window.class", 44 );
 LayoutBase    = OpenLibrary( "gadgets/layout.gadget", 44 );
 ButtonBase    = OpenLibrary( "gadgets/button.gadget", 44 );
 if( (!IntuitionBase) || (!WindowBase) || (!LayoutBase) || (!ButtonBase) ){
  CloseLibrary( ButtonBase );
  CloseLibrary( WindowBase );
  CloseLibrary( LayoutBase );
  CloseLibrary( DosBase );
  CloseLibrary( IntuitionBase );
  return( 20 );
 }

 /* Jetzt wird's interessant : */

 layout = (Object*)NewObject( LAYOUT_GetClass(),NULL,
                              LAYOUT_Orientation,LAYOUT_VERTICAL,
                              LAYOUT_DeferLayout,TRUE,
                              LAYOUT_SpaceInner,TRUE,
                              LAYOUT_SpaceOuter,TRUE,
                              TAG_END );

 /* da haben wir's: LAYOUT_GetClass() kommt aus layout.gadget    */
 /* und liefert uns den ben&ouml;tigten Zeiger, wir brauchen also     */
 /* keinen Klassennamen. Dann folgen einige Eigenschaften, mit   */
 /* denen wir uns noch genauer besch&auml;ftigen werden. Sie          */
 /* betreffen jedenfalls das Aussehen und die Funktionsweise des */
 /* Layout. &Uuml;brigens gibt es auch Reaction-Makros, die diese     */
 /* Erzeugung etwas angenehmer machen (in                        */
 /* reaction/reaction_macros.h). */

 button = (Object*)NewObject( BUTTON_GetClass(),NULL,
                              GA_Text,"Mein erster Reaction-Button ...",
                              TAG_END );

 /* Man gew&ouml;hnt sich dran, oder? */
 /* Sch&ouml;n ist, dass man wirklich nur das angeben muss, was man   */
 /* ben&ouml;tigt; man muss nicht wie fr&uuml;her erst viele Parameter     */
 /* festlegen, sondern ist mit ein paar Zeilen fertig. Zudem     */
 /* sieht es auch noch &uuml;bersichtlicher aus.*/

 SetGadgetAttrs( (Gadget*)layout,NULL,NULL,LAYOUT_AddChild,button,TAG_END
                 );

 /* Hier ordnen wir den Button unserem Layout unter. Dazu m&uuml;ssen  */
 /* wir nur die Eigenschaft LAYOUT_AddChild setzen. &Uuml;brigens      */
 /* h&auml;tten wir auch SetAttrs benutzen k&ouml;nnen, wenn wir sowieso    */
 /* weder Fenster noch Requester angeben. Aber wir sollten uns    */
 /* daran gew&ouml;hnen, mit SetGadgetAttrs zu arbeiten, denn wenn das */
 /* Fenster offen ist, geht's nicht anders. */

 window = (Object*)NewObject( WINDOW_GetClass(),NULL,
                              WINDOW_Layout,layout,
                              WINDOW_Position,WPOS_CENTERMOUSE,
                              WA_Activate,TRUE,
                              WA_Title,"Ein Fenster !!",
                              WA_DragBar,TRUE,
                              TAG_END );

 /* Hier &uuml;bergeben wir dem Fenster direkt sein "Kind", n&auml;mlich   */
 /* unser Layout. Dann folgen einige Eigenschaften, mit denen    */
 /* wir uns n&auml;chstes Mal genauer besch&auml;ftigen. Sie betreffen     */
 /* jedenfalls das Aussehen und die Funktionsweise des Fensters. */
 /* Offen ist es aber noch nicht, also: */

 DoMethod( window,WM_OPEN );

 /* So einfach ist das. Wer sich mal die AutoDocs anschaut, wird  */
 /* feststellen dass man aber bei der Angabe eines Fensters immer */
 /* einen Zeiger auf eine Window-Struktur ben&ouml;tigt und kein       */
 /* Objekt. Kein Problem, holen wir ihn uns: */

 GetAttr( WINDOW_Window, window, &intuiwin );

 /* Immer aufpassen, dass man einen ZEIGER auf die Variable    */
 /* &uuml;bergibt, sonst kommt der Guru ... */

 Delay( 500 ); /* wir warten erst mal ca. 10 Sekunden ... */

 SetGadgetAttrs( (Gadget*)button,intuiwin,NULL,
                 GA_Text,"... ist immer noch da!",TAG_END );

 /* Hier ist endlich unser intuiwin im Einsatz! Hat auch einen  */
 /* Sinn, denn das Fenster muss direkt aktualisiert werden.     */
 /* &Uuml;brigens ist es mir schon des &ouml;fteren passiert, dass ich    */
 /* TAG_END vergessen habe - gerade wenn ich zuvor GetAttr      */
 /* benutzt habe. Das macht sich dann meist durch seltsame      */
 /* Ergebnisse oder sogar einen Absturz bemerkbar. Sobald man   */
 /* mal das Programm debuggt und Enforcer oder ein &auml;hnliches    */
 /* Tool startet, findet man meist den Fehler. */

 Delay( 500 ); /* weil's so sch&ouml;n ist ... */

 DoMethod( window,WM_CLOSE ); /* klar, oder ? */

 DisposeObject( window );

 /* So, das war's. Wie gesagt, das Layout und der Button werden vom */
 /* Window freigegeben. Nat&uuml;rlich m&uuml;ssen jetzt noch die Libraries   */
 /* geschlossen werden. Und wenn das Programm noch weiter geht,     */
 /* sollte man nicht vergessen, alle Zeiger auf NULL zu setzen:     */

 window   = NULL;
 layout   = NULL;
 button   = NULL;
 intuiwin = NULL;

 CloseLibrary( ButtonBase );
 CloseLibrary( WindowBase );
 CloseLibrary( LayoutBase );
 CloseLibrary( DosBase );
 CloseLibrary( IntuitionBase );
 return( 0 );
}


Screenshot:
<IMG SRC="../extra/reaction.png" ALT="Screenshot">


An dieser Stelle m&ouml;chte ich schon mal ein paar Tips loswerden, auch wenn
ich erst in den n&auml;chsten Teilen auf die angesprochenen Themen eingehe:

- Wer schon mit Reactor arbeitet, wird fr&uuml;her oder sp&auml;ter beim
  Kompilieren die Fehlermeldung "Symbol _STR nicht definiert"
  erhalten. Der Grund ist einfach, dass man irgendwo vergessen hat, zu
  einem Text einen Konstantenbezeichner als "Locale ID" anzugeben.
  Diese Id's dienen zur Lokalisierung des Programms und sind unbedingt
  notwendig; am Anfang reicht es, irgendeinen Text einzugeben, z.B.
  MSG_TEXT1 usw.

- Reactor st&uuml;rzt manchmal ab, wenn man falsche Einstellungen vorgenommen
  hat oder Objekte entfernt hat, die an anderer Stelle noch eingetragen
  waren. (Z.B. sollte man erst den Verweis auf ein Label entfernen,
  dann das Label selbst.) Man sollte hier also ein bisschen mitdenken
  und nicht alles dem Programm &uuml;berlassen ;)

- Manches funktioniert nicht so, wie man erwarten k&ouml;nnte: z.B. wird
  normalerweise ein Gadget direkt nach SetGadgetAttrs() aktualisiert,
  bei einem Checkbox-Gadget allerdings muss RefreshGList() explizit
  aufgerufen werden. Man sollte nicht direkt verzweifeln, sondern die
  AutoDocs durchst&ouml;bern, meist findet man irgendwo einen Hinweis oder
  eine Funktion, die das Problem l&ouml;st!


Jetzt sind wir schon am Ende des ersten Teils angekommen. Unser erstes
Programm ist schon fertig und sieht doch h&uuml;bsch aus! Jedenfalls kann sich
niemand &uuml;ber endlose Quelltexte beschweren. Vor allem gab es nirgends
irgendeine absolute Gr&ouml;&szlig;e oder Position! Jetzt ist der Punkt gekommen,
dieses Programm abzutippen und erste Erfahrungen zu sammeln. Wer m&ouml;chte,
kann sich ja schon mal die AutoDocs zu den Gadgets anschauen, oder im
Internet st&ouml;bern. Eine sch&ouml;ne Beschreibung von BOOPSI und ein schon etwas
komplexeres Beispielprogramm findet sich auf der Developer-CD unter
Reference/Amiga_Mail_Vol2/IV-23/. Im n&auml;chsten Teil geht es dann
haupts&auml;chlich um Fenster (Erzeugung, Eigenschaften, Ereignisbehandlung) und
ReActor.


Ansonsten w&uuml;nsche ich schon mal viel Spa&szlig; mit Reaction,

euer

Martin R. Elsner &lt;email@martin-elsner.de&gt;

</PRE></TD></TR>
</TABLE>
</BODY>
</HTML>
</PRE></TD></TR>
</TABLE>
</BODY>
</HTML>

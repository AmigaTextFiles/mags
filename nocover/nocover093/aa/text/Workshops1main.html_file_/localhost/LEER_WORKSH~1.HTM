<!-- saved from url=(0022)http://internet.e-mail -->
<HTML>
<BODY ALINK=#FFAA00 VLINK=#000077 LINK=#0022CC BGCOLOR=#FFFFFF TEXT=#000000>
<TABLE BORDER=0 WIDTH="100%">
<TR><TD><PRE>
Workshops / Hintergrundberichte / Buchvorstellungen
---------------------------------------------------

1. Workshop: Programmierung in C++ - Teil 1 (von Thomas Richter)

1. Anstelle einer Einf&uuml;hrung: Wozu C++?

Nun ja, vor allen Dingen ist C++ eine Programmiersprache. Meistens h&ouml;rt man
bei C++ auch gleich Dinge wie "objektorientiert" - und &uuml;blicherweise geh&ouml;rt
C++ zum guten Ton, will man sich als Programmierer verdingen. Der Name
"C++" ist eigentlich auch schon ein Wortspiel: C++ wurde von Bjarne
Stroustrup als Nachfolger der Programmiersprache C entwickelt und das
angeh&auml;ngte "++" bedeutet in C sowie auch in C++: "Erh&ouml;he um eins". "C++"
ist damit "C+1", also das n&auml;chste "C". Der Name "C" wiederum ist ein
&auml;hnlicher Witz, ist doch C die Fortentwicklung von B, und B geht wiederum
auf die Programmiersprache BCPL zur&uuml;ck.

Warum erz&auml;hle ich das alles? Nun, sowohl C als auch BCPL spielen eine gro&szlig;e
Rolle im Betriebssystem des Amiga. Fast alle Komponenten des OS sind in C
geschrieben, mit Ausnahme des DOS - das sind die Befehle und Programme im
Verzeichnis C: und was dazu geh&ouml;rt. Diese wurden zun&auml;chst in BCPL
geschrieben. Einige kleinere Teile schlie&szlig;lich sind in Assembler.

&Uuml;blicherweise folgt dann bei Einf&uuml;hrungen in C++ an dieser Stelle etwas wie
"Warum Objektorientierung?", es folgen Aufz&auml;hlungen von Vorteilen dieser
Programmiertechnik bei gro&szlig;en Projekten, die von mehreren Entwicklern
betreut werden, es folgen Designregeln, wie man so etwas richtig
aufzieht... und nach weiteren zwei Seiten langweilt sich der Leser zu Tode.

Also machen wir's anders: Hinein in die Praxis! All' das Zeug soll am
"lebenden Objekt" studiert werden.


2. Vor die Freude haben die G&ouml;tter...

Ja, und da geht das Problem schon los. F&uuml;r C++ ben&ouml;tigt man einen sog.
"Compiler", der ein menschenlesbares - jedenfalls behaupten Programmierer,
es sei menschenlesbar - Quell-Programm in denjenigen Code &uuml;bersetzen soll,
den der Rechner auch wirklich versteht. F&uuml;r den Amiga einen brauchbaren
C++-Compiler zu finden, ist leider nicht so leicht. Zumindest einige
Alternativen habe ich finden k&ouml;nnen:

SAS C

Der SAS ist der klassische C-Compiler f&uuml;r den Amiga. Das sieht man allein
daran, dass der Gro&szlig;teil des OS eben mit dem SAS compiliert wurde.
Qualitativ einer der besten Compiler, wird er aber leider nicht mehr weiter
entwickelt. Die neueren Versionen des SAS C beinhalteten auch eine
"Ann&auml;herung" an einen C++-Compiler. Ann&auml;herung deshalb, weil die
Unterst&uuml;tzung f&uuml;r C++ eher mau und recht unvollst&auml;ndig ausf&auml;llt. Wenn man
einen SAS zuhause hat, wird er f&uuml;r unsere Beispielprogramme ausreichen.
Mehr aber auch nicht. Zu kaufen gibt's ihn eh' nicht mehr.

Storm C 3.0

Dieser Compiler unterst&uuml;tzt zumindest den Gro&szlig;teil des C++-Sprachumfanges,
wenn auch manchmal mit einigen Macken. Die Version ist nicht ganz
taufrisch, aber der Compiler findet sich auf der Developer-CD 2.1, die man
f&uuml;r sinnvolles Arbeiten auf dem Amiga sowieso mal braucht. Beim Testen des
Compilers fielen einige Programmfehler auf - sog. "Hits" - die auf schlecht
getesteten Code hindeuten. Nun ja, f&uuml;r unsere Zwecke dennoch ausreichend.
Je nach Geschmack ist die graphische Benutzeroberfl&auml;che entweder hilfreich,
oder einfach ein Klotz am Bein. "Real Men" werden nat&uuml;rlich einen von der
Shell aus bedienbaren Compiler vorziehen, f&uuml;r Einsteiger kann die
Oberfl&auml;che aber hilfreich sein. Ich werde hier aufgrund der leichten
Verf&uuml;gbarkeit erst mal beim Storm C 3.0 bleiben.

Gnu C++ 2.95

Der GNU C++ ist der von der Free Software Foundation bereitgestellte
Compiler. Er ist auf allen m&ouml;glichen Plattformen, inklusive PC und Amiga,
verf&uuml;gbar. Allein von der Compilerleistung l&auml;sst sich GNU C++ kaum
&uuml;bertreffen und ist dem SAS ebenb&uuml;rtig. Der Sprachumfang entspricht
detailgenau dem Standard und auch sonst g&auml;be es wenig zu klagen, w&auml;re der
Compiler in einem benutzbaren und installierbaren Zustand. Leider wird nur
der fortgeschrittene Experte einen GNU C++ auf dem Amiga installieren und
benutzen k&ouml;nnen, und einige Stunden f&uuml;r die Installationsarbeit wird man
schon rechnen m&uuml;ssen. GNU ist eben "expertenfreundlich".

Storm C 4.x

Als Compiler verbirgt sich dahinter der GNU C++, allerdings hat man ihm
eine bedienbare Oberfl&auml;che spendiert. Insofern gibt es in Puncto
Compilerleistung bestimmt nichts zu meckern. Ich besitze den Storm 4 nicht
und kann deswegen keine Aussagen &uuml;ber die Qualit&auml;t der Oberfl&auml;che machen,
aber will man schon einen C++ kaufen, so ist dies hier wohl die richtige
Wahl. Sehr viele andere Optionen gibt's so wie so nicht.


3. Ein erstes C++-Progr&auml;mmchen

Allein aus Traditionsgr&uuml;nden geh&ouml;rt es sich, als allererstes Programm ein
"Hallo Welt" zu schreiben - das Programm soll nichts weiter anstellen, als
diesen Text auf den Bildschirm auszugeben.

Bleiben wir also erst mal beim Storm C 3.0: Die Installation von CD erfolgt
problemlos und soll hier nicht beschrieben werden. Ein Doppelklick auf das
Storm-C-Programmicon startet dann auch schon die Oberfl&auml;che.

Als erstes m&uuml;ssen wir ein neues Projekt aufsetzen: Dazu w&auml;hle man im
"Projekt"-Men&uuml; den Men&uuml;punkt "Neu". Im daraufhin erscheinenden Fenster
markiere man zun&auml;chst "C++ Programm" durch Klicken auf das zugeh&ouml;rige
Feld, denn so ein Programm wollen wir ja schreiben. Oben rechts neben
"Projekt-Schublade" w&auml;hle man mit dem Dateirequester noch einen geeigneten
Aufbewahrungsort f&uuml;r das Projekt, als Name w&auml;hlen wir einfach mal "Hallo".
Danach dieses Fenster mit "OK" verlassen.

Das Projekt ist jetzt erstellt, muss aber noch ge&ouml;ffnet werden - das
geschieht hier leider nicht automatisch. Also im "Projekt"-Men&uuml; den Punkt
"&Ouml;ffnen..." ausw&auml;hlen, und dort die Projektdatei heraussuchen. Sie sollte
"Hallo.P" hei&szlig;en, mit einem spiegelverkehrten "P". Leider muss man hier
eventuell etwas suchen, der Requester zeigt nicht unbedingt die richtige
Schublade an. Danach erh&auml;lt man ein erst mal recht leeres Fenster, in das
die Bestandteile des Programmes eingef&uuml;gt werden m&uuml;ssen.

Wieso Bestandteile, gibt's denn mehr als einen? Ja, doch! Die Sprache C++
verf&uuml;gt &uuml;ber keine eingebauten "Befehle" wie etwa BASIC oder ARexx. Einem
C++-Programm muss alles beigebracht werden, und sei es nur das Drucken
eines Textes auf den Bildschirm. Zum Gl&uuml;ck geh&ouml;rt zum Lieferumfang eines
Compilers eine sogenannte "Standardbibliothek", die vorgefertigte L&ouml;sungen
f&uuml;r derlei Aufgaben bereitstellt. Ach ja, unser Code ist nat&uuml;rlich auch ein
Bestandteil des Programmes, wie k&ouml;nnte es anders sein?

Aus dem "Projekt"-Men&uuml; w&auml;hle man also nun "Datei(en) hinzuf&uuml;gen". Daraufhin
erscheint ein Dateirequester, in den man als Dateinamen "Hallo.cpp"
eintrage. Nein, diese Datei gibt's noch nicht, aber wir werden sie gleich
erstellen; folgerichtig fragt die Compileroberfl&auml;che auch nach, ob diese
Datei erstellt werden soll. Soll sie, das wird ja das Hauptprogramm. Als
Zweites m&uuml;ssen wir noch die Standardbibliothek hinzuf&uuml;gen: "Projekt"-Men&uuml;,
dort "Bibliothek(en) hinzuf&uuml;gen" ausw&auml;hlen. Als Bibliothek w&auml;hlen wir die
"storm.lib", sie enth&auml;lt alles notwendige. &Uuml;ber die Bedeutung weiterer
Bibliotheken braucht jetzt kein Wort verloren werden, dazu sp&auml;ter mehr.
Dieses Projekt sollte man nun mittels Speichern auf Platte sichern.

Ein Doppelklick auf "Hallo.cpp" &ouml;ffnet endlich einen Editor; hier kommt der
Programmcode hinein - das wurde auch Zeit. Folgendes bitte genau so in
dieses Fenster eintippen:


/* Ein allererstes klitzekleines Progr&auml;mmchen */

// Das folgende bringt dem Compiler einige &uuml;bliche
// Methoden bei, unter anderem das Drucken auf den Bildschirm.
// Die dazugeh&ouml;rigen Funktionen befinden sich in der "storm.lib"

#include &lt;iostream.h&gt;

// und jetzt zur ersten Programmfunktion: Sie hei&szlig;t "main" - und muss
// so hei&szlig;en. Sie wird immer als allererstes aufgerufen.
// Mehr dazu im Artikel.

int main(int argc,char **argv) {
        // gibt einen Text auf dem Bildschirm aus.
        // Das erledigt das cout-Objekt f&uuml;r uns.

        cout &lt;&lt; "Hallo, Welt!\n";

        return 0;
}
// und das war's auch schon, Leute.


Auch diesen Text sollte man jetzt auf Platte abspeichern. Jetzt zum
eigentlichen Kompilieren: Im Men&uuml; "Kompilieren" findet man den Men&uuml;punkt
"Alle &Uuml;bersetzen..."; nach Auswahl dieses Men&uuml;punktes ist der Rechner erst
einmal ein kleines Weilchen besch&auml;ftigt. Mit "Projekt starten" aus dem
gleichen Men&uuml; darf man nun seine Arbeit bewundern: Es sollte sich ein
Fenster &ouml;ffnen, in dem "Hallo, Welt!" steht, und sonst nichts. Das Fenster
kann man mit dem Schlie&szlig;knopf links oben auch wieder loswerden.

Falls das nicht klappt: Keine Panik! Vermutlich wird dann der Compiler
einige Fehlermeldungen generieren. Durch Doppelklick im daraufhin
erscheinenden Ausgabefenster des Compilers gelangt man an die fehlerhafte
Stelle im Quelltext. Hier muss man sich ganz genau ansehen, ob alles
wirklich richtig geschrieben ist; ein fehlendes Semikolon wird genauso
beanstandet wie eine fehlende Klammer! &Uuml;blicherweise sollte man sich auch
einige Zeilen &uuml;ber oder unter der beanstandeten Zeile umsehen, den
Tippfehler korrigieren und den Compiler neu anwerfen.


4. Pr&auml;prozessor, Compiler, Linker

Nach diesem ersten Test - der ging doch erfolgreich &uuml;ber die B&uuml;hne, oder
nicht? - sollte man sich auch fragen, was da eigentlich passiert ist.
Hier nun eine Erkl&auml;rung des Programmes Zeile f&uuml;r Zeile:

Die erste Zeile ist einfach nur ein Kommentar. Sie wird beim &Uuml;bersetzen
schlichtweg ignoriert. Genauer gesagt, alles was zwischen einem "/*" und
einem "*/" steht, wird ignoriert, selbst wenn mehrere Eingabezeilen
zwischen diesen beiden Symbolen stehen. Hier ist es nur eine. Genau das
gleiche gilt f&uuml;r die n&auml;chsten drei Zeilen: Der doppelte Querstrich "//"
leitet auch einen Kommentar ein, der geht aber jeweils nur bis zum
Zeilenende, im Gegensatz zu den mit "/*" erzeugten Kommentaren.

Was soll das? Warum schreibt man offensichtlich Daten in den Quellcode, die
der Compiler so wie so ignoriert? Zugegeben, bei dem kleinen Programm w&auml;re
es egal gewesen, aber Projekte aus dem wahren Leben eines Programmierers
gehen &uuml;ber mehrere tausend Zeilen, wenn nicht mehr, und da vergisst man
schon mal, was man sich mit diesem oder jenem Programmteil so gedacht hat.
Gute Kommentare an den wichtigen Programmstellen helfen dann weiter, wenn
man den entsprechenden Programmcode seit Wochen oder Monaten nicht mehr
angesehen hat.

Die folgende Zeile mit dem "#" ist genau genommen eigentlich gar keine C++-
Anweisung. Hierbei handelt es sich statt dessen um eine Kontrollzeile f&uuml;r
den sogenannten "Pr&auml;prozessor". Das ist ein vor dem Compiler auflaufender
Makro-Prozessor, dessen eigentliche Aufgabe nur darin besteht,
Wortersetzungen auszuf&uuml;hren und den Compiler letztendlich mit Eingabedaten
zu f&uuml;ttern. So ist es die Aufgabe des Pr&auml;prozessors, schon vorsorglich alle
Kommentare zu entfernen - der Compiler braucht sie sowieso nicht. Ferner
sucht der Pr&auml;prozessor nach allen Zeilen, die mit diesem Doppelkreuz ("#")
beginnen, denn das sind Kontrollanweisungen f&uuml;r ihn und nicht f&uuml;r den
Compiler.

Die #include-Anweisung f&uuml;gt nun den Inhalt der angegebenen Datei - hier
also den Inhalt von "iostream.h" - an die Stelle in den Quellcode ein, an
der diese Anweisung steht. Mit anderen Worten: Dem Compiler wird ein
Eingabetext serviert, bei dem diese Zeile fehlt, stattdessen ist der
gesamte Inhalt der Datei von "iostream.h" dahin getreten, genau so, als
h&auml;tte man ihn mit dem Editor dort von Hand eingef&uuml;gt.

Warum das denn blo&szlig;? Wie gesagt, es gibt in C++ keine eingebauten Befehle,
die irgend etwas auf den Bildschirm drucken. Irgendwo her muss der Compiler
aber trotzdem wissen, wie das geht. Die zugeh&ouml;rigen Definitionen hierf&uuml;r
werden in "iostream.h" gemacht. Die entsprechenden Funktionen, die
letztendlich die Arbeit ausf&uuml;hren, befinden sich dann in der oben schon
erw&auml;hnten "storm.lib". Da das eine ganze Menge sind, will man sie nicht
jedesmal neu &uuml;bersetzen m&uuml;ssen und darum enth&auml;lt "iostream.h" zwar die
notwendigen Details, wie mit diesen Funktionen umzugehen ist, aber nicht
die Funktionen selbst.

Mit dem Pr&auml;prozessor kann man noch andere nette Dinge - oder auch viel
Unheil - anrichten; dazu sp&auml;ter mehr.

Die n&auml;chsten drei Zeilen sind wieder Kommentare. Daraufhin folgt die
Definition einer Funktion. Wenn man sich noch d&uuml;ster an den
Mathematikunterricht erinnert, ist eine Funktion etwas, in das man Zahlen
hineinsteckt, die dann in ihrem Inneren verarbeitet werden, so dass dann
ein Ergebnis hinauspurzelt. Das ist bei C++ nicht viel anders, nur dass die
Argumente nicht nur Zahlen sein d&uuml;rfen, und dass das Resultat einer
Funktion auch nicht nur eine Zahl zu sein braucht.

Der Resultattyp einer Funktion steht ganz links auf der Zeile, die die
Funktion definiert. Hier ist es ein Resultat vom Typ "int" - das ist
einfach eine ganze Zahl. Der Funktionsname folgt, und lautet schlicht
"main". Jedes C++-Programm ben&ouml;tigt eine Funktion dieses Namens mit genau
diesem Resultat, denn diese Funktion wird beim Programmstart aufgerufen und
muss alles beinhalten, was das Programm ausmacht. Normalerweise w&uuml;rde man
nat&uuml;rlich in "main" andere Funktionen verwenden und nicht einfach das ganze
Programm dort hineinschreiben.

In den Klammern hinter "main" stehen die Argumente, hier sind es zwei:
Eines hei&szlig;t "argc", das andere "argv". Die Namen sind irrelevant und wir
brauchen diese Argumente auch &uuml;berhaupt nicht. Trotzdem bekommen wir sie
&uuml;bergeben. Wenn man dieses Programm von der Shell aufrufen w&uuml;rde, k&ouml;nnte
man hier die Kommandozeilenargumente herauslesen, doch das brauchen wir
nicht. Dementsprechend will ich mir hier auch verkneifen zu erkl&auml;ren, was
ein "char **" ist. "argc" ist hingegen wieder ein int, also einfach eine
ganze Zahl. Sie w&uuml;rde mit der Anzahl der Programmargumente gef&uuml;llt werden.

Hinter dieser Zeile folgt eine geschweifte Klammer ("{"). Zwischen ihr und
dem entsprechenden Gegenst&uuml;ck weiter unten steht der eigentliche Rumpf der
main-Funktion. Dieser Programmcode wird ausgef&uuml;hrt, wenn "main()"
aufgerufen wird - und da eben "main" zur Ausf&uuml;hrung des Programmes
aufgerufen wird, ist das unser Programm. Die folgenden Zeilen sind wieder
einfach nur Kommentare.

Danach folgt die einzig wirklich wichtige Anweisung in diesem Programm:
Die in Anf&uuml;hrungszeichen eingeschlossene Zeichenkette wird mittels "&lt;&lt;" in
das cout-Objekt "hineingeschoben". Das "cout" kommt - wie sollte es anders
sein - aus der Datei "iostream.h". Dort wird dem Compiler auch erkl&auml;rt, wie
man da eine Zeichenkette hineinschiebt. Wichtig f&uuml;r uns ist nur, dass
solche Zeichenketten wirklich auf dem Bildschirm ausgegeben werden. Alles,
was in "cout" hineinwandert, purzelt dort hinaus.

In der Zeichenkette f&auml;llt noch ein "\n" auf, das wir auf dem Bildschirm gar
nicht gesehen haben. Oder doch? Nun, "\n" ist ein Sonderzeichen und bewirkt
einen Zeilenvorschub, &auml;hnlich einem Druck auf die Return-Taste. Das "\n"
dabei bedeutet soviel wie "newline". Es gibt noch einige andere dieser
Sonderzeichen, etwa "\t" f&uuml;r die Tabulator-Taste, oder "\b" f&uuml;r die
Backspace-Taste.

Das Semikolon hinter der Zeichenkette schlie&szlig;t diese Anweisung ab. Es muss
dort stehen, denn es h&auml;lt Anweisungen auseinander.

Und schlie&szlig;lich gibt's noch ein "return 0;" zu besprechen: Dessen Bedeutung
ist leicht zu erkennen: Es beendet die Funktion und liefert als
R&uuml;ckgabewert eine Null. Mit dieser Null passiert hier nichts besonderes;
sie ist nur dann von Bedeutung, wenn das Programm von der Shell aus
gestartet werden w&uuml;rde. Dann w&auml;re dies der R&uuml;ckgabewert an die Shell, wobei
andere Werte als Null im Allgemeinen als Fehler interpretiert werden: Je
gr&ouml;&szlig;er, desto schlimmer!


5. Und was ist nun mit Objektorientierung?

Na ja, genaugenommen noch nichts! Oder nicht viel! In diesem Progr&auml;mmchen
haben wir nur ein einziges Objekt verwendet, und das ist "cout". Das
n&auml;chste Mal wollen wir aber wirklich Objekte selbst erstellen und
verwenden.

Thomas Richter &lt;thor@math.TU-Berlin.DE&gt;

</PRE></TD></TR>
</TABLE>
</BODY>
</HTML>
</PRE></TD></TR>
</TABLE>
</BODY>
</HTML>

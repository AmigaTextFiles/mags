<html>
<head>
  <title>Workshops</title>
  <meta name="Generator" content="GuideML V1.5">
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body>
<a href="main.html">CONTENTS</a> | <a href="tower-berichte5.html">PREV</a> | <a href="workshops2.html">NEXT</a>
<hr>
<pre>

Workshops / Hintergrundberichte
-------------------------------

1. ARexx-Kurs - Teil 5 (von Heiko Kuschel)

&raquo;ARexx-Kurs: &Uuml;bersicht

1. Einf&uuml;hrung in ARexx.
    - Wie funktionierts?
    - Was brauche ich?
    - Installation
    - ein erstes kleines Programm
        - Ein- und Ausgabe
        - do...end

2. Programmstruktur und Ansteuerung von anderen Programmen
    - if
    - do...end
    - address
    - Tracing

3. Ein- und Ausgabe; Funktionen
    - Ein- und Ausgabe
    - Stringfunktionen
    - mathematische Funktionen
    - Konvertierungsfunktionen
    - Bitmanipulation

4. komplexere Programmstrukturen
    - Operatoren
    - Procedure
    - Libraries
    - Systemfunktionen

5. Aufbau von Skripten
    - ein ARexx-Skript konzipieren
    - MUIRexx
    - Libraries
    - Beispiele f&uuml;r die Vernetzung von Programmen&laquo;


&raquo;5. Beispiele f&uuml;r die Vernetzung von Programmen
5.0. Vorbemerkungen
Hier wiederhole ich f&uuml;r Quereinsteiger noch einmal einen Teil der
Vorbemerkungen, die ich zum ganzen Kurs gemacht habe.

Der Kurs wird als reine Text-Datei angefertigt, da auch Amiga Aktuell u.a. 
in ASCII-Form verschickt wird. Um den Text etwas zu gliedern, habe ich 
daher ein paar &quot;Textmarker&quot; eingef&uuml;gt.

********** unterteilt einzelne Abschnitte

__________ bezeichnet Beginn und Ende eines ARexx-Programms. Die Striche 
geh&ouml;ren nicht zum Programm!
ARexx-Befehle werden in diesem Kurs immer GROSS geschrieben, obwohl das
eigentlich nicht n&ouml;tig ist. Auf diese Weise kann man sie aber leichter 
erkennen.

Ich hoffe, da&szlig; diese Regelung den Kurs etwas leserlicher macht.

Wenn ihr spezielle Fragen habt, etwas nicht verstanden habt oder Anregungen 
und Ideen f&uuml;r weitere Kursteile habt, k&ouml;nnt ihr euch gerne an mich wenden.
Ich selbst benutze folgende ARexx-f&auml;hige Programme und kann daher auf deren
Programmierung kurz eingehen, wenn das gew&uuml;nscht wird:
Wordworth, GoldEd, Database Professional, YAM, Miami, Voyager, TurboCalc.

Hier meine Kontaktadresse:

Heiko Kuschel
Lehmgrubenweg 13
97280 Remlingen
E-Mail: <a href="mailto:hk0006@wuerzburg.baynet.de">hk0006@wuerzburg.baynet.de</a>

Und jetzt... viel Spa&szlig; mit ARexx!

****************************************************

5.1. Ein ARexx-Skript konzipieren
Mittlerweile haben wir so ziemlich alle ARexx-Befehle durchgemacht, die es
gibt. Aber - wie mache ich daraus nun ein sinnvolles ARexx-Skript? Bei 
vielen Vorhaben ist das gar nicht so einfach, denn manche Programme, die 
&uuml;ber ARexx anzusteuern sind, haben so ihre Eigenheiten. Ein paar 
Grundprobleme m&ouml;chte ich in diesem Kursteil ansprechen und dann noch 
Skripte vorstellen, die ich selber f&uuml;r den &quot;Hausgebrauch&quot; geschrieben habe.

****************************************************
5.1.1. Wie finde ich die Adresse?
Fast alle ARexx-f&auml;higen Programme bieten die M&ouml;glichkeit, ARexx-Skripte 

der Port des startenden Programms als ARexx-Port voreingestellt, an den die 
Befehle geschickt werden sollen. Das sieht dann so aus:
__________________________________
OPTIONS RESULTS
PortName = ADDRESS()
__________________________________

Wenn sp&auml;ter ein anderes Programm angesteuert wird und dadurch der Port mit
ADRRESS xxx ver&auml;ndert wird, kannst Du anschlie&szlig;end wieder auf das Programm
zur&uuml;ckkommen, das das Skript gestartet hat. Und zwar ganz einfach mit

ADDRESS VALUE PortName

PortName ist hier die Variable, in der der Portname des Programms abgelegt
wird, das das Skript gestartet hat. Z.B. Wordworth.1 oder YAM etc.

****************************************************
5.1.2. Eigenheiten der einzelnen Programme
Manche Programme haben nicht nur einen einzigen ARexx-Port. Stattdessen 
&ouml;ffnen sie f&uuml;r jedes Fenster einen eigenen, z.B. Wordworth und, soweit ich 
wei&szlig;, auch Final Writer. Die werden dann durchnumeriert: Wordworth.1, 
Wordworth.2 usw.
Dadurch kann man sich nie sicher sein, da&szlig; ein bestimmter Port tats&auml;chlich
existiert! Es kann ja sein, da&szlig; das Fenster (und damit der Port), dem
Wordworth.1 zugeordnet wurde, geschlossen wurde. Vielleicht existieren 
gerade nur Wordworth.3 und Wordworth.5. Wenn ich Wordworth also von au&szlig;en 
ansteuern will, ohne da&szlig; das Skript aus Wordworth heraus gestartet wurde, 
ist es ziemlich schwierig, einen richtigen Port zu finden. Ich behelfe mir 
immer mit der folgenden kleinen Schleife:
__________________________________
options results
DO Num = 1 to 20
        WwPort = &quot;WORDWORTH.&quot; || Num
        IF SHOW(PORTS, WwPort) THEN DO
                Address Value WwPort
                leave Num
        end
end
if num=21 then do
    echo &quot;Wordworth nicht gefunden! Programm endet.&quot;
    quit
end
__________________________________

&Uuml;brigens gibt es auch andere Programme, die eine Zahl hintendran h&auml;ngen, 
bei der diese Zahl aber etwas anderes bedeutet. Der normale ARexx-Port von 
GoldEd hei&szlig;t z.B. GOLDED.1 Hier gibt es nur ein GOLDED.2, wenn GoldEd 
tats&auml;chlich nochmal neu gestartet wird. Alle Fenster mit unterschiedlichen 
Texten innerhalb von GoldEd haben dagegen diesen einen ARexx-Port GOLDED.1.
Bei GoldEd gibt es noch eine weitere Besonderheit: Der Text mu&szlig; f&uuml;r den
normalen Zugriff gesperrt werden. Dabei mu&szlig; seit Version 4 von GoldEd auch 
noch angegeben werden, f&uuml;r welche Version dieses Skript geschrieben wurde. 
Sinnvoll, da sich der ARexx-Wortschatz von GoldEd beim Sprung von Version 3 
auf 4 ziemlich ge&auml;ndert hat. Einzelheiten dazu stehen in der Online-Hilfe 
zu GoldEd.

Ein Wort noch zu allgemeinen Problemen mit der Ausf&uuml;hrung von Programmen:
Gerade bei Database Professional (DBPro) habe ich festgestellt, da&szlig; es oft
genau auf die Schreibweise (gro&szlig;/klein etc.) ankommt. Oft ist es auch 
n&ouml;tig, da&szlig; Argumente in Anf&uuml;hrungszeichen gesetzt werden. Beachte dabei 
folgendes: Aus
FINDBASE &quot;Adressen.db&quot;
wird f&uuml;r Database:
FINDBASE Adressen.db

Du mu&szlig;t stattdessen das Ganze nochmal in Anf&uuml;hrungszeichen setzen, da immer 
die &auml;u&szlig;ersten durch ARexx entfernt werden:
'FINDBASE &quot;Addressen.db&quot;'
Alternativ m&uuml;&szlig;te eigentlich auch gehen:
FINDBASE '&quot;Addressen.db&quot;'
An Database wird dann dieser Text &uuml;bermittelt:
FINDBASE &quot;Adressen.db&quot;

Kapiert? Ich hoffe es. Das Kapitel mit den Anf&uuml;hrungszeichen ist eines der
kompliziertesten in der ganzen ARexx-Programmiererei.

&Uuml;brigens: Mir ist es auch schon passiert, da&szlig; ich einen Befehl genau so
eingegeben habe, wie er im Handbuch steht, und es hat trotzdem nicht
funktioniert. Das war bei Beckertext III.

****************************************************
5.2. MUIRexx

5.2.1. Kurzeinf&uuml;hrung
MUIRexx ist ein ausgesprochen gutes Hilfsmittel, um komplizierteste
Bedienoberfl&auml;chen zu erstellen. Es ist gewisserma&szlig;en die Schnittstelle 
zwischen ARexx und dem &quot;Magic User Interface&quot;, kurz: MUI, mit dem 
inzwischen viele Programme programmiert sind (z.B. YAM, Voyager, STFax,...)
MUIRexx ist anders als andere Libraries: Es ist ein eigenes Programm, das 
&uuml;ber ARexx gesteuert wird und, je nach den Befehlen, die es erh&auml;lt, ein 
Fenster mit Schaltfl&auml;chen, Listern, Texten oder was auch immer aufbaut. Es 
ist im Aminet erh&auml;ltlich unter dev/mui und kostet eine Shareware-Geb&uuml;hr von 
15 US-Dollar.
Nun wird das aber nicht einfach &uuml;ber ADDRESS MUIREXX gemacht, sondern jedes
erstellte Fenster bekommt einen eigenen ARexx-Port. Am einfachsten schaffst 
Du das, indem Du mit MUIRexxBuild ein neues Fenster erstellst und dem einen 
Namen gibst. Ich habe auf diese Weise ein Fenster mit dem Namen &quot;Listen&quot; 
erstellt, das wird dann &uuml;ber ADDRESS Listen angesteuert.
Das Ganze funktioniert so &auml;hnlich wie eine DO... END-Schleife: Erst wird 
ein Fenster definiert, und darin einzelne Gruppen:
WINDOW
    GROUP
        GROUP
        ...
        ENDGROUP
    ENDGROUP
    GROUP
    ....
    ENDGROUP
ENDWINDOW
Das w&auml;re eine typische Grundstruktur f&uuml;r eine Fensterdefinition. Die ganzen
Dinge mit diversen Variablen usw. kannst Du dabei weitgehend MUIRexxBuild
&uuml;berlassen, das &uuml;brigens selbst eine MUIRexx-Anwendung ist!

****************************************************
5.2.2. Ein Beispiel
Bis jetzt habe ich es immerhin geschafft, ein Fenster aufzubauen, das
verschiedene Gruppen enth&auml;lt. Nur das dazugeh&ouml;rige Programm fehlt noch, das 
die damit verbundenen Aktionen auch ausf&uuml;hrt... Da es hier aber um die 
Arbeit mit MUIRexx geht, m&ouml;chte ich das Ganze trotzdem einmal kurz 
vorstellen. Weitere Beispiele finden sich ja auch im MUIRexx-Ordner.
Mein kleines Skript soll mir eigentlich die Verwaltung von Mailinglisten
vereinfachen. Das sind so eine Art EMail-Rundschreiben-Gruppen. Ich schicke
eine Mail an eine bestimmte Adresse, und diese Mail wird an alle verteilt, 
die sich in der Mailingliste eingetragen haben.
Um in so eine Liste zu kommen, mu&szlig; man an eine jeweils unterschiedliche 
Adresse eine Mail schicken, etwa &quot;subscribe PAmiga-list meine-Email-
Adresse&quot;. &Auml;hnlich mit unsubscribe, wenn man wieder rauswill. Und daneben 
gibt es noch manche Mailinglisten, bei denen man sich auch kurzzeitig 
ausklinken kann, ohne sich vollst&auml;ndig zu verabschieden, indem man die 
Optionen auf NOMAIL setzt, das hei&szlig;t, ich kriege im Moment keine Mail. F&uuml;r 
jede Mailingliste existiert also:
- eine Adresse, an die alle Befehle geschickt werden m&uuml;ssen
- ein Befehl, um sich einzuschreiben
- ein Befehl, um sich wieder auszuschreiben
- evtl. ein Befehl, um die Listenoptionen auf NOMAIL zu setzen
- evtl. ein Befehl, um NOMAIL wieder r&uuml;ckg&auml;ngig zu machen.
Da ich immer wieder mal wechsle, dachte ich mir, es w&auml;re sinnvoll, das &uuml;ber 
ein Programm zu machen. Dabei wollte ich zun&auml;chst aus einer gro&szlig;en Liste 
(wer die haben will, kann mich anmailen) ein paar Standard-Mailinglisten 
ausw&auml;hlen k&ouml;nnen, die dann wiederum einzeln an- und abgeschaltet werden 
k&ouml;nnen.
Das dazugeh&ouml;rige Fenster stelle ich mir so vor, da&szlig; ich eine Liste der
aktuellen (sprich: von mir vorausgew&auml;hlten) Mailinglisten habe und &uuml;ber 
&quot;Prefs&quot; weitere dazunehmen kann oder welche herausnehmen kann. In einer 
Zeile untendrunter soll, sofern vorhanden, eine kurze Beschreibung der 
Mailingliste stehen, die ich gerade angeklickt habe.
... und so sieht mein Programm dazu aus:
(da einige Programmzeilen sehr lang sind, habe ich die l&auml;ngeren unter ihnen
mit zwei Kommentarzeilen eingerahmt. F&uuml;r viele von Euch ist sonst 
vermutlich nicht zu erkennen, wo eine Programmzeile unterbrochen ist.
/*Das Folgende ist eine Zeile*/
hier dazwischen steht eine lange Programmzeile
/*bis hier*/

Das folgende Programm wird aus einer Shell heraus wie folgt gestartet:
muirexx:muirexx Listen.rexx PORT Listen
Listen.rexx ist dabei der Name des Skripts.
__________________________________
/* Application created by MUIBuild */

address Listen

MUIA_Listview_DragType = 0x80425cd3
MUIA_List_DragSortable = 0x80426099
MUIV_Listview_DragType_Immediate = 1
TRUE = 1
MUIA_Listview_MultiSelect = 0x80427e08
MUIA_Dropable = 0x8042fbce
MUIV_Listview_MultiSelect_Default = 1
MUIA_List_Quiet = 0x8042d8c7
MUIV_List_Insert_Sorted = -2
line = '%s';

/*Diese Variablen wurden von MUIRexxBuild selbstst&auml;ndig eingef&uuml;gt*/

window COMMAND &quot;&quot;&quot;quit&quot;&quot;&quot; PORT Listen TITLE &quot;&quot;&quot;Mailinglisten-Verwaltung&quot;&quot;&quot;
 group HORIZ REGISTER LABELS &quot;Aktuelle,Prefs&quot;
  group ID Aktuell
   group HORIZ
    group FRAME
     text LABEL &quot;Liste der aktuellen Mailinglisten&quot;
     list ID List1
    endgroup
    group FRAME
     text LABEL &quot;Status&quot;
     space
     radio LABELS &quot;On,Off,Nomail&quot;
     space
    endgroup
   endgroup
   view ID Help1 STRING &quot;Hilfetext&quot;
  endgroup
  group ID Prefs
   group HORIZ
    group FRAME
/*Das Folgende ist eine Zeile*/
    text LABEL &quot;Liste der bekannten Mailinglisten&quot; list ID List2 ATTRS 
MUIA_Listview_DragType MUIV_Listview_DragType_Immediate 
MUIA_List_DragSortable TRUE
/*bis hier*/
     endgroup
    group FRAME
/*Das Folgende ist eine Zeile*/
     text LABEL &quot;Aktuelle Liste&quot; list ID List3 ATTRS MUIA_Listview_DragType 
MUIV_Listview_DragType_Immediate MUIA_List_DragSortable TRUE MUIA_Dropable 
TRUE
/*bis hier*/
    endgroup
   endgroup
  view ID Help2 STRING &quot;Hilfetext2&quot;
  endgroup
 endgroup
endwindow

/* bis hierher sollte es ziemlich verst&auml;ndlich sein. */
callhook ID List2 PORT INLINE INCLUDE List3 DROP,
    COMMAND &quot;&quot;&quot;options results;
                address Listen;
                line='%s';
/*Das Folgende ist eine Zeile*/
                'list ID &quot;List2&quot; INSERT POS &quot;MUIV_List_Insert_Sorted&quot; 
STRING' line;
/*bis hier*/
                'list ID &quot;List3&quot; REMOVE STRING' line;
                'list ID &quot;List1&quot; REMOVE STRING' line;&quot;&quot;&quot;
callhook ID List3 PORT INLINE INCLUDE List2 DROP,
    COMMAND &quot;&quot;&quot;options results;
                address Listen;
                line='%s';
/*Das Folgende ist eine Zeile*/
                'list ID &quot;List3&quot; INSERT POS &quot;MUIV_List_Insert_Sorted&quot; 
STRING' line;
/*bis hier*/
/*Das Folgende ist eine Zeile*/
                'list ID &quot;List1&quot; INSERT POS &quot;MUIV_List_Insert_Sorted&quot; 
STRING' line;
/*bis hier*/
                'list ID &quot;List2&quot; REMOVE STRING' line;&quot;&quot;&quot;
callhook ID List1 INCLUDE List1
   list ID List1 INSERT STRING &quot;YAM&quot;
   list ID List1 INSERT STRING &quot;PAmiga&quot;
   list ID List1 INSERT STRING &quot;I-Amiga&quot;
   list ID List1 INSERT STRING &quot;TeamAmiga&quot;
   list ID List1 INSERT STRING &quot;STFax&quot;
   list ID List3 INSERT STRING &quot;YAM&quot;
   list ID List3 INSERT STRING &quot;PAmiga&quot;
   list ID List3 INSERT STRING &quot;I-Amiga&quot;
   list ID List3 INSERT STRING &quot;TeamAmiga&quot;
   list ID List2 INSERT STRING &quot;CU-Amiga&quot;
   list ID List2 INSERT STRING &quot;Voyager&quot;
   list ID List3 INSERT STRING &quot;STFax&quot;
__________________________________
Ich hoffe, da&szlig; der Aufbau des Fensters auch beim Lesen des Quelltextes 
halbwegs verst&auml;ndlich wird. &quot;REGISTER&quot; sind die Karteikartenreiter am 
oberen Ende des Fensters. Wenn ich eine Gruppe sp&auml;ter nocheinmal 
weiterverwenden mu&szlig;, kann ich ihr mit ID einen Namen zuweisen, also z.B. 
GROUP ID ErsteGruppe.
Schwieriger wird schon die Sache mit Callhook. Hier werden Ereignisse
definiert, nach denen irgendeine Aktion stattfinden soll. Also: Wenn ich in
&quot;Prefs&quot; einen Listennamen aus dem einen Lister in den anderen ziehe, mu&szlig; 
dieser Name nat&uuml;rlich im alten Lister verschwinden und im neuen auftauchen. 
Da Computer, selbst Amigas, leider nicht intelligent genug sind, mu&szlig; ich 
ihm das extra sagen. Das sieht dann so aus:
__________________________________
callhook ID List2 PORT INLINE INCLUDE List3 DROP,
    COMMAND &quot;&quot;&quot;options results;
                address Listen;
                line='%s';
/*Das Folgende ist eine Zeile*/
                'list ID &quot;List2&quot; INSERT POS &quot;MUIV_List_Insert_Sorted&quot; 
STRING' line;
/*bis hier*/
                'list ID &quot;List3&quot; REMOVE STRING' line;
                'list ID &quot;List1&quot; REMOVE STRING' line;&quot;&quot;&quot;
__________________________________
Das hei&szlig;t: Wenn in List2 etwas fallengelassen wird, und zwar aus List3, 
dann starte ein ARexx-Skript, das den MUIRexx-Task Listen addressiert. In 
List2 wird der Name der Mailingliste eingef&uuml;gt (mit %s), in List3 entfernt 
und ebenso in List1. (Das ist die erste, die man sieht, auf der Seite 
&quot;Aktuelle&quot;.)
Um das Programm zu vervollst&auml;ndigen, fehlen jetzt also nur noch weitere 
solche Callhooks, die dann erst einmal den jeweils zur Liste geh&ouml;rigen 
Hilfetext anzeigen, auf der Seite &quot;Aktuelle&quot; den richtigen Radioknopf f&uuml;r 
die jeweils angeklickte Liste aktivieren (also ob sie an, aus oder auf 
NOMAIL gesetzt ist) - und au&szlig;erdem noch eine Reihe von Kn&ouml;pfen, um die 
entsprechenden Befehls-mails loszuschicken, abzubrechen oder eine &Uuml;bersicht 
&uuml;ber den aktuellen Stand der Dinge auszugeben. Vielleicht hast Du ja Lust, 
so etwas zu machen... :)
Anbei mein einfaches Programm, das vier verschiedene Mailinglisten 
bestellt. So habe ich das bisher gehandhabt:
__________________________________
/* YAM und I-Amiga werden auf MAIL gesetzt, Pamiga und Team Amiga 
bestellt*/
/* $VER: 1.0. 23.2.98 */
options results
if ~show(&quot;P&quot;,YAM) then address command &quot;run Yam:Yam&quot;

address command
'echo &#062;t:Yamtext &quot;SET YAM MAIL&quot;'
'echo &#062;t:Iamigatext &quot;SET I-AMIGA MAIL&quot;'
'echo &#062;t:PAmigatext &quot;SUBSCRIBE PAMIGA-LIST <a href="mailto:hk0006@wuerzburg.baynet.de">hk0006@wuerzburg.baynet.de</a>&quot;'
'echo &#062;t:TAmigatext &quot;SUBSCRIBE TeamAmiga <a href="mailto:hk0006@wuerzburg.baynet.de">hk0006@wuerzburg.baynet.de</a>&quot;'

&quot;sys:rexxc/Waitforport YAM&quot;

address YAM
mailwrite
writemailto &quot;<a href="mailto:Listserv@tu-clausthal.de">Listserv@tu-clausthal.de</a>&quot;
&quot;writeletter t:Yamtext&quot;
writequeue
mailwrite
writemailto &quot;<a href="mailto:Majordomo@lists.netlink.co.uk">Majordomo@lists.netlink.co.uk</a>&quot;
&quot;writeletter t:PAMIGATEXT&quot;
writequeue
mailwrite
writemailto &quot;<a href="mailto:listserv@listserv.acsu.buffalo.edu">listserv@listserv.acsu.buffalo.edu</a>&quot;
&quot;writeletter t:Iamigatext&quot;
writequeue
mailwrite
writemailto &quot;<a href="mailto:majordomo@thule.no">majordomo@thule.no</a>&quot;
&quot;writeletter t:TAMIGATEXT&quot;
writequeue
address command
&quot;delete &#062;NIL: t:yamtext&quot;
&quot;delete &#062;NIL: t:?amigatext&quot;
__________________________________
Ich denke, dieses Skript solltest Du inzwischen mit Leichtigkeit verstehen.

****************************************************
5.3. andere Libraries
5.3.1. rexxreqtools.library
Die rexxreqtools.library findet sich, soweit ich wei&szlig;, im Aminet.

Sie enth&auml;lt die Funktionen der reqtools.library, also alle Arten von
Requestern. Auch daf&uuml;r gibt es im Lieferumfang schon ein paar Demos, mit 
denen man ganz gut weiterarbeiten kann. Ich m&ouml;chte nur eben vorstellen, wie 
ich ein Skript beginne, das zuerst nachsieht, ob Wordworth l&auml;uft und dann 
den Requester von Wordworth verwendet, ansonsten aber Rexxreqtools:
__________________________________
options results
DO Num = 1 to 20
        WwPort = &quot;WORDWORTH.&quot; || Num
        IF SHOW(PORTS, WwPort) THEN DO
                Address Value WwPort
                leave Num
        end
end
if num=21 then do
  if ~show(&quot;L&quot;,rexxreqtools.library) then do
  call addlib(&quot;rexxreqtools.library&quot;, 0, -30, 0)
  end
  gadtxt= &quot;_Holen|E_nde|_To-Do-Liste|_Cancel&quot;
  Anf = upper(rtgetstring(&quot; &quot;,&quot;Bitte Textstelle eingeben:&quot;,&quot;Text 
3.0.&quot;,gadtxt))
  buttonresult=rtresult
end
else do
  do i=0 to 5
  viewwindow i
  end    /* wenn Makro nicht von WW aus aufgerufen wird, ist sonst die 
Workbench vorne*/
         /* keine Ahnung, wie man herausfinden kann, welches Fenster 
existiert.*/
/*Das Folgende ist eine Zeile*/
  WizardReq TITLE &quot;Text 3.0.&quot; LABEL &quot;Bitte Textstelle eingeben:&quot; TEXTBOX 1 
&quot;_Stelle:&quot; BUTTON 1 &quot;_Holen&quot; BUTTON 2 &quot;E_nde&quot; BUTTON 3 &quot;_To-Do-Liste&quot; 
BUTTON &quot;-1&quot; &quot;_Cancel&quot;
/*bis hier*/
  buttonresult = RESULT
  Wizard_GetTextBox 1
  Anf = UPPER(RESULT)
end
select
  when buttonresult = 2 then do
  when buttonresult = -1 then do
  etc.
end
_________________________________
Hier hast Du nun also zwei verschieden definierte Requester drin: Einen mit
einem Wordworth-Befehl (WizardReq) und einen mit der Rexxreqtools.library
(rtgetstring).
Gleichzeitig nat&uuml;rlich auch die verschiedenen M&ouml;glichkeiten, das Ergebnis 
des Requesters abzufragen: Bei reqtools wird der eingegebene Text sofort 
als Variable &uuml;bergeben. Welcher Knopf gedr&uuml;ckt wurde, kann &uuml;ber die 
Variable rtresult abgefragt werden. Bei Wordworth steht die Nummer des 
Knopfs in RESULT, und der eingegebene Text ebenfalls, nachdem der Befehl 
Wizard_GetTextBox eingegeben wurde. Dabei die Nummer der Textbox nicht 
vergessen! (hier 1) Es sind n&auml;mlich mehrere Textboxen in ein und demselben 
Requester m&ouml;glich.
Der &quot;Abbruch&quot;-Knopf hat die Nummer &quot;-1&quot; erhalten, da RESULT ebenfalls -1
enth&auml;lt, wenn das Schlie&szlig;gadget in der linken oberen Ecke bet&auml;tigt wird. So
haben wir zwei Fliegen mit einer Klappe geschlagen.

****************************************************
5.3.2. rexxtricks.library
Die Rexxtricks.library enth&auml;lt eine Menge n&uuml;tzlicher Funktionen aus den
folgenden Bereichen:

AmigaDOS-Funktionen
SCSI-Funktionen
Clipboard-Funktionen
Listen-Funktionen
Publicscreen-Funktionen
Icon-Funktionen
Sonstige Funktionen

Diese im einzelnen zu erl&auml;utern, w&uuml;rde hier zu weit f&uuml;hren. Aber ich wollte
einmal auf diese Library aufmerksam machen, denn sie kann oft wirklich 
n&uuml;tzlich sein. Lies mal die Anleitung, sie ist ziemlich gut!

****************************************************
5.4. Beispiele f&uuml;r die Vernetzung von Programmen
5.4.1. Beckertext und Wordworth
Das Sch&ouml;ne an ARexx ist ja gerade, da&szlig; es auch m&ouml;glich ist, mehrere 
Programme miteinander zu verkn&uuml;pfen. Ein kleines Beispiel hatten wir 
bereits in einem fr&uuml;heren Kursteil: Ein Skript, das Miami und YAM startet, 
online geht, Post sendet und abholt und wieder offline geht. Das war 
nat&uuml;rlich relativ simpel.
Beim folgenden Skript kommt immerhin dazu, da&szlig; ein bestimmter Text 
irgendwie zwischen zwei Anwendungen ausgetauscht werden soll. Ich habe es 
geschrieben, weil ich fr&uuml;her viel mit Beckertext gearbeitet habe, jetzt 
inzwischen aber Wordworth verwende. Da BT und WW leider kein gemeinsames 
Clipboard verwenden, Wordworth au&szlig;erdem keinen &quot;Dazuladen&quot;-Befehl kennt, 
war es gar nicht so einfach, das zu realisieren. Eigentlich tut dieses 
Skript nichts anderes, als einen bereits markierten Text aus Beckertext in 
das aktuelle Wordworth-Dokument an der aktuellen Stelle einzuf&uuml;gen. Und so 
sieht das Ganze aus:
_________________________________
/*  BT-Text (markierten Block) in WW5 einsetzen - MJ+HK 17.6.96  */
OPTIONS RESULTS
WwPortName = Address()
GetFont
OldFont = Result
GetFontSize
OldFontSize = Result
Address ('bt3')
kopiere
neudok
einsetzen
'asichern &quot;T:BT&quot;'
schliesse
Address Value WwPortName
New
Address Value Result
Open FILENAME &quot;T:BT&quot;
SelectAll
Font NAME OldFont SIZE OldFontSize
Copy
Close FORCE
Address Value WwPortName
Paste
Address Command delete &quot;T:BT&quot;
_________________________________
Also: Das Skript wird aus Wordworth aufgerufen, sonst ist es nicht m&ouml;glich, 
das aktuelle Fenster in Wordworth zu bestimmen.
Dann wird festgestellt, welche Schriftart an der aktuellen Stelle 
eingestellt ist, damit auch der neue Text gleich in dieser Schriftart 
erscheint.
Anschlie&szlig;end setze ich den aktuellen Port auf Beckertext. Warum da die 
Klammern n&ouml;tig sind, wei&szlig; ich wirklich nicht. So stehts im Handbuch, und 
nur so funktioniert's auch.
Mit Beckertext ist es nicht m&ouml;glich, einen Block einzeln abzuspeichern. 
Also: Neues Dokument &ouml;ffnen, Block hineinkopieren, Dokument als reinen Text
abspeichern. Und jetzt das gleiche r&uuml;ckw&auml;rts f&uuml;r Wordworth: Neues Dokument
&ouml;ffnen, mit der richtigen Schrift formatieren, ins &quot;richtige&quot; Dokument
kopieren, fertig.

****************************************************
5.4.2. Typisch Multitasking...
Als n&auml;chstes m&ouml;chte ich euch noch ein Skript vorstellen, an dem eine Menge
Programme beteiligt sind: Wordworth, GoldEd, Database Pro, YAM. Dieses 
Skript habe ich geschrieben, um die Texte, die ich schreibe, archivieren, 
ausdrucken, im Gro&szlig;druck f&uuml;r meinen Opa ausdrucken, an Freunde in 
verschiedenen Dateiformaten mailen zu k&ouml;nnen. Und das alles in einem 
Aufwasch. :)
Selbst wenn Du einige der Programme nicht selbst hast, hoffe ich, da&szlig; Du 
den einen oder anderen Kniff brauchen kannst. Schau's Dir mal an.
_________________________________
/* $VER: 1.1. 19.8.97 - 23.1.98*/
options results
Wordworthport=Address()
/*Das Folgende ist eine Zeile*/
wizardreq title &quot;Ansprache versenden&quot; label &quot;Bitte Nummer der Ansprache 
eingeben.&quot; textbox 1 &quot;_Nummer:&quot; textbox 2 &quot;In _DB &uuml;bernehmen (J/N):&quot; 
textbox 3 &quot;_Gro&szlig;druck erstellen (J/N):&quot; textbox 4 &quot;_Mail verschicken (J/N)&quot; 
textbox 5 &quot;Anzahl N_ormaldrucke:&quot; Button 1 &quot;_Ok&quot; Button &quot;-1&quot; &quot;_Abbruch&quot;
/*bis hier*/
 if result = &quot;-1&quot; then do
            exit
       end

       Wizard_Gettextbox (1)
       Nummer=Right(Result,3,&quot;0&quot;)
       Wizard_Gettextbox (2)
       DB=Result

       Wizard_Gettextbox (3)
       Grossdruck=Result

       Wizard_Gettextbox (4)
       Mail=Result

       Wizard_Gettextbox (5)
       Normaldruck=Result

/* bis hierher wird &uuml;berpr&uuml;ft, welche der Aktionen tats&auml;chlich durchgef&uuml;hrt 
werden sollen. */
/*Meine Ansprachen sind durchnumeriert, und zwar nach dem Schema 
002.Beschreibung */
if Normaldruck=&quot;J&quot; then Normaldruck=1
if Normaldruck&#062;0 then do
   SAVEAS NAME &quot;Text:Wordworth7/Dokumente/Ansprachen/000.TEMP&quot;
end
/*Wenn ein Ausdruck in der &quot;Normalform&quot; gew&uuml;nscht ist, mu&szlig; die Datei 
zwischengespeichert werden.*/
/*Den tats&auml;chlichen Namen des Textes kann man mit Wordworth leider nicht 
herausfinden.*/
 if DB=&quot;J&quot; then do
    if ~show(&quot;P&quot;,DataBase) then address command &quot;run Text:DBProV3.1/db&quot;
 end
if Mail=&quot;J&quot; then do
   'SAVEAS RTF Name T:Ansprache.rtf'
   'SAVEAS WORDPERFECT Name T:Ansprache.wpf'
   if ~show(&quot;P&quot;,YAM) then address command &quot;run Yam:Yam&quot;
end
/*Hier werden die jeweils ben&ouml;tigten Programme gestartet:*/
/*DBPRo, falls eine Aufnahme in die Datei gew&uuml;nscht ist,*/
/*und YAM, falls die Ansprachen per EMail verschickt werden sollen.*/

address command
   if ~Exists(&quot;Text:Wordworth7/Dokumente/Ansprachen/&quot;||Nummer||&quot;.kurz&quot;) 
then do
/*Das Folgende ist eine Zeile*/
   &quot;echo &#062; Text:Wordworth7/Dokumente/Ansprachen/&quot;||Nummer||&quot;.kurz&quot;  
'&quot;Ansprache Nr. '||Nummer||'&quot;'
/*bis hier*/
   &quot;echo &#062;&#062; Text:Wordworth7/Dokumente/Ansprachen/&quot;||Nummer||&quot;.kurz&quot; '&quot;Text: 
&quot;'
   &quot;echo &#062;&#062; Text:Wordworth7/Dokumente/Ansprachen/&quot;||Nummer||&quot;.kurz&quot; 
'&quot;Datum: &quot;'
   &quot;echo &#062;&#062; Text:Wordworth7/Dokumente/Ansprachen/&quot;||Nummer||&quot;.kurz&quot; '&quot;Ort: 
&quot;'
   &quot;echo &#062;&#062; Text:Wordworth7/Dokumente/Ansprachen/&quot;||Nummer||&quot;.kurz&quot; 
'&quot;Stichworte: &quot;'
   &quot;echo &#062;&#062; Text:Wordworth7/Dokumente/Ansprachen/&quot;||Nummer||&quot;.kurz&quot; 
'&quot;Beschreibung: &quot;'
    end
/*Hier gebe ich mir selbst ein kleines Formular f&uuml;r eine Kurzbeschreibung 
vor.*/
/*Der doppelte Pfeil nach echo bewirkt, da&szlig; der Text an die bestehende 
Datei*/
/*angeh&auml;ngt wird.*/
/*Ein Teil davon wird in der Datenbank weiterverwendet, die ganze Datei 
auf*/
/*jeden Fall mit der entsprechenden Nummer und dem Anh&auml;ngsel .kurz 
abgespeichert.*/

&quot;ged Text:Wordworth7/Dokumente/Ansprachen/&quot;||Nummer||&quot;.kurz sticky&quot;
/*GoldEd wird gestartet, damit ich meine Kurzbeschreibung bearbeiten 
kann.*/
/*Die Option sticky bewirkt, da&szlig; das Skript erst dann weiterl&auml;uft, wenn 
ich*/
/*GoldEd wieder beendet habe.*/
if Mail=&quot;J&quot; then do
   if ~show(&quot;P&quot;,GOLDED.1) then address command ged
   &quot;sys:rexxc/Waitforport GOLDED.1&quot;
   address GOLDED.1
   Lock current release 4
   'open t:Ansprache.rtf'
   replace string &quot;&auml;&quot; by &quot;'8a&quot; all quiet
   replace string &quot;&ouml;&quot; by &quot;'9a&quot; all quiet
   replace string &quot;&uuml;&quot; by &quot;'9f&quot; all quiet
   replace string &quot;&szlig;&quot; by &quot;'a7&quot; all quiet
   unlock
   'save all nolf exit'
/* Was soll das nur schon wieder sein? Hier ersetze ich alle &auml;,&ouml;,&uuml;,&szlig;*/
/* durch die entsprechenden Codierungen, wie sie im RTF-Format eigentlich*/
/* verwendet werden - nur Wordworth macht das leider nicht. Zumindest*/
/* WW6 nicht - ich habe WW7 darauf noch nicht &uuml;berpr&uuml;ft.*/
   address command
   'echo &#062;t:Ansprachemailtext &quot;Hallo!&quot;'
   'echo &#062;&#062;t:Ansprachemailtext &quot;Anbei eine Ansprache von mir.&quot;'
   'echo &#062;&#062;t:Ansprachemailtext &quot;Viele Gr&uuml;&szlig;e&quot;'
   'echo &#062;&#062;t:Ansprachemailtext'
   'echo &#062;&#062;t:Ansprachemailtext &quot;Heiko&quot;'
   'echo &#062;&#062;t:Ansprachemailtext &quot;Hier die Kurzfassung:&quot;'
/*Das Folgende ist eine Zeile*/
   'join t:Ansprachemailtext 
Text:Wordworth7/Dokumente/Ansprachen/'||Nummer||'.kurz to 
t:Ansprachemailtext2'
/*bis hier*/
   &quot;sys:rexxc/Waitforport YAM&quot;
   address YAM
   mailwrite
 /*  writemailto &quot;Tscho&quot;
   &quot;writesubject Ansprache_von_Heiko&quot;
   &quot;writeletter t:Ansprachemailtext2&quot;
   writequeue
   mailwrite*/
   writemailto &quot;ThoVo&quot;
   &quot;writesubject Ansprache_von_Heiko&quot;
   &quot;writeletter t:Ansprachemailtext2&quot;
   &quot;writeattach t:Ansprache.rtf&quot;
   writequeue
   mailwrite
   writemailto &quot;Reinhard&quot;
   &quot;writesubject Ansprache_von_Heiko&quot;
   &quot;writeletter t:Ansprachemailtext2&quot;
   &quot;writeattach t:Ansprache.wpf&quot;
   writequeue
end
/*OK, jetzt werden die Dateien verschickt. Einmal nur die 
Kurzbeschreibung,*/
/*einmal als RTF-Datei, einmal als WordPerfect-Datei.*/
if DB=&quot;J&quot; then do
   address DataBase
   GETFILENAME
   if Result=0 then do
       SAVE
   end
   'OPEN Text:DBProV3.1/Aufs&auml;tze/Aufs&auml;tze.db'
   'DEMARKRANGE $F1 &quot;#?&quot;'
   'SHOW ALL'

   'SETSEARCH FIELD PART'

   'SEARCHFIELD $F1'
   'SEARCH eig. Anspr.'
   'SEARCHFIELD $F2'
   'SETSEARCH GREATER'
   'SEARCHNEXT ' Nummer
   if RC=0 then do
     GETDATA $F1
     IF RESULT=&quot;EIG. Anspr.&quot; THEN DO
       SCHONDA=1
     END
   END
/* Hier wird in DBPro erstmal &uuml;berpr&uuml;ft, ob nicht schon ein Eintrag f&uuml;r*/
/* diese Ansprache vorhanden ist. Ein neuer wird nur gemacht, wenn diese*/
/* Nummer nicht gefunden wurde. (SCHONDA=0)*/
   IF SCHONDA ~=1 THEN DO
      'ADD'
      'PUTDATA $F1 eig. Anspr.'
      'PUTDATA $F2' NUMMER
      'PUTDATA $F3 Kuschel, H.'
/*Das Folgende ist eine Zeile*/
      
Erfolg=OPEN(&quot;Kurzdatei&quot;,&quot;Text:Wordworth7/Dokumente/Ansprachen/&quot;||Nummer||&quot;.
kurz&quot;,&quot;R&quot;)
/*bis hier*/
      If Erfolg then do
         Do while ~EOF(&quot;Kurzdatei&quot;)
            Zeile=Readln(&quot;Kurzdatei&quot;)
            Select
               when abbrev(Zeile,&quot;Text&quot;)=1 then do
                 'PUTDATA $F4 'substr(Zeile,7)
               end
               when abbrev(Zeile,&quot;Datum&quot;)=1 then do
                 DatumOrt=substr(Zeile,8)
               end
               when abbrev(Zeile,&quot;Ort&quot;)=1 then do
                 DatumOrt=DatumOrt||&quot;, &quot;||substr(Zeile,6)
                 'PUTDATA $F7 'DatumOrt
                 end
               when abbrev(Zeile,&quot;Stichworte&quot;)=1 then do
                 'PUTDATA $F12 'substr(Zeile,13)
               end
               Otherwise do
                 NOP
               end
            end
         end
      end
/* Jetzt werden die Daten in die einzelnen Felder meiner Datei 
geschrieben:*/
/* $F1 ist der Oberbegriff, $F2 die Nummer, $F3 der Autor. Alles andere*/
/* lese ich aus der Kurzdatei, die ich vorhin angelegt habe. Das wird 
dann*/
/* automatisch an die richtige Stelle geschrieben.*/

      'SORT $F1 $F2'
      'SAVE'
   end
end
/*Sortieren, speichern, Ende.*/
if Grossdruck = &quot;J&quot; then do
  address value Wordworthport
  SAVEAS NAME &quot;Text:Wordworth7/Dokumente/Ansprachen/000.GROSSDRUCK&quot;
  DOCUMENT A4 &quot;2cm&quot; &quot;2cm&quot; &quot;1.67cm&quot; &quot;2.54cm&quot; 1 &quot;2cm&quot; LANDSCAPEOFF
  CTRLDOWN
  CURSOR UP
  SHIFTDOWN
  CURSOR DOWN
  FONT SIZE &quot;24pt&quot;
  PARAGRAPH 0 0 0 FULL AUTO ONEHALF
  PRINTOPTIONS REVERSE BLACKANDWHITE ODDANDEVENPAGES
  SAVE
  PRINT
end
/*Gro&szlig;druck, falls gew&uuml;nscht. Das Dokumentformat mu&szlig; ge&auml;ndert werden,*/
/*weil ich normalerweise DinA4 quer zweispaltig bevorzuge.*/
/*Durch den ganzen Sermon mit CTRLDOWN etc. wird der gesamte Text*/
/*markiert. Dann stelle ich die Schriftgr&ouml;&szlig;e 24pt. ein, ein geeignetes*/
/*Absatzformat, und ab in den Drucker damit. */
If Normaldruck&#062;0 then do
 address value Wordworthport
 OPEN FILENAME &quot;Text:Wordworth7/Dokumente/Ansprachen/000.TEMP&quot; FORCE
 PRINTOPTIONS REVERSE BLACKANDWHITE COLLATE COPIES NORMALDRUCK 
ODDANDEVENPAGES
 PRINT
end
/*Die &quot;normale&quot; Druckvariante kommt nach dem Gro&szlig;druck, weil sie viel 
l&auml;nger*/
/*dauert. Querformat ist ziemlich langsam mit Wordworth. :( */
/*Beachte bei PRINTOPTIONS, da&szlig; eine initialisierte Variable drin ist!*/
/*An einer Stelle steht NORMALDRUCK. In dieser Variable ist gespeichert,*/
/*wie viele Ausdrucke ich davon haben will.*/
address command
If Mail=&quot;J&quot; then do
&quot;delete &#062;NIL: t:Ansprache.rtf&quot;
&quot;delete &#062;NIL: t:Ansprachemailtex#?&quot;
&quot;delete &#062;NIL:  t:Ansprache.wpf&quot;
If Normaldruck&#062;0 then do
&quot;delete &#062;NIL: Text:Wordworth7/Dokumente/Ansprachen/000.TEMP&quot;
END
/*Ein bi&szlig;chen aufr&auml;umen mu&szlig; sein. :)  */
_________________________________
So, das war ein ziemlich langes Programm. Viele weitere Programme, oft auch
kommentierte, findest Du im Aminet, im Verzeichnis util/rexx. Schau Dich 
ruhig einmal um. Evtl. findest Du dort auch schon das, was Du gerade 
schreiben wolltest... oder auf jeden Fall gute Anregungen f&uuml;rs eigene 
Programmieren.

****************************************************
5.5. Das Ende
Das war der ARexx-Kurs. Geschafft. Ich hoffe, Du hattest Spa&szlig; daran, und 
ich konnte das meiste halbwegs verst&auml;ndlich erkl&auml;ren. Wenn Du Probleme 
haben solltest, wende Dich an meine Adresse.
Ich m&ouml;chte demn&auml;chst den ganzen Kurs ins AmigaGuide-Format umwandeln und 
dann im Aminet ver&ouml;ffentlichen. Er wird voraussichtlich ver&ouml;ffentlicht 
unter docs/help/ARexx-Kurs.lha Da ich dabei ein paar AGuide-Kniffe einbauen 
will, br&auml;uchte ich jemanden, der/die diesen Guide unter AmigaOS 2.x testet. 
Ich wei&szlig; n&auml;mlich nicht, wie es da funktioniert. Au&szlig;erdem suche ich Leute, 
die mir ein paar Kurzinformationen zu anderen Texteditoren als GoldEd geben 
k&ouml;nnen, damit ich auch diese Editoren ber&uuml;cksichtigen kann.
Solltest Du Dich hier irgendwo angesprochen f&uuml;hlen, melde Dich doch bitte 
mal bei mir. Danke!

Heiko&laquo;
</pre>
</body>
</html>

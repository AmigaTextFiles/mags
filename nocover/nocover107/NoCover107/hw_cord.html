<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
  <HEAD>
    <META name="generator" content="HTML Tidy, see www.w3.org">
    <!-- Author = Cord Hagen -->

    <TITLE>Arbeitsspeicher</TITLE>
  </HEAD>

  <BODY background="cord1.jpg" text="#fffff0" bgcolor="#000000">
    <TABLE width="100%" border="0" cellpadding="8" summary="">
      <TR>
        <TD>
          <H1 align="center"><FONT color="#ffff00"><B>Warum ist
          Arbeitsspeicher so unterschiedlich teuer?</B></FONT></H1>

          <P>Diese Frage stellt man sich schnell mal, wenn man die
          doch erheblichen Preisunterschiede zwischen
          NoName-Modulen und Markenspeicher feststellt. Da ist dann
          auch von Parity und ECC die Rede, aber brauche ich das
          &uuml;berhaupt?</P>

          <P>Es bedarf tats&auml;chlich nur ein einziges falsch
          ausgelesene Bit, - eine winzige Speicherinformation
          falsch &uuml;bermittelt und schon kann das komplette
          System abst&uuml;rzen, einfrieren oder andere Fehler
          verursachen. In vielen F&auml;llen ist das nur ein
          Absturz unter Vielen und so denkt man oft nicht
          dar&uuml;ber nach, dass es sich um einen defekten
          Speicherbaustein handeln k&ouml;nnte. Es gibt zwar
          diverse Funktionen, die solchen Fehler vorbeugen sollen,
          aber oft greifen Diese nicht mehr ausreichend.</P>

          <P>Generell ist die Fehlerqute moderner Speicherbausteine
          sehr gering. F&uuml;hrende Markenhersteller unterziehen
          ihre Produkte diversen ausgiebigen Tests, bis ein Modul
          das Produktionswerk verl&auml;sst. Bei diesen Tests wird
          sofort alles aus dem Verkehr gezogen, was nicht alle
          Tests vollkommen unproblematisch durchlaufen konnte.
          Diese Tests umgehen Billighersteller aus Fernost manchmal
          ganz gern. Geraten defekte Module mit in den Verkauf,
          werden sie lieber innerhalb ihrer Garantieleistung
          anstandslos umgetauscht. Wenn aber solche Module nur
          einzelne defekte Bl&ouml;cke haben, arbeitet das System
          scheinbar einwandfrei mit solchen Modulen.
          Unerkl&auml;rliche Abst&uuml;rze oder das Einfrieren des
          Systems k&ouml;nnen die Folge sein. Aber auch bei den
          NoName-Speichermodulen sind fehlerhafte Bausteine eher
          der Einzelfall. Zum sogenannten SoftError, der dann
          vorliegt, wenn ein Bit umkippt - aus einer "0" also eine
          "1" wird und umgekehrt, k&ouml;nnen dann diese
          physikalischen Fehler dazu kommen. Der Speicher wird
          instabil und fr&uuml;her oder sp&auml;ter wackelt das
          ganze System. Aber wodurch entstehen physikalische Fehler
          &uuml;berhaupt erst? Zum einen gibt es tats&auml;chlich
          Alterungserscheinungen beispielsweise durch Diffusion und
          zum anderen k&ouml;nnen Spannungsspitzen, oder
          elektrische Aufladungen bei unsachgem&auml;&szlig;er
          Handhabung zu Speicherbausteindefekten f&uuml;hren. Sogar
          St&ouml;rungen durch radioaktive Strahlungen wurden
          angeblich festgestellt. Diese nat&uuml;rliche radioaktive
          Strahlung ensteht beispielsweise durch Isotope wir Uran,
          oder Thorium, was in den Kunststoffen der IC-Geh&auml;use
          enthalten ist. Beim Zerfall solcher Isotope senden sie
          &uuml;ber die Zeit Alpha Partikel aus dem Kern des
          Helium-Atoms. Diese Alphastrahlung kann durch ihre
          kinetische Energie die Ladung von Speicherzellen
          ver&auml;ndern. Fehlerhaft ausgelesene Daten sind dann
          die Folge.</P>

          <P>Um falsch ausgelesene und damit fehlerhaft
          geschriebene Daten durch einen Fehler im Speicher zu
          verhindern, gibt es verschiedene Verfahren. Eine einfache
          Technik zum Erkennen von Bitfehlern bei Speichermodulen
          ist die Parit&auml;tspr&uuml;fung. Mehr Sicherheit bei
          der Fehlererkennung bietet das ECC-Verfahren, das
          zus&auml;tzlich eine Fehlerkorrektur erm&ouml;glicht.
          Speichermodule unterscheidet man nach Non-Parity-,
          Parity- und ECC-Modulen. Obwohl Non-Parity-Module keine
          Fehlererkennung bieten, sind sie weit verbreitet. Der
          Grund sind die geringeren Kosten, weil im Gegensatz zu
          Parity- und ECC-L&ouml;sungen kein zus&auml;tzlicher
          Speicher ben&ouml;tigt wird.</P>

          <P><B>Parity</B><BR>
           Unterst&uuml;tzt die Speichersteuerung (Chipsatz) und
          das Speichermodul die Parit&auml;ts-Technik, dann erfolgt
          bei jedem Speichervorgang eine zus&auml;tzliche
          Pr&uuml;fsummenbildung. Zu jedem einzelnen Datenbytepaket
          kommt dann ein zus&auml;tzliches Pr&uuml;fsummenbit
          hinzu. Durch die Speichersteuerung erfolgt dann ein
          Vergleich, wodurch sichergestellt wird, dass das
          einzelene Datenpaket tats&auml;chlich unver&auml;ndert
          und damit fehlerfrei &uuml;bertragen wurde. Nur ein
          einziges ver&auml;ndertes Bit w&uuml;rde sofort die
          Pr&uuml;fsumme verf&auml;lschen und die Speichersteuerung
          weiss sofort, dass ein Fehler aufgetreten ist. Der
          Nachteil der Parit&auml;tspr&uuml;fung ist, dass sie zwar
          Fehler erkennen, aber nicht korrigieren kann. Das
          Verfahren arbeitet zudem nur zuverl&auml;ssig, wenn ein
          einzelnes Bit umkippt. Kippen dagegen mehrere Bits in
          einem Datenbyte um, so k&ouml;nnen die Fehler eventuell
          verdeckt bleiben.</P>

          <P><B>Fake Parity</B><BR>
           Speichermodule mit Parit&auml;t sind im Gegensatz zu
          Non-Parity-Modulen teurer. Parity-Module ben&ouml;tigen
          pro Byte neun Bit und somit mehr Speicher bei gleicher
          Kapazit&auml;t. Die Module besitzen ein zus&auml;tzliches
          DRAM-IC, dass nur der Parit&auml;tsspeicherung dient. Die
          Preise pro Modul steigen somit. Um Kosten zu sparen,
          verwenden manche Hersteller einen billigeren
          Fake-Parity-Chip. Die Idee hinter den Modulen mit dem
          Pseudo-Chip ist, Mainboards, die eine
          Parit&auml;tspr&uuml;fung dringend verlangen, billiger
          best&uuml;cken zu k&ouml;nnen. Mit der
          Verkaufsargumentation, dass die Parit&auml;tspr&uuml;fung
          nicht dringend ben&ouml;tigt sei, ergibt sich so ein
          nicht unerheblicher Wettbewerbsvorteil. Die Funktion der
          Fake-Parity-Module ist einfach: Der Pseudo-Chip generiert
          einfach eine Eins oder Null zu dem Zeitpunkt, wenn die
          Daten gelesen werden - entsprechend der Quersumme des
          Datenbyte. Das Modul liefert so der Speichersteuerung
          immer ein passendes Parit&auml;tsbit und t&auml;uscht die
          Richtigkeit der Daten vor. Die Speichersteuerung kann so
          z wischen einen Parity- und Fake-Parity-Speichermodul
          nicht unterscheiden. Haupts&auml;chlich wurden solche
          Mogelpackungen nur auf den alten SIMMs verwendet. Oft
          erkennt man alles lediglich an der Beschriftung der
          Speichermodule. So sind viele Fake-Parity-Module mit der
          Bezeichnung BP, GSM, MPEC, oder VT gekennzeichnet.
          Zumindest, wenn der Hersteller fair arbeitet, l&auml;sst
          sich auch schon am Preis ein so kostensparendes Modul
          ausmachen.</P>

          <P><B>ECC</B><BR>
           Der Hammingcode des ECC-Verfahrens ben&ouml;tigt bei
          typischen 32Bit breiten Datenstr&ouml;men
          zus&auml;tzliche Checkbits. Wenn der Prozessor eines
          64-Bit-Rechnersystems seine Daten in das DRAM schreibt,
          berechnet der ECC-Controller der Speichersteuerung acht
          ECC-Bits und h&auml;ngt diese an die Daten an. Das
          nunmehr 72-Bit-breite Datum wird im DIMM abgespeichert.
          W&auml;hrend eines Lesevorgangs berechnet der Chipsatz
          die ECC-Bits von den eingelesenen 64 Datenbits neu. Der
          Controller vergleicht dann den neu berechneten Code mit
          den ebenfalls eingelesenen Fehlercode, der beim Schreiben
          generiert wurde. Bei &Uuml;bereinstimmung der Codes ist
          das 64-Bit-Datenwort korrekt. Unterscheiden sich die
          Codes, l&auml;sst sich die Stelle, an der ein Bit gekippt
          ist, genau lokalisieren. Die Speichersteuerung
          &auml;ndert dann wieder das Attribut des gekippten Bit zu
          seinem urspr&uuml;nglichen Wert. Man k&ouml;nnte von den
          Fehlerwerten ableiten, dass ein
          32MByte-Parit&auml;tsspeicher gleich viele Fehler
          erzeugt, wie ein 1GByte-Speicher unter ECC-Controlling.
          Diese Werte rechtfertigen daher sehr wohl den Preis
          teurer Marken-ECC-Chips und werden gern in Serversystemen
          und wichtigen Workstations eingesetzt.</P>

          <P>Und wie sieht es in der t&auml;glichen Praxis aus?<BR>
           Ich hatte ein relativ labiles System und sehr
          h&auml;ufige und unerkl&auml;rliche Abst&uuml;rze. Mehr
          zuf&auml;llig starterte ich mein System zwischendurch von
          meiner Linux-Bootpartition, auf der sich auch ein recht
          gutes Speichertestprogramm befand. Ich lie&szlig; dieses
          Testprogramm laufen und in Speicherbereich 47MByte meines
          zweiten DIMMs tauchten tats&auml;chlich mehrere Fehler
          auf. Ich entfernte das defekte Modul und hatte nun aber
          auch nicht mehr viel Vertrauen in mein erstes
          NoName-Modul. So bestellte ich mir ein wesentlich
          teureres 512MByte-Modul von Infineon und mein System
          l&auml;uft seit dieser Investition deutlich stabiler. Wer
          also h&auml;ufige Systemabst&uuml;rze hat, die er nicht
          im Geringsten nachvollziehen kann, dem kann ich nur
          w&auml;rmstens empfehlen, etwas Geld in guten
          Markenspeicher mit ECC zu investieren.</P>

          <P>Euer Higgins<BR>
           Cord Hagen</P>
          <HR>
        </TD>
      </TR>
    </TABLE>
    <BR>
  </BODY>
</HTML>


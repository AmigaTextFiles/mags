<HTML>
<BODY ALINK=#FFAA00 VLINK=#000077 LINK=#0022CC BGCOLOR=#FFFFFF TEXT=#000000>
<TABLE BORDER=0 WIDTH="100%">
<TR><TD><PRE>
Workshops / Hintergrundberichte / Buchvorstellungen
---------------------------------------------------

1. Einf&uuml;hrung in die Reaction-Programmierung (von Martin R. Elsner)

Sechster und letzter Teil: Eigene Klassen

Die gr&ouml;&szlig;ten Probleme sollten jetzt schon gel&ouml;st sein, vielleicht ein 
eigenes Programm fertiggestellt, das ausgiebig Reaction-Objekte benutzt. 
Aber vielleicht ist der Eine oder Andere irgendwo auf eine Idee gesto&szlig;en, 
die er mit den Standard-Objekten nicht l&ouml;sen konnte. Aber auch daf&uuml;r gibt 
es eine L&ouml;sung: Man programmiert einfach eine eigene Klasse!

Zun&auml;chst ein kleiner Hinweis: Man sollte sich zun&auml;chst &uuml;berlegen, ob die 
Idee wirklich nicht mit den schon vorhandenen Objekten umgesetzt werden 
k&ouml;nnte. Manchmal findet man in den Autodocs Klassen oder Tags, die man noch 
nicht genau kennt und bisher untersch&auml;tzt hat. Z.B. kann ein Label nicht 
nur eine einfache Beschriftung, sondern mehrere Zeilen Text und Grafiken 
darstellen.
Au&szlig;erdem ist es empfehlenswert, Standardklassen zu verwenden, da diese 
meist gut getestet sind, weiterentwickelt werden und f&uuml;r einheitliche 
Oberfl&auml;che und Funktionsweise der Programme sorgen.

Falls man trotzdem nicht f&uuml;ndig wird, kann auch im Aminet recherchiert 
werden. Hier muss man aber auf die eben erw&auml;hnten Vorteile verzichten und 
hat meist auch keinen Zugriff auf die Quelltexte. Dann bleibt keine Wahl: 
Man muss selber ran!

Eine eigene Klasse wird immer von einer schon bestehenden abgeleitet. Dazu 
bietet sich eine Klasse an, die m&ouml;glichst viele der gew&uuml;nschten 
Eigenschaften schon mitbringt, sodass nur die Differenzen neu programmiert 
werden m&uuml;ssen. Man entscheidet sich z.B. daf&uuml;r, den Button als Basisklasse 
zu nutzen und eine neue - private - Klasse zu entwickeln.

Eine umfassende Einf&uuml;hrung in die Erzeugung eigener Klassen findet man im 
Kurs von Michael Christoph (http://www.meicky-soft.de/amiga-
magazin/reaction.html oder direkt bei http://www.amiga-
magazin.de/magazin/a02-00/programmieren.html). Hier m&ouml;chte ich deswegen nur 
als Beispiel eine Klasse auff&uuml;hren, die mir Stephan Rupprecht zur Verf&uuml;gung 
gestellt hat, und die ich f&uuml;r den Einsatz in ClassAction etwas modifiziert 
habe: eine Icon-Klasse, basierend auf Gadgetclass (also der Basisklasse f&uuml;r 
alle Gadgets), die ein Icon als Grafik verwendet und auf Mausklicks wie ein 
Button reagiert.

Zum Vergleich: Ein Button kann nat&uuml;rlich mit GA_Image auch mit einer 
beliebigen Grafik gef&uuml;ttert werden, die man z.B. &uuml;ber ein Penmap- oder 
Bitmap-Objekt aus einem Icon (bzw. der .info-Datei) erzeugt hat, 
vorausgesetzt, ein entsprechender DataType existiert im System. Allerdings 
ist der aktuelle Icon-Datatype nicht in der Lage, den Hintergrund der 
Grafik transparent zu zeichnen, und nicht auf allen Systemen ist ein Icon-
Datatype installiert. Unser Icon-Button soll dagegen immer funktionieren 
und das Icon wie auf der Workbench anzeigen. Der Einfachheit halber soll 
die Klasse nicht extern, sondern im Quellcode des Programms selbst 
enthalten sein.


Was ben&ouml;tigt man f&uuml;r eine eigene Klasse?

Nun, au&szlig;er der Festlegung auf eine Basisklasse wird haupts&auml;chlich eine 
Ereignisbehandlungsfunktion ben&ouml;tigt, und zwar in Form eines Hooks. Diese 
kann dann mit DoSuperMethod auf die geerbten Methoden zur&uuml;ckgreifen (falls 
sie existieren), kann aber auch (und das ist ja der Sinn der Sache) neue 
Funktionen einf&uuml;hren. Bei Gadgets kann dies haupts&auml;chlich die Darstellung 
oder die Reaktion auf Ereignisse betreffen.

F&uuml;r unseren Icon-Button m&uuml;ssen zwei Dinge geregelt werden: das Zeichen des 
Icons, f&uuml;r das wir DrawIconState verwenden, und die Reaktion auf einen 
Mausklick. Dazu existieren die Methoden GM_RENDER und GM_HANDLEINPUT, die 
wir in unserer Behandlungsroutine butclass_DISPATCH abfangen und in 
butclass_RENDER und butclass_HANDLEINPUT bearbeiten. Wir m&uuml;ssen nat&uuml;rlich 
das Icon selbst (d.h. einen Zeiger auf ein DiskObject) irgendwo speichern; 
dazu verwenden wir einfach GA_UserData. Wenn wir aber auch einen BackFill-
Hook unterst&uuml;tzen und auf einen Doppelklick pr&uuml;fen wollen, brauchen wir 
zus&auml;tzliche Eigenschaften in unserem Objekt: Dazu definieren wir eine 
Struktur InstanceData, die von Intuition angelegt und freigegeben wird, 
aber von uns genutzt werden kann. Diese muss bei OM_NEW bzw. 
OM_SET/OM_UPDATE gef&uuml;llt werden und kann dann in den sonstigen Routinen mit 
Hilfe des Makros INST_DATA verwendet werden. Au&szlig;erdem muss bei GM_DOMAIN 
die Gr&ouml;&szlig;e unseres Buttons ausgerechnet werden, damit die &uuml;bergeordneten 
Objekte den n&ouml;tigen Platz reservieren k&ouml;nnen.


Zun&auml;chst die n&ouml;tigen Includes, Abk&uuml;rzungen und Bibliotheken:

  #include &lt;intuition/intuition.h&gt;
  #include &lt;intuition/classusr.h&gt;
  #include &lt;intuition/classes.h&gt;
  #include &lt;intuition/gadgetclass.h&gt;
  #include &lt;intuition/cghooks.h&gt;
  #include &lt;workbench/icon.h&gt;
  #include &lt;workbench/workbench.h&gt;
  #include &lt;gadgets/layout.h&gt;
  #include &lt;libraries/gadtools.h&gt;
  #include &lt;clib/intuition_protos.h&gt;
  #include &lt;clib/alib_protos.h&gt;
  #include &lt;clib/icon_protos.h&gt;
  #include &lt;clib/layers_protos.h&gt;
  #include &lt;clib/utility_protos.h&gt;
  #include &lt;clib/dos_protos.h&gt;

  #define REG(reg,arg)    register __##reg arg
  #define G(x)            ((struct Gadget *)x)

  extern struct Library
    *IconBase,
    *DOSBase,
    *IntuitionBase,
    *UtilityBase,
    *LayersBase,
    *GfxBase;


Nun unsere zus&auml;tzlichen Daten pro Objekt, und die ben&ouml;tigten Funktionen:

  struct InstanceData{
    ULONG                    secs;      /* nur zur Pr&uuml;fung ...   */
    ULONG                    micro;     /* ...   auf Doppelklick */
    struct Hook             *backfill;  /* siehe butclass_RENDER */
    Object                  *parent;    /* siehe butclass_SET    */
  };

  ULONG butclass_DISPATCH( REG( a0, Class *cl ), REG( a2, Object *o ), REG( a1, Msg msg ) );
  ULONG butclass_DOMAIN( Class *cl, Object *o, struct gpDomain *gpd );
  ULONG butclass_HANDLEINPUT( Class *cl, Object *o, struct gpInput *gpi );
  ULONG butclass_RENDER( Class *cl, Object *o, struct gpRender *gpr );
  ULONG butclass_SET( Class *cl, Object *o, struct opSet *ops );


Zwei Funktionen erlauben das Anlegen und Freigeben unserer Klasse:


  IClass *MakeIconClass(){
    IClass   *cl;

    if( cl = MakeClass( NULL,
              "gadgetclass",                 /* die Basisklasse */
              NULL,
              sizeof( struct InstanceData ), /* Gr&ouml;&szlig;e unserer Zusatzdaten */
              0L ) )
      cl-&gt;cl_Dispatcher.h_Entry = (HOOKFUNC) butclass_DISPATCH;
      /* Einzige Initialisierung: Einsetzen unseres Dispatchers */
    return cl;
  }

  BOOL RemoveIconClass( IClass *cl ){
    if( cl ) return FreeClass(cl);
    else return FALSE;
  }

D.h. wir speichern den Zeiger (cl=MakeIconClass()). um ihn beim Erzeugen 
von Gadgets zu verwenden (gadget=(Object*)NewObject( cl,NULL,...)), und 
geben die Klasse zuletzt mit RemoveIconClass(cl) wieder frei.


Und jetzt der ganze Rest:


  ULONG butclass_DISPATCH( REG( a0, Class *cl ), REG( a2, Object *o ), REG( a1, Msg msg ) ){
    /* allgemeine Ereignisbehandlungroutine */
    ULONG ret = 0L;

    switch( msg-&gt;MethodID ){
      case GM_HANDLEINPUT:
      case GM_GOACTIVE: ret = butclass_HANDLEINPUT( cl, o, (struct gpInput *) msg ); break;

      case OM_SET:
      case OM_UPDATE:   ret = butclass_SET( cl, o, (struct opSet *) msg ); break;

      case GM_RENDER:   ret = butclass_RENDER( cl, o, (struct gpRender *) msg ); break;

      case GM_DOMAIN:   ret = butclass_DOMAIN( cl, o, (struct gpDomain *) msg ); break;

      case OM_NEW:{
        if( ret = DoSuperMethodA( cl, o, msg ) ){
          /* zus&auml;tzlich zum Erzeugen des Objekts m&uuml;ssen Eigenschaften gesetzt werden */
          butclass_SET( cl, (Object *) ret, (struct opSet *) msg );
        }
        break;
      }
      default: ret = DoSuperMethodA( cl, o, msg );
      /* in JEDEM Fall alle anderen Methoden an die Mutterklasse &uuml;bergeben! */
    }
    return ret;
  }

  /****************************************************************************/

  void butclass_redraw( Object *o, struct GadgetInfo *gi ){
    /* siehe butclass_HANDLEINPUT */
    struct RastPort *rp;

    if( rp = ObtainGIRPort( gi ) ){
      DoMethod( o, GM_RENDER, (ULONG) gi, (ULONG) rp, GREDRAW_REDRAW );
      ReleaseGIRPort( rp );
    }
  }

  /****************************************************************************/

  ULONG butclass_HANDLEINPUT( Class *cl, Object *o, struct gpInput *gpi ){
    /* Reaktion auf Eingaben (Mausklicks) des Benutzers */
    InputEvent *ie = gpi-&gt;gpi_IEvent;
    ULONG retval = GMR_MEACTIVE;

    if( ie ){
      switch( ie-&gt;ie_Class ){
        case IECLASS_RAWMOUSE:{
          switch( ie-&gt;ie_Code ){
            case SELECTUP: retval = GMR_NOREUSE; break;

            case SELECTDOWN:{
              InstanceData     *id = (InstanceData*)INST_DATA( cl, o );

  #ifdef DOUBLECLICK
              /* Falls das Icon eine GADGETUP-Botschaft nur nach einem  */
              /* Doppelklick liefern soll, m&uuml;ssen wir den Zeitpunkt des */
              /* letzten Klicks pr&uuml;fen:                                 */
              if( DoubleClick( id-&gt;secs, id-&gt;micro, ie-&gt;ie_TimeStamp.tv_secs,
                               ie-&gt;ie_TimeStamp.tv_micro ) ){
                G(o)-&gt;Flags |= GFLG_SELECTED;
                butclass_redraw( o, gpi-&gt;gpi_GInfo );
                retval = GMR_NOREUSE | GMR_VERIFY;

                id-&gt;secs = id-&gt;micro = 0UL;
              }else{
                id-&gt;secs  = ie-&gt;ie_TimeStamp.tv_secs;
                 id-&gt;micro = ie-&gt;ie_TimeStamp.tv_micro;
                G(o)-&gt;Flags ^= GFLG_SELECTED;
                butclass_redraw( o, gpi-&gt;gpi_GInfo );
                retval = GMR_NOREUSE;
              }
  #else
              /* GADGETUP nach einfachem Klick */
              G(o)-&gt;Flags |= GFLG_SELECTED;
              butclass_redraw( o, gpi-&gt;gpi_GInfo );
              retval = GMR_NOREUSE | GMR_VERIFY;
  #endif
            }
            break;

            case MENUDOWN: retval = GMR_REUSE; break;
          }
          break;
        }
      }
    }
    return retval;
  }

  /****************************************************************************/

  BOOL IsIconFrameless( struct DiskObject *icon ){
    /* Pr&uuml;ft, ob das Icon ohne Rahmen dargestellt werden muss */
    /* siehe butclass_RENDER*/
    ULONG frameless;

    IconControl( icon,ICONCTRLA_GetFrameless, (ULONG) &frameless,TAG_DONE );

    if( frameless == FALSE ){
      ULONG   globalfl;
      if( IconControl( NULL,ICONCTRLA_GetGlobalFrameless, (ULONG) &globalfl,TAG_DONE ) )
        frameless = globalfl;
    }

    return frameless;
  }

  /****************************************************************************/

  ULONG butclass_RENDER( Class *cl, Object *o, struct gpRender *gpr ){
    /* Zeichnen des Icons */
    RastPort         *rp = gpr-&gt;gpr_RPort;
    DiskObject       *icon = (struct DiskObject *) G(o)-&gt;UserData;
    Hook             *hook;
    InstanceData     *id = (InstanceData*)INST_DATA( cl, o );
    Layer            *layer = gpr-&gt;gpr_GInfo-&gt;gi_Layer;
    WORD             x = G(o)-&gt;LeftEdge, y = G(o)-&gt;TopEdge;

    /* Unter unserem Icon muss der richtige Hintergrund dargestellt werden: */
    hook = InstallLayerHook( layer, id-&gt;backfill );

    DrawIconState(rp, icon, NULL, x,y,
      (G(o)-&gt;Flags & GFLG_SELECTED) != 0L,
      ICONDRAWA_DrawInfo, (ULONG) gpr-&gt;gpr_GInfo-&gt;gi_DrInfo,
      ICONDRAWA_Frameless, IsIconFrameless( icon ),
      TAG_DONE );

    InstallLayerHook( layer, hook );

    return 0L;   }

  /****************************************************************************/

  ULONG butclass_SET( Class *cl, Object *o, struct opSet *ops ){
    /* Setzen der Eigenschaften */
    InstanceData     *id = (InstanceData*)INST_DATA( cl, o );     TagItem          *ti, *tlist = ops-&gt;ops_AttrList;
    DiskObject       *icon = NULL;

    while( ti = NextTagItem( &tlist ) ){
      switch( ti-&gt;ti_Tag ){
        case GA_BackFill:
          id-&gt;backfill = (Hook*) ti-&gt;ti_Data;
          break; 
        case LAYOUT_Parent:
          id-&gt;parent = (Object *) ti-&gt;ti_Data;
          break;

        case GA_UserData:
          icon = (struct DiskObject *) ti-&gt;ti_Data;
          break;
      }
    }

    if( id-&gt;parent && icon ){
      /* Berechnen der Icongr&ouml;&szlig;e und Mitteilung an das Parent-Objekt */
      Rectangle rect;
      UWORD     w,h;

      GetIconRectangle( NULL, icon, NULL, &rect,
        ICONDRAWA_Borderless, FALSE, TAG_DONE );
      /* Wir z&auml;hlen also den Rand mit */

      w = ( rect.MaxX - rect.MinX ) + 1;
      h = ( rect.MaxY - rect.MinY ) + 1;

      SetAttrs( id-&gt;parent,
        LAYOUT_ModifyChild, (ULONG) o,
        CHILD_MinWidth, w,
        CHILD_MinHeight, h,
        CHILD_MaxWidth, w,
        CHILD_MaxHeight, h,
        TAG_DONE );
      /* Dies war die einzige Stelle, f&uuml;r die wir id-&gt;Parent brauchten. */
      /* Da das Icon nachtr&auml;glich ge&auml;ndert werden kann, m&uuml;ssen wir es   */
      /* im Objekt speichern.                                           */
    }

    return (ops-&gt;MethodID != OM_NEW) ? DoSuperMethodA( cl, o, (Msg) ops ) : 1L;
    /* bei OM_NEW wurde die SuperMethod schon in HANDLEINPUT aufgerufen! */
  }

  /****************************************************************************/

  ULONG butclass_DOMAIN( Class *cl, Object *o, struct gpDomain *gpd ){
    /* Berechnen der Gadget-Ausma&szlig;e */
    InstanceData *id = (InstanceData*)INST_DATA( cl, o );
    DiskObject   *icon = (struct DiskObject *) G(o)-&gt;UserData;

    if( icon ){
      /* nur wenn das Icon schon geladen wurde, steht die Gr&ouml;&szlig;e des Buttons fest */
      struct Rectangle rect;
      UWORD            w,h;

      GetIconRectangle( NULL, icon, NULL, &rect,
        ICONDRAWA_Borderless, FALSE,
        TAG_DONE );

      w = rect.MaxX - rect.MinX + 1;
      h = rect.MaxY - rect.MinY + 1;

      switch( gpd-&gt;gpd_Which ){
        case GDOMAIN_MINIMUM:
          gpd-&gt;gpd_Domain.Width = w;
          gpd-&gt;gpd_Domain.Height = h;
          break;

        case GDOMAIN_NOMINAL:
        case GDOMAIN_MAXIMUM:
          gpd-&gt;gpd_Domain.Width = w;
          gpd-&gt;gpd_Domain.Height = h;
          break;
      }
      return 1L;
    }

    return 0L;
  }

Mit dieser Klasse k&ouml;nnen nun Objekte erzeugt und in Layouts eingef&uuml;gt 
werden, wobei mit GA_UserData ein Zeiger auf das Icon &uuml;bergeben werden 
muss, das man mit GetIconTags bei gegebenem Dateinamen laden kann.


Nat&uuml;rlich ist diese Klasse weder besonders trickreich noch v&ouml;llig 
ausgereift - man k&ouml;nnte noch weitere Eigenschaften hinzuf&uuml;gen, die die 
Reaktion auf Doppelklick oder einfachen Klick steuern etc. Aber ich hoffe, 
sie hat die grundlegende Funktionsweise eigener Klassen verst&auml;ndlich 
gemacht.


So, das soll's erst mal gewesen sein - wer mehr &uuml;ber Reaction wissen will, 
findet in den schon erw&auml;hnten Dokumenten und im Kurs von Michael Christoph 
noch viel mehr Informationen.

Ansonsten stehe ich nat&uuml;rlich weiterhin mit meinem beschr&auml;nkten Wissen zur 
Verf&uuml;gung ;)

euer 

Martin R. Elsner &lt;email@martin-elsner.de&gt;

</PRE></TD></TR>
</TABLE>
</BODY>
</HTML>
</PRE></TD></TR>
</TABLE>
</BODY>
</HTML>
